{"version":3,"sources":["/emsdk/emscripten/system/lib/libc/emscripten_get_heap_size.c","/emsdk/emscripten/system/lib/libc/musl/src/errno/__errno_location.c","/emsdk/emscripten/system/lib/libc/sbrk.c","/emsdk/emscripten/system/lib/dlmalloc.c","/emsdk/emscripten/system/lib/compiler-rt/stack_ops.S","../PVRTDecompress.cpp","/emsdk/emscripten/system/lib/libcxx/src/new.cpp","../../../../../../../../../../usr/local/Cellar/emscripten/4.0.23/libexec/cache/sysroot/include/c++/v1/__new/allocate.h","../../../../../../../../../../usr/local/Cellar/emscripten/4.0.23/libexec/cache/sysroot/include/c++/v1/__memory/allocator.h","/emsdk/emscripten/system/lib/libcxxabi/src/cxa_handlers.cpp","/emsdk/emscripten/system/lib/libcxx/src/new_helpers.cpp","/emsdk/emscripten/system/lib/libc/musl/src/exit/abort.c","/emsdk/emscripten/system/lib/libcxx/src/include/atomic_support.h","/emsdk/emscripten/system/lib/libc/musl/src/signal/setitimer.c","/emsdk/emscripten/system/lib/libc/raise.c","/emsdk/emscripten/system/lib/libc/musl/src/exit/_Exit.c","/emsdk/emscripten/system/lib/libc/pthread_sigmask.c","/emsdk/emscripten/system/lib/libc/musl/src/signal/sigaddset.c","/emsdk/emscripten/system/lib/libc/musl/src/signal/sigismember.c"],"sourcesContent":["/*\n * Copyright 2021 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n */\n\n#include <emscripten/heap.h>\n#include <stddef.h>\n\nsize_t emscripten_get_heap_size() {\n  return __builtin_wasm_memory_size(0) << 16;\n}\n","#include <errno.h>\n#include \"pthread_impl.h\"\n\n#if __EMSCRIPTEN__\n// For emscripten we use TLS here instead of `__pthread_self`, so that in single\n// threaded builds this gets lowered away to normal global variable.\nstatic _Thread_local int __errno_storage = 0;\n#endif\n\nint *__errno_location(void)\n{\n#if __EMSCRIPTEN__\n\treturn &__errno_storage;\n#else\n\treturn &__pthread_self()->errno_val;\n#endif\n}\n\nweak_alias(__errno_location, ___errno_location);\n","/*\n * Copyright 2019 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n *\n*/\n\n// libc files are compiled as -std=c99 which doesn't normally declare\n// max_align_t.\n#if __STDC_VERSION__ < 201112L\n#define __NEED_max_align_t\n#endif\n\n#include <errno.h>\n#include <limits.h>\n#include <stddef.h>\n#include <stdint.h>\n#ifdef __EMSCRIPTEN_SHARED_MEMORY__ // for error handling, see below\n#include <stdio.h>\n#include <stdlib.h>\n#endif\n\n#ifdef __EMSCRIPTEN_TRACING__\nvoid emscripten_memprof_sbrk_grow(intptr_t old, intptr_t new);\n#else\n#define emscripten_memprof_sbrk_grow(...) ((void)0)\n#endif\n\n#include <emscripten/heap.h>\n\nextern size_t __heap_base;\n\nstatic uintptr_t sbrk_val = (uintptr_t)&__heap_base;\n\nuintptr_t* emscripten_get_sbrk_ptr() {\n#ifdef __PIC__\n  // In relocatable code we may call emscripten_get_sbrk_ptr() during startup,\n  // potentially *before* the setup of the dynamically-linked __heap_base, when\n  // using SAFE_HEAP. (SAFE_HEAP instruments *all* memory accesses, so even the\n  // code doing dynamic linking itself ends up instrumented, which is why we can\n  // get such an instrumented call before sbrk_val has its proper value.)\n  if (sbrk_val == 0) {\n    sbrk_val = (uintptr_t)&__heap_base;\n  }\n#endif\n  return &sbrk_val;\n}\n\n// Enforce preserving a minimal alignof(maxalign_t) alignment for sbrk.\n#define SBRK_ALIGNMENT (__alignof__(max_align_t))\n\n#ifdef __EMSCRIPTEN_SHARED_MEMORY__\n#define READ_SBRK_PTR(sbrk_ptr) (__c11_atomic_load((_Atomic(uintptr_t)*)(sbrk_ptr), __ATOMIC_SEQ_CST))\n#else\n#define READ_SBRK_PTR(sbrk_ptr) (*(sbrk_ptr))\n#endif\n\nvoid *_sbrk64(int64_t increment) {\n  if (increment >= 0) {\n    increment = (increment + (SBRK_ALIGNMENT-1)) & ~((int64_t)SBRK_ALIGNMENT-1);\n  } else {\n    increment = -(-increment & ~((int64_t)SBRK_ALIGNMENT-1));\n  }\n\n  uintptr_t *sbrk_ptr = (uintptr_t*)emscripten_get_sbrk_ptr();\n\n  // To make sbrk thread-safe, implement a CAS loop to update the\n  // value of sbrk_ptr.\n  while (1) {\n    uintptr_t old_brk = READ_SBRK_PTR(sbrk_ptr);\n    int64_t new_brk64 = (int64_t)old_brk + increment;\n    uintptr_t new_brk = (uintptr_t)new_brk64;\n    // Check for a) an over/underflow, which would indicate that we are\n    // allocating over maximum addressable memory. and b) if necessary,\n    // increase the WebAssembly Memory size, and abort if that fails.\n    if (new_brk < 0 || new_brk64 != (int64_t)new_brk\n     || (new_brk > emscripten_get_heap_size() && !emscripten_resize_heap(new_brk))) {\n      errno = ENOMEM;\n      return (void*)-1;\n    }\n#ifdef __EMSCRIPTEN_SHARED_MEMORY__\n    // Attempt to update the dynamic top to new value. Another thread may have\n    // beat this one to the update, in which case we will need to start over\n    // by iterating the loop body again.\n    uintptr_t expected = old_brk;\n\n    __c11_atomic_compare_exchange_strong((_Atomic(uintptr_t)*)sbrk_ptr,\n      &expected, new_brk, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n\n    if (expected != old_brk) continue; // CAS failed, another thread raced in between.\n#else\n    *sbrk_ptr = new_brk;\n#endif\n\n    emscripten_memprof_sbrk_grow(old_brk, new_brk);\n    return (void*)old_brk;\n  }\n}\n\nvoid *sbrk(intptr_t increment_) {\n#if defined(__wasm64__) // TODO || !defined(wasm2gb)\n  // In the correct https://linux.die.net/man/2/sbrk spec, sbrk() parameter is\n  // intended to be treated as signed, meaning that it is not possible in a\n  // 32-bit program to sbrk alloc (or dealloc) more than 2GB of memory at once.\n\n  // Treat sbrk() parameter as signed.\n  return _sbrk64((int64_t)increment_);\n#else\n  // BUG: Currently the Emscripten test suite codifies expectations that sbrk()\n  // values passed to this function are to be treated as unsigned, which means\n  // that in 2GB and 4GB build modes, it is not possible to shrink memory.\n  // To satisfy that mode, treat sbrk() parameters in 32-bit builds as unsigned.\n  // https://github.com/emscripten-core/emscripten/issues/25138\n\n  // Treat sbrk() parameter as unsigned.\n  return _sbrk64((int64_t)(uintptr_t)increment_);\n#endif\n}\n\nint brk(void* ptr) {\n#ifdef __EMSCRIPTEN_SHARED_MEMORY__\n  // FIXME\n  printf(\"brk() is not threadsafe yet, https://github.com/emscripten-core/emscripten/issues/10006\");\n  abort();\n#else\n  uintptr_t last = (uintptr_t)sbrk(0);\n  if (sbrk((uintptr_t)ptr - last) == (void*)-1) {\n    return -1;\n  }\n  return 0;\n#endif\n}\n","\n/* XXX Emscripten XXX */\n#if __EMSCRIPTEN__\n// When building for wasm we export `malloc` and `emscripten_builtin_malloc` as\n// weak alias of the internal `dlmalloc` which is static to this file.\n#define DLMALLOC_EXPORT static\n/* mmap uses malloc, so malloc can't use mmap */\n#define HAVE_MMAP 0\n/* Emscripten's sbrk can interpret unsigned values greater than (MAX_SIZE_T / 2U) (2GB) correctly */\n#define UNSIGNED_MORECORE 1\n/* we can only grow the heap up anyhow, so don't try to trim */\n#define MORECORE_CANNOT_TRIM 1\n#ifndef DLMALLOC_DEBUG\n/* dlmalloc has many checks, calls to abort() increase code size,\n   leave them only in debug builds */\n#define ABORT __builtin_unreachable()\n/* allow malloc stats only in debug builds, which brings in stdio code. */\n#define NO_MALLOC_STATS 1\n#endif\n/* XXX Emscripten Tracing API. This defines away the code if tracing is disabled. */\n#include <emscripten/trace.h>\n\n#ifdef __EMSCRIPTEN_SHARED_MEMORY__\n#define USE_LOCKS 1\n#endif\n\n/* Make malloc() and free() threadsafe by securing the memory allocations with pthread mutexes. */\n#if __EMSCRIPTEN_PTHREADS__\n#define USE_SPIN_LOCKS 0 // Ensure we use pthread_mutex_t.\n#endif\n\n#ifndef MALLOC_ALIGNMENT\n#include <stddef.h>\n/* `malloc`ed pointers must be aligned at least as strictly as max_align_t. */\n#define MALLOC_ALIGNMENT (__alignof__(max_align_t))\n/*\n  Emscripten aligns even float128 to 64-bits, to save size and increase speed.\n  See https://github.com/emscripten-core/emscripten/issues/10072\n*/\n_Static_assert(MALLOC_ALIGNMENT == 8, \"max_align_t must be 8\");\n#endif\n\n#endif // __EMSCRIPTEN__\n\n\n#define __THROW\n#define __attribute_malloc__\n#define __wur\n\n\n/*\n This is a version (aka dlmalloc) of malloc/free/realloc written by\n Doug Lea and released to the public domain, as explained at\n http://creativecommons.org/publicdomain/zero/1.0/ Send questions,\n comments, complaints, performance data, etc to dl@cs.oswego.edu\n \n * Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea\n Note: There may be an updated version of this malloc obtainable at\n ftp://gee.cs.oswego.edu/pub/misc/malloc.c\n Check before installing!\n \n * Quickstart\n \n This library is all in one file to simplify the most common usage:\n ftp it, compile it (-O3), and link it into another program. All of\n the compile-time options default to reasonable values for use on\n most platforms.  You might later want to step through various\n compile-time and dynamic tuning options.\n \n For convenience, an include file for code using this malloc is at:\n ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.6.h\n You don't really need this .h file unless you call functions not\n defined in your system include files.  The .h file contains only the\n excerpts from this file needed for using this malloc on ANSI C/C++\n systems, so long as you haven't changed compile-time options about\n naming and tuning parameters.  If you do, then you can create your\n own malloc.h that does include all settings by cutting at the point\n indicated below. Note that you may already by default be using a C\n library containing a malloc that is based on some version of this\n malloc (for example in linux). You might still want to use the one\n in this file to customize settings or to avoid overheads associated\n with library versions.\n \n * Vital statistics:\n \n Supported pointer/size_t representation:       4 or 8 bytes\n size_t MUST be an unsigned type of the same width as\n pointers. (If you are using an ancient system that declares\n size_t as a signed type, or need it to be a different width\n than pointers, you can use a previous release of this malloc\n (e.g. 2.7.2) supporting these.)\n \n Alignment:                                     8 bytes (minimum)\n This suffices for nearly all current machines and C compilers.\n However, you can define MALLOC_ALIGNMENT to be wider than this\n if necessary (up to 128bytes), at the expense of using more space.\n \n Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)\n 8 or 16 bytes (if 8byte sizes)\n Each malloced chunk has a hidden word of overhead holding size\n and status information, and additional cross-check word\n if FOOTERS is defined.\n \n Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)\n 8-byte ptrs:  32 bytes    (including overhead)\n \n Even a request for zero bytes (i.e., malloc(0)) returns a\n pointer to something of the minimum allocatable size.\n The maximum overhead wastage (i.e., number of extra bytes\n allocated than were requested in malloc) is less than or equal\n to the minimum size, except for requests >= mmap_threshold that\n are serviced via mmap(), where the worst case wastage is about\n 32 bytes plus the remainder from a system page (the minimal\n mmap unit); typically 4096 or 8192 bytes.\n \n Security: static-safe; optionally more or less\n The \"security\" of malloc refers to the ability of malicious\n code to accentuate the effects of errors (for example, freeing\n space that is not currently malloc'ed or overwriting past the\n ends of chunks) in code that calls malloc.  This malloc\n guarantees not to modify any memory locations below the base of\n heap, i.e., static variables, even in the presence of usage\n errors.  The routines additionally detect most improper frees\n and reallocs.  All this holds as long as the static bookkeeping\n for malloc itself is not corrupted by some other means.  This\n is only one aspect of security -- these checks do not, and\n cannot, detect all possible programming errors.\n \n If FOOTERS is defined nonzero, then each allocated chunk\n carries an additional check word to verify that it was malloced\n from its space.  These check words are the same within each\n execution of a program using malloc, but differ across\n executions, so externally crafted fake chunks cannot be\n freed. This improves security by rejecting frees/reallocs that\n could corrupt heap memory, in addition to the checks preventing\n writes to statics that are always on.  This may further improve\n security at the expense of time and space overhead.  (Note that\n FOOTERS may also be worth using with MSPACES.)\n \n By default detected errors cause the program to abort (calling\n \"abort()\"). You can override this to instead proceed past\n errors by defining PROCEED_ON_ERROR.  In this case, a bad free\n has no effect, and a malloc that encounters a bad address\n caused by user overwrites will ignore the bad address by\n dropping pointers and indices to all known memory. This may\n be appropriate for programs that should continue if at all\n possible in the face of programming errors, although they may\n run out of memory because dropped memory is never reclaimed.\n \n If you don't like either of these options, you can define\n CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything\n else. And if if you are sure that your program using malloc has\n no errors or vulnerabilities, you can define INSECURE to 1,\n which might (or might not) provide a small performance improvement.\n \n It is also possible to limit the maximum total allocatable\n space, using malloc_set_footprint_limit. This is not\n designed as a security feature in itself (calls to set limits\n are not screened or privileged), but may be useful as one\n aspect of a secure implementation.\n \n Thread-safety: NOT thread-safe unless USE_LOCKS defined non-zero\n When USE_LOCKS is defined, each public call to malloc, free,\n etc is surrounded with a lock. By default, this uses a plain\n pthread mutex, win32 critical section, or a spin-lock if if\n available for the platform and not disabled by setting\n USE_SPIN_LOCKS=0.  However, if USE_RECURSIVE_LOCKS is defined,\n recursive versions are used instead (which are not required for\n base functionality but may be needed in layered extensions).\n Using a global lock is not especially fast, and can be a major\n bottleneck.  It is designed only to provide minimal protection\n in concurrent environments, and to provide a basis for\n extensions.  If you are using malloc in a concurrent program,\n consider instead using nedmalloc\n (http://www.nedprod.com/programs/portable/nedmalloc/) or\n ptmalloc (See http://www.malloc.de), which are derived from\n versions of this malloc.\n \n System requirements: Any combination of MORECORE and/or MMAP/MUNMAP\n This malloc can use unix sbrk or any emulation (invoked using\n the CALL_MORECORE macro) and/or mmap/munmap or any emulation\n (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system\n memory.  On most unix systems, it tends to work best if both\n MORECORE and MMAP are enabled.  On Win32, it uses emulations\n based on VirtualAlloc. It also uses common C library functions\n like memset.\n \n Compliance: I believe it is compliant with the Single Unix Specification\n (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably\n others as well.\n \n * Overview of algorithms\n \n This is not the fastest, most space-conserving, most portable, or\n most tunable malloc ever written. However it is among the fastest\n while also being among the most space-conserving, portable and\n tunable.  Consistent balance across these factors results in a good\n general-purpose allocator for malloc-intensive programs.\n \n In most ways, this malloc is a best-fit allocator. Generally, it\n chooses the best-fitting existing chunk for a request, with ties\n broken in approximately least-recently-used order. (This strategy\n normally maintains low fragmentation.) However, for requests less\n than 256bytes, it deviates from best-fit when there is not an\n exactly fitting available chunk by preferring to use space adjacent\n to that used for the previous small request, as well as by breaking\n ties in approximately most-recently-used order. (These enhance\n locality of series of small allocations.)  And for very large requests\n (>= 256Kb by default), it relies on system memory mapping\n facilities, if supported.  (This helps avoid carrying around and\n possibly fragmenting memory used only for large chunks.)\n \n All operations (except malloc_stats and mallinfo) have execution\n times that are bounded by a constant factor of the number of bits in\n a size_t, not counting any clearing in calloc or copying in realloc,\n or actions surrounding MORECORE and MMAP that have times\n proportional to the number of non-contiguous regions returned by\n system allocation routines, which is often just 1. In real-time\n applications, you can optionally suppress segment traversals using\n NO_SEGMENT_TRAVERSAL, which assures bounded execution even when\n system allocators return non-contiguous spaces, at the typical\n expense of carrying around more memory and increased fragmentation.\n \n The implementation is not very modular and seriously overuses\n macros. Perhaps someday all C compilers will do as good a job\n inlining modular code as can now be done by brute-force expansion,\n but now, enough of them seem not to.\n \n Some compilers issue a lot of warnings about code that is\n dead/unreachable only on some platforms, and also about intentional\n uses of negation on unsigned types. All known cases of each can be\n ignored.\n \n For a longer but out of date high-level description, see\n http://gee.cs.oswego.edu/dl/html/malloc.html\n \n * MSPACES\n If MSPACES is defined, then in addition to malloc, free, etc.,\n this file also defines mspace_malloc, mspace_free, etc. These\n are versions of malloc routines that take an \"mspace\" argument\n obtained using create_mspace, to control all internal bookkeeping.\n If ONLY_MSPACES is defined, only these versions are compiled.\n So if you would like to use this allocator for only some allocations,\n and your system malloc for others, you can compile with\n ONLY_MSPACES and then do something like...\n static mspace mymspace = create_mspace(0,0); // for example\n #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)\n \n (Note: If you only need one instance of an mspace, you can instead\n use \"USE_DL_PREFIX\" to relabel the global malloc.)\n \n You can similarly create thread-local allocators by storing\n mspaces as thread-locals. For example:\n static __thread mspace tlms = 0;\n void*  tlmalloc(size_t bytes) {\n if (tlms == 0) tlms = create_mspace(0, 0);\n return mspace_malloc(tlms, bytes);\n }\n void  tlfree(void* mem) { mspace_free(tlms, mem); }\n \n Unless FOOTERS is defined, each mspace is completely independent.\n You cannot allocate from one and free to another (although\n conformance is only weakly checked, so usage errors are not always\n caught). If FOOTERS is defined, then each chunk carries around a tag\n indicating its originating mspace, and frees are directed to their\n originating spaces. Normally, this requires use of locks.\n \n -------------------------  Compile-time options ---------------------------\n \n Be careful in setting #define values for numerical constants of type\n size_t. On some systems, literal values are not automatically extended\n to size_t precision unless they are explicitly casted. You can also\n use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.\n \n WIN32                    default: defined if _WIN32 defined\n Defining WIN32 sets up defaults for MS environment and compilers.\n Otherwise defaults are for unix. Beware that there seem to be some\n cases where this malloc might not be a pure drop-in replacement for\n Win32 malloc: Random-looking failures from Win32 GDI API's (eg;\n SetDIBits()) may be due to bugs in some video driver implementations\n when pixel buffers are malloc()ed, and the region spans more than\n one VirtualAlloc()ed region. Because dlmalloc uses a small (64Kb)\n default granularity, pixel buffers may straddle virtual allocation\n regions more often than when using the Microsoft allocator.  You can\n avoid this by using VirtualAlloc() and VirtualFree() for all pixel\n buffers rather than using malloc().  If this is not possible,\n recompile this malloc with a larger DEFAULT_GRANULARITY. Note:\n in cases where MSC and gcc (cygwin) are known to differ on WIN32,\n conditions use _MSC_VER to distinguish them.\n \n DLMALLOC_EXPORT       default: extern\n Defines how public APIs are declared. If you want to export via a\n Windows DLL, you might define this as\n #define DLMALLOC_EXPORT extern  __declspec(dllexport)\n If you want a POSIX ELF shared object, you might use\n #define DLMALLOC_EXPORT extern __attribute__((visibility(\"default\")))\n \n MALLOC_ALIGNMENT         default: (size_t)(2 * sizeof(void *))\n Controls the minimum alignment for malloc'ed chunks.  It must be a\n power of two and at least 8, even on machines for which smaller\n alignments would suffice. It may be defined as larger than this\n though. Note however that code and data structures are optimized for\n the case of 8-byte alignment.\n \n MSPACES                  default: 0 (false)\n If true, compile in support for independent allocation spaces.\n This is only supported if HAVE_MMAP is true.\n \n ONLY_MSPACES             default: 0 (false)\n If true, only compile in mspace versions, not regular versions.\n \n USE_LOCKS                default: 0 (false)\n Causes each call to each public routine to be surrounded with\n pthread or WIN32 mutex lock/unlock. (If set true, this can be\n overridden on a per-mspace basis for mspace versions.) If set to a\n non-zero value other than 1, locks are used, but their\n implementation is left out, so lock functions must be supplied manually,\n as described below.\n \n USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and spin locks available\n If true, uses custom spin locks for locking. This is currently\n supported only gcc >= 4.1, older gccs on x86 platforms, and recent\n MS compilers.  Otherwise, posix locks or win32 critical sections are\n used.\n \n USE_RECURSIVE_LOCKS      default: not defined\n If defined nonzero, uses recursive (aka reentrant) locks, otherwise\n uses plain mutexes. This is not required for malloc proper, but may\n be needed for layered allocators such as nedmalloc.\n \n LOCK_AT_FORK            default: not defined\n If defined nonzero, performs pthread_atfork upon initialization\n to initialize child lock while holding parent lock. The implementation\n assumes that pthread locks (not custom locks) are being used. In other\n cases, you may need to customize the implementation.\n \n FOOTERS                  default: 0\n If true, provide extra checking and dispatching by placing\n information in the footers of allocated chunks. This adds\n space and time overhead.\n \n INSECURE                 default: 0\n If true, omit checks for usage errors and heap space overwrites.\n \n USE_DL_PREFIX            default: NOT defined\n Causes compiler to prefix all public routines with the string 'dl'.\n This can be useful when you only want to use this malloc in one part\n of a program, using your regular system malloc elsewhere.\n \n MALLOC_INSPECT_ALL       default: NOT defined\n If defined, compiles malloc_inspect_all and mspace_inspect_all, that\n perform traversal of all heap space.  Unless access to these\n functions is otherwise restricted, you probably do not want to\n include them in secure implementations.\n \n ABORT                    default: defined as abort()\n Defines how to abort on failed checks.  On most systems, a failed\n check cannot die with an \"assert\" or even print an informative\n message, because the underlying print routines in turn call malloc,\n which will fail again.  Generally, the best policy is to simply call\n abort(). It's not very useful to do more than this because many\n errors due to overwriting will show up as address faults (null, odd\n addresses etc) rather than malloc-triggered checks, so will also\n abort.  Also, most compilers know that abort() does not return, so\n can better optimize code conditionally calling it.\n \n PROCEED_ON_ERROR           default: defined as 0 (false)\n Controls whether detected bad addresses cause them to bypassed\n rather than aborting. If set, detected bad arguments to free and\n realloc are ignored. And all bookkeeping information is zeroed out\n upon a detected overwrite of freed heap space, thus losing the\n ability to ever return it from malloc again, but enabling the\n application to proceed. If PROCEED_ON_ERROR is defined, the\n static variable malloc_corruption_error_count is compiled in\n and can be examined to see if errors have occurred. This option\n generates slower code than the default abort policy.\n \n DEBUG                    default: NOT defined\n The DEBUG setting is mainly intended for people trying to modify\n this code or diagnose problems when porting to new platforms.\n However, it may also be able to better isolate user errors than just\n using runtime checks.  The assertions in the check routines spell\n out in more detail the assumptions and invariants underlying the\n algorithms.  The checking is fairly extensive, and will slow down\n execution noticeably. Calling malloc_stats or mallinfo with DEBUG\n set will attempt to check every non-mmapped allocated and free chunk\n in the course of computing the summaries.\n \n ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)\n Debugging assertion failures can be nearly impossible if your\n version of the assert macro causes malloc to be called, which will\n lead to a cascade of further failures, blowing the runtime stack.\n ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),\n which will usually make debugging easier.\n \n MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32\n The action to take before \"return 0\" when malloc fails to be able to\n return memory because there is none available.\n \n HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES\n True if this system supports sbrk or an emulation of it.\n \n MORECORE                  default: sbrk\n The name of the sbrk-style system routine to call to obtain more\n memory.  See below for guidance on writing custom MORECORE\n functions. The type of the argument to sbrk/MORECORE varies across\n systems.  It cannot be size_t, because it supports negative\n arguments, so it is normally the signed type of the same width as\n size_t (sometimes declared as \"intptr_t\").  It doesn't much matter\n though. Internally, we only call it with arguments less than half\n the max value of a size_t, which should work across all reasonable\n possibilities, although sometimes generating compiler warnings.\n \n MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE\n If true, take advantage of fact that consecutive calls to MORECORE\n with positive arguments always return contiguous increasing\n addresses.  This is true of unix sbrk. It does not hurt too much to\n set it true anyway, since malloc copes with non-contiguities.\n Setting it false when definitely non-contiguous saves time\n and possibly wasted space it would take to discover this though.\n \n UNSIGNED_MORECORE         default: 0 (false)\n True if MORECORE can only handle unsigned arguments. This sets\n MORECORE_CANNOT_TRIM to 1 (true).\n\n MORECORE_CANNOT_TRIM      default: NOT defined\n True if MORECORE cannot release space back to the system when given\n negative arguments. This is generally necessary only if you are\n using a hand-crafted MORECORE function that cannot handle negative\n arguments.\n \n NO_SEGMENT_TRAVERSAL       default: 0\n If non-zero, suppresses traversals of memory segments\n returned by either MORECORE or CALL_MMAP. This disables\n merging of segments that are contiguous, and selectively\n releasing them to the OS if unused, but bounds execution times.\n \n HAVE_MMAP                 default: 1 (true)\n True if this system supports mmap or an emulation of it.  If so, and\n HAVE_MORECORE is not true, MMAP is used for all system\n allocation. If set and HAVE_MORECORE is true as well, MMAP is\n primarily used to directly allocate very large blocks. It is also\n used as a backup strategy in cases where MORECORE fails to provide\n space from system. Note: A single call to MUNMAP is assumed to be\n able to unmap memory that may have be allocated using multiple calls\n to MMAP, so long as they are adjacent.\n \n HAVE_MREMAP               default: 1 on linux, else 0\n If true realloc() uses mremap() to re-allocate large blocks and\n extend or shrink allocation spaces.\n \n MMAP_CLEARS               default: 1 except on WINCE.\n True if mmap clears memory so calloc doesn't need to. This is true\n for standard unix mmap using /dev/zero and on WIN32 except for WINCE.\n \n USE_BUILTIN_FFS            default: 0 (i.e., not used)\n Causes malloc to use the builtin ffs() function to compute indices.\n Some compilers may recognize and intrinsify ffs to be faster than the\n supplied C version. Also, the case of x86 using gcc is special-cased\n to an asm instruction, so is already as fast as it can be, and so\n this setting has no effect. Similarly for Win32 under recent MS compilers.\n (On most x86s, the asm version is only slightly faster than the C version.)\n \n malloc_getpagesize         default: derive from system includes, or 4096.\n The system page size. To the extent possible, this malloc manages\n memory from the system in page-size units.  This may be (and\n usually is) a function rather than a constant. This is ignored\n if WIN32, where page size is determined using getSystemInfo during\n initialization.\n \n USE_DEV_RANDOM             default: 0 (i.e., not used)\n Causes malloc to use /dev/random to initialize secure magic seed for\n stamping footers. Otherwise, the current time is used.\n \n NO_MALLINFO                default: 0\n If defined, don't compile \"mallinfo\". This can be a simple way\n of dealing with mismatches between system declarations and\n those in this file.\n \n MALLINFO_FIELD_TYPE        default: size_t\n The type of the fields in the mallinfo struct. This was originally\n defined as \"int\" in SVID etc, but is more usefully defined as\n size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set\n \n NO_MALLOC_STATS            default: 0\n If defined, don't compile \"malloc_stats\". This avoids calls to\n fprintf and bringing in stdio dependencies you might not want.\n \n REALLOC_ZERO_BYTES_FREES    default: not defined\n This should be set if a call to realloc with zero bytes should\n be the same as a call to free. Some people think it should. Otherwise,\n since this malloc returns a unique pointer for malloc(0), so does\n realloc(p, 0).\n \n LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H\n LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H\n LACKS_STDLIB_H LACKS_SCHED_H LACKS_TIME_H  default: NOT defined unless on WIN32\n Define these if your system does not have these header files.\n You might need to manually insert some of the declarations they provide.\n \n DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,\n system_info.dwAllocationGranularity in WIN32,\n otherwise 64K.\n Also settable using mallopt(M_GRANULARITY, x)\n The unit for allocating and deallocating memory from the system.  On\n most systems with contiguous MORECORE, there is no reason to\n make this more than a page. However, systems with MMAP tend to\n either require or encourage larger granularities.  You can increase\n this value to prevent system allocation functions to be called so\n often, especially if they are slow.  The value must be at least one\n page and must be a power of two.  Setting to 0 causes initialization\n to either page size or win32 region size.  (Note: In previous\n versions of malloc, the equivalent of this option was called\n \"TOP_PAD\")\n \n DEFAULT_TRIM_THRESHOLD    default: 2MB\n Also settable using mallopt(M_TRIM_THRESHOLD, x)\n The maximum amount of unused top-most memory to keep before\n releasing via malloc_trim in free().  Automatic trimming is mainly\n useful in long-lived programs using contiguous MORECORE.  Because\n trimming via sbrk can be slow on some systems, and can sometimes be\n wasteful (in cases where programs immediately afterward allocate\n more large chunks) the value should be high enough so that your\n overall system performance would improve by releasing this much\n memory.  As a rough guide, you might set to a value close to the\n average size of a process (program) running on your system.\n Releasing this much memory would allow such a process to run in\n memory.  Generally, it is worth tuning trim thresholds when a\n program undergoes phases where several large chunks are allocated\n and released in ways that can reuse each other's storage, perhaps\n mixed with phases where there are no such chunks at all. The trim\n value must be greater than page size to have any useful effect.  To\n disable trimming completely, you can set to MAX_SIZE_T. Note that the trick\n some people use of mallocing a huge space and then freeing it at\n program startup, in an attempt to reserve system memory, doesn't\n have the intended effect under automatic trimming, since that memory\n will immediately be returned to the system.\n \n DEFAULT_MMAP_THRESHOLD       default: 256K\n Also settable using mallopt(M_MMAP_THRESHOLD, x)\n The request size threshold for using MMAP to directly service a\n request. Requests of at least this size that cannot be allocated\n using already-existing space will be serviced via mmap.  (If enough\n normal freed space already exists it is used instead.)  Using mmap\n segregates relatively large chunks of memory so that they can be\n individually obtained and released from the host system. A request\n serviced through mmap is never reused by any other request (at least\n not directly; the system may just so happen to remap successive\n requests to the same locations).  Segregating space in this way has\n the benefits that: Mmapped space can always be individually released\n back to the system, which helps keep the system level memory demands\n of a long-lived program low.  Also, mapped memory doesn't become\n `locked' between other chunks, as can happen with normally allocated\n chunks, which means that even trimming via malloc_trim would not\n release them.  However, it has the disadvantage that the space\n cannot be reclaimed, consolidated, and then used to service later\n requests, as happens with normal chunks.  The advantages of mmap\n nearly always outweigh disadvantages for \"large\" chunks, but the\n value of \"large\" may vary across systems.  The default is an\n empirically derived value that works well in most systems. You can\n disable mmap by setting to MAX_SIZE_T.\n \n MAX_RELEASE_CHECK_RATE   default: 4095 unless not HAVE_MMAP\n The number of consolidated frees between checks to release\n unused segments when freeing. When using non-contiguous segments,\n especially with multiple mspaces, checking only for topmost space\n doesn't always suffice to trigger trimming. To compensate for this,\n free() will, with a period of MAX_RELEASE_CHECK_RATE (or the\n current number of segments, if greater) try to release unused\n segments to the OS when freeing chunks that result in\n consolidation. The best value for this parameter is a compromise\n between slowing down frees with relatively costly checks that\n rarely trigger versus holding on to unused memory. To effectively\n disable, set to MAX_SIZE_T. This may lead to a very slight speed\n improvement at the expense of carrying around more memory.\n */\n\n/* Version identifier to allow people to support multiple versions */\n#ifndef DLMALLOC_VERSION\n#define DLMALLOC_VERSION 20806\n#endif /* DLMALLOC_VERSION */\n\n#ifndef DLMALLOC_EXPORT\n#define DLMALLOC_EXPORT extern\n#endif\n\n#ifndef WIN32\n#ifdef _WIN32\n#define WIN32 1\n#endif  /* _WIN32 */\n#ifdef _WIN32_WCE\n#define LACKS_FCNTL_H\n#define WIN32 1\n#endif /* _WIN32_WCE */\n#endif  /* WIN32 */\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#include <tchar.h>\n#define HAVE_MMAP 1\n#define HAVE_MORECORE 0\n#define LACKS_UNISTD_H\n#define LACKS_SYS_PARAM_H\n#define LACKS_SYS_MMAN_H\n#define LACKS_STRING_H\n#define LACKS_STRINGS_H\n#define LACKS_SYS_TYPES_H\n#define LACKS_ERRNO_H\n#define LACKS_SCHED_H\n#ifndef MALLOC_FAILURE_ACTION\n#define MALLOC_FAILURE_ACTION\n#endif /* MALLOC_FAILURE_ACTION */\n#ifndef MMAP_CLEARS\n#ifdef _WIN32_WCE /* WINCE reportedly does not clear */\n#define MMAP_CLEARS 0\n#else\n#define MMAP_CLEARS 1\n#endif /* _WIN32_WCE */\n#endif /*MMAP_CLEARS */\n#endif  /* WIN32 */\n\n#if defined(DARWIN) || defined(_DARWIN)\n/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */\n#ifndef HAVE_MORECORE\n#define HAVE_MORECORE 0\n#define HAVE_MMAP 1\n/* OSX allocators provide 16 byte alignment */\n#ifndef MALLOC_ALIGNMENT\n#define MALLOC_ALIGNMENT ((size_t)16U)\n#endif\n#endif  /* HAVE_MORECORE */\n#endif  /* DARWIN */\n\n#ifndef LACKS_SYS_TYPES_H\n#include <sys/types.h>  /* For size_t */\n#endif  /* LACKS_SYS_TYPES_H */\n\n/* The maximum possible size_t value has all bits set */\n#define MAX_SIZE_T           (~(size_t)0)\n\n#ifndef USE_LOCKS /* ensure true if spin or recursive locks set */\n/* XXX: The following block adapted locally to avoid\n        clean up new Clang -Wexpansion-to-defined warnings.\n        http://lists.llvm.org/pipermail/cfe-commits/Week-of-Mon-20160118/147239.html */\n#if (defined(USE_SPIN_LOCKS) && USE_SPIN_LOCKS != 0) || \\\n    (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0)\n#define USE_LOCKS 1\n#else\n#define USE_LOCKS 0\n#endif\n#endif /* USE_LOCKS */\n\n#if USE_LOCKS /* Spin locks for gcc >= 4.1, older gcc on x86, MSC >= 1310 */\n#if ((defined(__GNUC__) &&                                              \\\n((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) ||      \\\ndefined(__i386__) || defined(__x86_64__))) ||                    \\\n(defined(_MSC_VER) && _MSC_VER>=1310))\n#ifndef USE_SPIN_LOCKS\n#define USE_SPIN_LOCKS 1\n#endif /* USE_SPIN_LOCKS */\n#elif USE_SPIN_LOCKS\n#error \"USE_SPIN_LOCKS defined without implementation\"\n#endif /* ... locks available... */\n#elif !defined(USE_SPIN_LOCKS)\n#define USE_SPIN_LOCKS 0\n#endif /* USE_LOCKS */\n\n#ifndef ONLY_MSPACES\n#define ONLY_MSPACES 0\n#endif  /* ONLY_MSPACES */\n#ifndef MSPACES\n#if ONLY_MSPACES\n#define MSPACES 1\n#else   /* ONLY_MSPACES */\n#define MSPACES 0\n#endif  /* ONLY_MSPACES */\n#endif  /* MSPACES */\n#ifndef MALLOC_ALIGNMENT\n#define MALLOC_ALIGNMENT ((size_t)(2 * sizeof(void *)))\n#endif  /* MALLOC_ALIGNMENT */\n#ifndef FOOTERS\n#define FOOTERS 0\n#endif  /* FOOTERS */\n#ifndef ABORT\n#define ABORT  abort()\n#endif  /* ABORT */\n#ifndef ABORT_ON_ASSERT_FAILURE\n#define ABORT_ON_ASSERT_FAILURE 1\n#endif  /* ABORT_ON_ASSERT_FAILURE */\n#ifndef PROCEED_ON_ERROR\n#define PROCEED_ON_ERROR 0\n#endif  /* PROCEED_ON_ERROR */\n\n#ifndef INSECURE\n#define INSECURE 0\n#endif  /* INSECURE */\n#ifndef MALLOC_INSPECT_ALL\n#define MALLOC_INSPECT_ALL 0\n#endif  /* MALLOC_INSPECT_ALL */\n#ifndef HAVE_MMAP\n#define HAVE_MMAP 1\n#endif  /* HAVE_MMAP */\n#ifndef MMAP_CLEARS\n#define MMAP_CLEARS 1\n#endif  /* MMAP_CLEARS */\n#ifndef HAVE_MREMAP\n#ifdef linux\n#define HAVE_MREMAP 1\n#define _GNU_SOURCE /* Turns on mremap() definition */\n#else   /* linux */\n#define HAVE_MREMAP 0\n#endif  /* linux */\n#endif  /* HAVE_MREMAP */\n#ifndef MALLOC_FAILURE_ACTION\n#define MALLOC_FAILURE_ACTION  errno = ENOMEM;\n#endif  /* MALLOC_FAILURE_ACTION */\n#ifndef HAVE_MORECORE\n#if ONLY_MSPACES\n#define HAVE_MORECORE 0\n#else   /* ONLY_MSPACES */\n#define HAVE_MORECORE 1\n#endif  /* ONLY_MSPACES */\n#endif  /* HAVE_MORECORE */\n#ifndef UNSIGNED_MORECORE\n#define UNSIGNED_MORECORE 0\n#endif  /* UNSIGNED_MORECORE */\n#if UNSIGNED_MORECORE\n#define MORECORE_CANNOT_TRIM 1\n#endif  /* UNSIGNED_MORECORE */\n#if !HAVE_MORECORE\n#define MORECORE_CONTIGUOUS 0\n#else   /* !HAVE_MORECORE */\n#define MORECORE_DEFAULT sbrk\n#ifndef MORECORE_CONTIGUOUS\n#define MORECORE_CONTIGUOUS 1\n#endif  /* MORECORE_CONTIGUOUS */\n#endif  /* HAVE_MORECORE */\n#ifndef DEFAULT_GRANULARITY\n#if (MORECORE_CONTIGUOUS || defined(WIN32))\n#define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */\n#else   /* MORECORE_CONTIGUOUS */\n#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)\n#endif  /* MORECORE_CONTIGUOUS */\n#endif  /* DEFAULT_GRANULARITY */\n#ifndef DEFAULT_TRIM_THRESHOLD\n#ifndef MORECORE_CANNOT_TRIM\n#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)\n#else   /* MORECORE_CANNOT_TRIM */\n#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T\n#endif  /* MORECORE_CANNOT_TRIM */\n#endif  /* DEFAULT_TRIM_THRESHOLD */\n#ifndef DEFAULT_MMAP_THRESHOLD\n#if HAVE_MMAP\n#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)\n#else   /* HAVE_MMAP */\n#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T\n#endif  /* HAVE_MMAP */\n#endif  /* DEFAULT_MMAP_THRESHOLD */\n#ifndef MAX_RELEASE_CHECK_RATE\n#if HAVE_MMAP\n#define MAX_RELEASE_CHECK_RATE 4095\n#else\n#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T\n#endif /* HAVE_MMAP */\n#endif /* MAX_RELEASE_CHECK_RATE */\n#ifndef USE_BUILTIN_FFS\n#define USE_BUILTIN_FFS 0\n#endif  /* USE_BUILTIN_FFS */\n#ifndef USE_DEV_RANDOM\n#define USE_DEV_RANDOM 0\n#endif  /* USE_DEV_RANDOM */\n#ifndef NO_MALLINFO\n#define NO_MALLINFO 0\n#endif  /* NO_MALLINFO */\n#ifndef MALLINFO_FIELD_TYPE\n#define MALLINFO_FIELD_TYPE size_t\n#endif  /* MALLINFO_FIELD_TYPE */\n#ifndef NO_MALLOC_STATS\n#define NO_MALLOC_STATS 0\n#endif  /* NO_MALLOC_STATS */\n#ifndef NO_SEGMENT_TRAVERSAL\n#define NO_SEGMENT_TRAVERSAL 0\n#endif /* NO_SEGMENT_TRAVERSAL */\n\n/*\n mallopt tuning options.  SVID/XPG defines four standard parameter\n numbers for mallopt, normally defined in malloc.h.  None of these\n are used in this malloc, so setting them has no effect. But this\n malloc does support the following options.\n */\n\n#define M_TRIM_THRESHOLD     (-1)\n#define M_GRANULARITY        (-2)\n#define M_MMAP_THRESHOLD     (-3)\n\n/* ------------------------ Mallinfo declarations ------------------------ */\n\n#if !NO_MALLINFO\n/*\n This version of malloc supports the standard SVID/XPG mallinfo\n routine that returns a struct containing usage properties and\n statistics. It should work on any system that has a\n /usr/include/malloc.h defining struct mallinfo.  The main\n declaration needed is the mallinfo struct that is returned (by-copy)\n by mallinfo().  The malloinfo struct contains a bunch of fields that\n are not even meaningful in this version of malloc.  These fields are\n are instead filled by mallinfo() with other numbers that might be of\n interest.\n \n HAVE_USR_INCLUDE_MALLOC_H should be set if you have a\n /usr/include/malloc.h file that includes a declaration of struct\n mallinfo.  If so, it is included; else a compliant version is\n declared below.  These must be precisely the same for mallinfo() to\n work.  The original SVID version of this struct, defined on most\n systems with mallinfo, declares all fields as ints. But some others\n define as unsigned long. If your system defines the fields using a\n type of different width than listed here, you MUST #include your\n system version and #define HAVE_USR_INCLUDE_MALLOC_H.\n */\n\n/* #define HAVE_USR_INCLUDE_MALLOC_H */\n\n#ifdef HAVE_USR_INCLUDE_MALLOC_H\n#include \"/usr/include/malloc.h\"\n#else /* HAVE_USR_INCLUDE_MALLOC_H */\n#ifndef STRUCT_MALLINFO_DECLARED\n/* HP-UX (and others?) redefines mallinfo unless _STRUCT_MALLINFO is defined */\n#define _STRUCT_MALLINFO\n#define STRUCT_MALLINFO_DECLARED 1\nstruct mallinfo {\n    MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */\n    MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */\n    MALLINFO_FIELD_TYPE smblks;   /* always 0 */\n    MALLINFO_FIELD_TYPE hblks;    /* always 0 */\n    MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */\n    MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */\n    MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */\n    MALLINFO_FIELD_TYPE uordblks; /* total allocated space */\n    MALLINFO_FIELD_TYPE fordblks; /* total free space */\n    MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */\n};\n#endif /* STRUCT_MALLINFO_DECLARED */\n#endif /* HAVE_USR_INCLUDE_MALLOC_H */\n#endif /* NO_MALLINFO */\n\n/*\n Try to persuade compilers to inline. The most critical functions for\n inlining are defined as macros, so these aren't used for them.\n */\n\n#ifndef FORCEINLINE\n#if defined(__GNUC__)\n#define FORCEINLINE __inline __attribute__ ((always_inline))\n#elif defined(_MSC_VER)\n#define FORCEINLINE __forceinline\n#endif\n#endif\n#ifndef NOINLINE\n#if defined(__GNUC__)\n#define NOINLINE __attribute__ ((noinline))\n#elif defined(_MSC_VER)\n#define NOINLINE __declspec(noinline)\n#else\n#define NOINLINE\n#endif\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#ifndef FORCEINLINE\n#define FORCEINLINE inline\n#endif\n#endif /* __cplusplus */\n#ifndef FORCEINLINE\n#define FORCEINLINE\n#endif\n    \n#if !ONLY_MSPACES\n    \n    /* ------------------- Declarations of public routines ------------------- */\n    \n#ifndef USE_DL_PREFIX\n// XXX Emscripten XXX\n#if defined(__EMSCRIPTEN__)\nvoid* __libc_malloc(size_t) __attribute__((weak, alias(\"dlmalloc\")));\nvoid  __libc_free(void*) __attribute__((weak, alias(\"dlfree\")));\nvoid* __libc_calloc(size_t) __attribute__((weak, alias(\"dlcalloc\")));\nvoid* __libc_realloc(void*, size_t) __attribute__((weak, alias(\"dlrealloc\")));\nvoid* malloc(size_t) __attribute__((weak, alias(\"dlmalloc\")));\nvoid  free(void*) __attribute__((weak, alias(\"dlfree\")));\nvoid* calloc(size_t, size_t) __attribute__((weak, alias(\"dlcalloc\")));\nvoid* realloc(void*, size_t) __attribute__((weak, alias(\"dlrealloc\")));\nvoid* realloc_in_place(void*, size_t) __attribute__((weak, alias(\"dlrealloc_in_place\")));\nvoid* memalign(size_t, size_t) __attribute__((weak, alias(\"dlmemalign\")));\nint posix_memalign(void**, size_t, size_t) __attribute__((weak, alias(\"dlposix_memalign\")));\nvoid* valloc(size_t) __attribute__((weak, alias(\"dlvalloc\")));\nvoid* pvalloc(size_t) __attribute__((weak, alias(\"dlpvalloc\")));\n#if !NO_MALLINFO\nstruct mallinfo mallinfo(void) __attribute__((weak, alias(\"dlmallinfo\")));\n#endif\nint mallopt(int, int) __attribute__((weak, alias(\"dlmallopt\")));\nint malloc_trim(size_t) __attribute__((weak, alias(\"dlmalloc_trim\")));\n#if !NO_MALLOC_STATS\nvoid malloc_stats(void) __attribute__((weak, alias(\"dlmalloc_stats\")));\n#endif\nsize_t malloc_usable_size(const void*) __attribute__((weak, alias(\"dlmalloc_usable_size\")));\nsize_t malloc_footprint(void) __attribute__((weak, alias(\"dlmalloc_footprint\")));\nsize_t malloc_max_footprint(void) __attribute__((weak, alias(\"dlmalloc_max_footprint\")));\nsize_t malloc_footprint_limit(void) __attribute__((weak, alias(\"dlmalloc_footprint_limit\")));\nsize_t malloc_set_footprint_limit(size_t bytes) __attribute__((weak, alias(\"dlmalloc_set_footprint_limit\")));\n#if MALLOC_INSPECT_ALL\nvoid malloc_inspect_all(void(*handler)(void*, void *, size_t, void*), void* arg) __attribute__((weak, alias(\"dlmalloc_inspect_all\")));\n#endif\nvoid** independent_calloc(size_t, size_t, void**) __attribute__((weak, alias(\"dlindependent_calloc\")));\nvoid** independent_comalloc(size_t, size_t*, void**) __attribute__((weak, alias(\"dlindependent_comalloc\")));\nsize_t bulk_free(void**, size_t n_elements) __attribute__((weak, alias(\"dlbulk_free\")));\n#endif /*__EMSCRIPTEN__*/\n#endif /* USE_DL_PREFIX */\n    \n    /*\n     malloc(size_t n)\n     Returns a pointer to a newly allocated chunk of at least n bytes, or\n     null if no space is available, in which case errno is set to ENOMEM\n     on ANSI C systems.\n     \n     If n is zero, malloc returns a minimum-sized chunk. (The minimum\n     size is 16 bytes on most 32bit systems, and 32 bytes on 64bit\n     systems.)  Note that size_t is an unsigned type, so calls with\n     arguments that would be negative if signed are interpreted as\n     requests for huge amounts of space, which will often fail. The\n     maximum supported value of n differs across systems, but is in all\n     cases less than the maximum representable value of a size_t.\n     */\n    DLMALLOC_EXPORT void* dlmalloc(size_t);\n    \n    /*\n     free(void* p)\n     Releases the chunk of memory pointed to by p, that had been previously\n     allocated using malloc or a related routine such as realloc.\n     It has no effect if p is null. If p was not malloced or already\n     freed, free(p) will by default cause the current program to abort.\n     */\n    DLMALLOC_EXPORT void  dlfree(void*);\n    \n    /*\n     calloc(size_t n_elements, size_t element_size);\n     Returns a pointer to n_elements * element_size bytes, with all locations\n     set to zero.\n     */\n    DLMALLOC_EXPORT void* dlcalloc(size_t, size_t);\n    \n    /*\n     realloc(void* p, size_t n)\n     Returns a pointer to a chunk of size n that contains the same data\n     as does chunk p up to the minimum of (n, p's size) bytes, or null\n     if no space is available.\n     \n     The returned pointer may or may not be the same as p. The algorithm\n     prefers extending p in most cases when possible, otherwise it\n     employs the equivalent of a malloc-copy-free sequence.\n     \n     If p is null, realloc is equivalent to malloc.\n     \n     If space is not available, realloc returns null, errno is set (if on\n     ANSI) and p is NOT freed.\n     \n     if n is for fewer bytes than already held by p, the newly unused\n     space is lopped off and freed if possible.  realloc with a size\n     argument of zero (re)allocates a minimum-sized chunk.\n     \n     The old unix realloc convention of allowing the last-free'd chunk\n     to be used as an argument to realloc is not supported.\n     */\n    DLMALLOC_EXPORT void* dlrealloc(void*, size_t);\n    \n    /*\n     realloc_in_place(void* p, size_t n)\n     Resizes the space allocated for p to size n, only if this can be\n     done without moving p (i.e., only if there is adjacent space\n     available if n is greater than p's current allocated size, or n is\n     less than or equal to p's size). This may be used instead of plain\n     realloc if an alternative allocation strategy is needed upon failure\n     to expand space; for example, reallocation of a buffer that must be\n     memory-aligned or cleared. You can use realloc_in_place to trigger\n     these alternatives only when needed.\n     \n     Returns p if successful; otherwise null.\n     */\n    DLMALLOC_EXPORT void* dlrealloc_in_place(void*, size_t);\n    \n    /*\n     memalign(size_t alignment, size_t n);\n     Returns a pointer to a newly allocated chunk of n bytes, aligned\n     in accord with the alignment argument.\n     \n     The alignment argument should be a power of two. If the argument is\n     not a power of two, the nearest greater power is used.\n     8-byte alignment is guaranteed by normal malloc calls, so don't\n     bother calling memalign with an argument of 8 or less.\n     \n     Overreliance on memalign is a sure way to fragment space.\n     */\n    DLMALLOC_EXPORT void* dlmemalign(size_t, size_t);\n    \n    /*\n     int posix_memalign(void** pp, size_t alignment, size_t n);\n     Allocates a chunk of n bytes, aligned in accord with the alignment\n     argument. Differs from memalign only in that it (1) assigns the\n     allocated memory to *pp rather than returning it, (2) fails and\n     returns EINVAL if the alignment is not a power of two (3) fails and\n     returns ENOMEM if memory cannot be allocated.\n     */\n    DLMALLOC_EXPORT int dlposix_memalign(void**, size_t, size_t);\n    \n    /*\n     valloc(size_t n);\n     Equivalent to memalign(pagesize, n), where pagesize is the page\n     size of the system. If the pagesize is unknown, 4096 is used.\n     */\n    DLMALLOC_EXPORT void* dlvalloc(size_t);\n    \n    /*\n     mallopt(int parameter_number, int parameter_value)\n     Sets tunable parameters The format is to provide a\n     (parameter-number, parameter-value) pair.  mallopt then sets the\n     corresponding parameter to the argument value if it can (i.e., so\n     long as the value is meaningful), and returns 1 if successful else\n     0.  To workaround the fact that mallopt is specified to use int,\n     not size_t parameters, the value -1 is specially treated as the\n     maximum unsigned size_t value.\n     \n     SVID/XPG/ANSI defines four standard param numbers for mallopt,\n     normally defined in malloc.h.  None of these are use in this malloc,\n     so setting them has no effect. But this malloc also supports other\n     options in mallopt. See below for details.  Briefly, supported\n     parameters are as follows (listed defaults are for \"typical\"\n     configurations).\n     \n     Symbol            param #  default    allowed param values\n     M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1 disables)\n     M_GRANULARITY        -2     page size   any power of 2 >= page size\n     M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)\n     */\n    DLMALLOC_EXPORT int dlmallopt(int, int);\n    \n    /*\n     malloc_footprint();\n     Returns the number of bytes obtained from the system.  The total\n     number of bytes allocated by malloc, realloc etc., is less than this\n     value. Unlike mallinfo, this function returns only a precomputed\n     result, so can be called frequently to monitor memory consumption.\n     Even if locks are otherwise defined, this function does not use them,\n     so results might not be up to date.\n     */\n    DLMALLOC_EXPORT size_t dlmalloc_footprint(void);\n    \n    /*\n     malloc_max_footprint();\n     Returns the maximum number of bytes obtained from the system. This\n     value will be greater than current footprint if deallocated space\n     has been reclaimed by the system. The peak number of bytes allocated\n     by malloc, realloc etc., is less than this value. Unlike mallinfo,\n     this function returns only a precomputed result, so can be called\n     frequently to monitor memory consumption.  Even if locks are\n     otherwise defined, this function does not use them, so results might\n     not be up to date.\n     */\n    DLMALLOC_EXPORT size_t dlmalloc_max_footprint(void);\n    \n    /*\n     malloc_footprint_limit();\n     Returns the number of bytes that the heap is allowed to obtain from\n     the system, returning the last value returned by\n     malloc_set_footprint_limit, or the maximum size_t value if\n     never set. The returned value reflects a permission. There is no\n     guarantee that this number of bytes can actually be obtained from\n     the system.\n     */\n    DLMALLOC_EXPORT size_t dlmalloc_footprint_limit();\n    \n    /*\n     malloc_set_footprint_limit();\n     Sets the maximum number of bytes to obtain from the system, causing\n     failure returns from malloc and related functions upon attempts to\n     exceed this value. The argument value may be subject to page\n     rounding to an enforceable limit; this actual value is returned.\n     Using an argument of the maximum possible size_t effectively\n     disables checks. If the argument is less than or equal to the\n     current malloc_footprint, then all future allocations that require\n     additional system memory will fail. However, invocation cannot\n     retroactively deallocate existing used memory.\n     */\n    DLMALLOC_EXPORT size_t dlmalloc_set_footprint_limit(size_t bytes);\n    \n#if MALLOC_INSPECT_ALL\n    /*\n     malloc_inspect_all(void(*handler)(void *start,\n     void *end,\n     size_t used_bytes,\n     void* callback_arg),\n     void* arg);\n     Traverses the heap and calls the given handler for each managed\n     region, skipping all bytes that are (or may be) used for bookkeeping\n     purposes.  Traversal does not include include chunks that have been\n     directly memory mapped. Each reported region begins at the start\n     address, and continues up to but not including the end address.  The\n     first used_bytes of the region contain allocated data. If\n     used_bytes is zero, the region is unallocated. The handler is\n     invoked with the given callback argument. If locks are defined, they\n     are held during the entire traversal. It is a bad idea to invoke\n     other malloc functions from within the handler.\n     \n     For example, to count the number of in-use chunks with size greater\n     than 1000, you could write:\n     static int count = 0;\n     void count_chunks(void* start, void* end, size_t used, void* arg) {\n     if (used >= 1000) ++count;\n     }\n     then:\n     malloc_inspect_all(count_chunks, NULL);\n     \n     malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.\n     */\n    DLMALLOC_EXPORT void dlmalloc_inspect_all(void(*handler)(void*, void *, size_t, void*),\n                                              void* arg);\n    \n#endif /* MALLOC_INSPECT_ALL */\n    \n#if !NO_MALLINFO\n    /*\n     mallinfo()\n     Returns (by copy) a struct containing various summary statistics:\n     \n     arena:     current total non-mmapped bytes allocated from system\n     ordblks:   the number of free chunks\n     smblks:    always zero.\n     hblks:     current number of mmapped regions\n     hblkhd:    total bytes held in mmapped regions\n     usmblks:   the maximum total allocated space. This will be greater\n     than current total if trimming has occurred.\n     fsmblks:   always zero\n     uordblks:  current total allocated space (normal or mmapped)\n     fordblks:  total free space\n     keepcost:  the maximum number of bytes that could ideally be released\n     back to system via malloc_trim. (\"ideally\" means that\n     it ignores page restrictions etc.)\n     \n     Because these fields are ints, but internal bookkeeping may\n     be kept as longs, the reported values may wrap around zero and\n     thus be inaccurate.\n     */\n    DLMALLOC_EXPORT struct mallinfo dlmallinfo(void);\n#endif /* NO_MALLINFO */\n    \n    /*\n     independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);\n     \n     independent_calloc is similar to calloc, but instead of returning a\n     single cleared space, it returns an array of pointers to n_elements\n     independent elements that can hold contents of size elem_size, each\n     of which starts out cleared, and can be independently freed,\n     realloc'ed etc. The elements are guaranteed to be adjacently\n     allocated (this is not guaranteed to occur with multiple callocs or\n     mallocs), which may also improve cache locality in some\n     applications.\n     \n     The \"chunks\" argument is optional (i.e., may be null, which is\n     probably the most typical usage). If it is null, the returned array\n     is itself dynamically allocated and should also be freed when it is\n     no longer needed. Otherwise, the chunks array must be of at least\n     n_elements in length. It is filled in with the pointers to the\n     chunks.\n     \n     In either case, independent_calloc returns this pointer array, or\n     null if the allocation failed.  If n_elements is zero and \"chunks\"\n     is null, it returns a chunk representing an array with zero elements\n     (which should be freed if not wanted).\n     \n     Each element must be freed when it is no longer needed. This can be\n     done all at once using bulk_free.\n     \n     independent_calloc simplifies and speeds up implementations of many\n     kinds of pools.  It may also be useful when constructing large data\n     structures that initially have a fixed number of fixed-sized nodes,\n     but the number is not known at compile time, and some of the nodes\n     may later need to be freed. For example:\n     \n     struct Node { int item; struct Node* next; };\n     \n     struct Node* build_list() {\n     struct Node** pool;\n     int n = read_number_of_nodes_needed();\n     if (n <= 0) return 0;\n     pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);\n     if (pool == 0) die();\n     // organize into a linked list...\n     struct Node* first = pool[0];\n     for (i = 0; i < n-1; ++i)\n     pool[i]->next = pool[i+1];\n     free(pool);     // Can now free the array (or not, if it is needed later)\n     return first;\n     }\n     */\n    DLMALLOC_EXPORT void** dlindependent_calloc(size_t, size_t, void**);\n    \n    /*\n     independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);\n     \n     independent_comalloc allocates, all at once, a set of n_elements\n     chunks with sizes indicated in the \"sizes\" array.    It returns\n     an array of pointers to these elements, each of which can be\n     independently freed, realloc'ed etc. The elements are guaranteed to\n     be adjacently allocated (this is not guaranteed to occur with\n     multiple callocs or mallocs), which may also improve cache locality\n     in some applications.\n     \n     The \"chunks\" argument is optional (i.e., may be null). If it is null\n     the returned array is itself dynamically allocated and should also\n     be freed when it is no longer needed. Otherwise, the chunks array\n     must be of at least n_elements in length. It is filled in with the\n     pointers to the chunks.\n     \n     In either case, independent_comalloc returns this pointer array, or\n     null if the allocation failed.  If n_elements is zero and chunks is\n     null, it returns a chunk representing an array with zero elements\n     (which should be freed if not wanted).\n     \n     Each element must be freed when it is no longer needed. This can be\n     done all at once using bulk_free.\n     \n     independent_comallac differs from independent_calloc in that each\n     element may have a different size, and also that it does not\n     automatically clear elements.\n     \n     independent_comalloc can be used to speed up allocation in cases\n     where several structs or objects must always be allocated at the\n     same time.  For example:\n     \n     struct Head { ... }\n     struct Foot { ... }\n     \n     void send_message(char* msg) {\n     int msglen = strlen(msg);\n     size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };\n     void* chunks[3];\n     if (independent_comalloc(3, sizes, chunks) == 0)\n     die();\n     struct Head* head = (struct Head*)(chunks[0]);\n     char*        body = (char*)(chunks[1]);\n     struct Foot* foot = (struct Foot*)(chunks[2]);\n     // ...\n     }\n     \n     In general though, independent_comalloc is worth using only for\n     larger values of n_elements. For small values, you probably won't\n     detect enough difference from series of malloc calls to bother.\n     \n     Overuse of independent_comalloc can increase overall memory usage,\n     since it cannot reuse existing noncontiguous small chunks that\n     might be available for some of the elements.\n     */\n    DLMALLOC_EXPORT void** dlindependent_comalloc(size_t, size_t*, void**);\n    \n    /*\n     bulk_free(void* array[], size_t n_elements)\n     Frees and clears (sets to null) each non-null pointer in the given\n     array.  This is likely to be faster than freeing them one-by-one.\n     If footers are used, pointers that have been allocated in different\n     mspaces are not freed or cleared, and the count of all such pointers\n     is returned.  For large arrays of pointers with poor locality, it\n     may be worthwhile to sort this array before calling bulk_free.\n     */\n    DLMALLOC_EXPORT size_t  dlbulk_free(void**, size_t n_elements);\n    \n    /*\n     pvalloc(size_t n);\n     Equivalent to valloc(minimum-page-that-holds(n)), that is,\n     round up n to nearest pagesize.\n     */\n    DLMALLOC_EXPORT void*  dlpvalloc(size_t);\n    \n    /*\n     malloc_trim(size_t pad);\n     \n     If possible, gives memory back to the system (via negative arguments\n     to sbrk) if there is unused memory at the `high' end of the malloc\n     pool or in unused MMAP segments. You can call this after freeing\n     large blocks of memory to potentially reduce the system-level memory\n     requirements of a program. However, it cannot guarantee to reduce\n     memory. Under some allocation patterns, some large free blocks of\n     memory will be locked between two used chunks, so they cannot be\n     given back to the system.\n     \n     The `pad' argument to malloc_trim represents the amount of free\n     trailing space to leave untrimmed. If this argument is zero, only\n     the minimum amount of memory to maintain internal data structures\n     will be left. Non-zero arguments can be supplied to maintain enough\n     trailing space to service future expected allocations without having\n     to re-obtain memory from the system.\n     \n     Malloc_trim returns 1 if it actually released any memory, else 0.\n     */\n    DLMALLOC_EXPORT int  dlmalloc_trim(size_t);\n    \n    /*\n     malloc_stats();\n     Prints on stderr the amount of space obtained from the system (both\n     via sbrk and mmap), the maximum amount (which may be more than\n     current if malloc_trim and/or munmap got called), and the current\n     number of bytes allocated via malloc (or realloc, etc) but not yet\n     freed. Note that this is the number of bytes allocated, not the\n     number requested. It will be larger than the number requested\n     because of alignment and bookkeeping overhead. Because it includes\n     alignment wastage as being in use, this figure may be greater than\n     zero even when no user-level chunks are allocated.\n     \n     The reported current and maximum system memory can be inaccurate if\n     a program makes other calls to system memory allocation functions\n     (normally sbrk) outside of malloc.\n     \n     malloc_stats prints only the most commonly interesting statistics.\n     More information can be obtained by calling mallinfo.\n     */\n    DLMALLOC_EXPORT void  dlmalloc_stats(void);\n    \n    /*\n     malloc_usable_size(void* p);\n     \n     Returns the number of bytes you can actually use in\n     an allocated chunk, which may be more than you requested (although\n     often not) due to alignment and minimum size constraints.\n     You can use this many bytes without worrying about\n     overwriting other allocated objects. This is not a particularly great\n     programming practice. malloc_usable_size can be more useful in\n     debugging and assertions, for example:\n     \n     p = malloc(n);\n     assert(malloc_usable_size(p) >= 256);\n     */\n    /* XXX EMSCRIPTEN: mark for export (and therefore weak) */\n    DLMALLOC_EXPORT size_t dlmalloc_usable_size(void*);\n    \n#endif /* ONLY_MSPACES */\n    \n#if MSPACES\n    \n    /*\n     mspace is an opaque type representing an independent\n     region of space that supports mspace_malloc, etc.\n     */\n    typedef void* mspace;\n    \n    /*\n     create_mspace creates and returns a new independent space with the\n     given initial capacity, or, if 0, the default granularity size.  It\n     returns null if there is no system memory available to create the\n     space.  If argument locked is non-zero, the space uses a separate\n     lock to control access. The capacity of the space will grow\n     dynamically as needed to service mspace_malloc requests.  You can\n     control the sizes of incremental increases of this space by\n     compiling with a different DEFAULT_GRANULARITY or dynamically\n     setting with mallopt(M_GRANULARITY, value).\n     */\n    DLMALLOC_EXPORT mspace create_mspace(size_t capacity, int locked);\n    \n    /*\n     destroy_mspace destroys the given space, and attempts to return all\n     of its memory back to the system, returning the total number of\n     bytes freed. After destruction, the results of access to all memory\n     used by the space become undefined.\n     */\n    DLMALLOC_EXPORT size_t destroy_mspace(mspace msp);\n    \n    /*\n     create_mspace_with_base uses the memory supplied as the initial base\n     of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this\n     space is used for bookkeeping, so the capacity must be at least this\n     large. (Otherwise 0 is returned.) When this initial space is\n     exhausted, additional memory will be obtained from the system.\n     Destroying this space will deallocate all additionally allocated\n     space (if possible) but not the initial base.\n     */\n    DLMALLOC_EXPORT mspace create_mspace_with_base(void* base, size_t capacity, int locked);\n    \n    /*\n     mspace_track_large_chunks controls whether requests for large chunks\n     are allocated in their own untracked mmapped regions, separate from\n     others in this mspace. By default large chunks are not tracked,\n     which reduces fragmentation. However, such chunks are not\n     necessarily released to the system upon destroy_mspace.  Enabling\n     tracking by setting to true may increase fragmentation, but avoids\n     leakage when relying on destroy_mspace to release all memory\n     allocated using this space.  The function returns the previous\n     setting.\n     */\n    DLMALLOC_EXPORT int mspace_track_large_chunks(mspace msp, int enable);\n    \n    \n    /*\n     mspace_malloc behaves as malloc, but operates within\n     the given space.\n     */\n    DLMALLOC_EXPORT void* mspace_malloc(mspace msp, size_t bytes);\n    \n    /*\n     mspace_free behaves as free, but operates within\n     the given space.\n     \n     If compiled with FOOTERS==1, mspace_free is not actually needed.\n     free may be called instead of mspace_free because freed chunks from\n     any space are handled by their originating spaces.\n     */\n    DLMALLOC_EXPORT void mspace_free(mspace msp, void* mem);\n    \n    /*\n     mspace_realloc behaves as realloc, but operates within\n     the given space.\n     \n     If compiled with FOOTERS==1, mspace_realloc is not actually\n     needed.  realloc may be called instead of mspace_realloc because\n     realloced chunks from any space are handled by their originating\n     spaces.\n     */\n    DLMALLOC_EXPORT void* mspace_realloc(mspace msp, void* mem, size_t newsize);\n    \n    /*\n     mspace_calloc behaves as calloc, but operates within\n     the given space.\n     */\n    DLMALLOC_EXPORT void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);\n    \n    /*\n     mspace_memalign behaves as memalign, but operates within\n     the given space.\n     */\n    DLMALLOC_EXPORT void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);\n    \n    /*\n     mspace_independent_calloc behaves as independent_calloc, but\n     operates within the given space.\n     */\n    DLMALLOC_EXPORT void** mspace_independent_calloc(mspace msp, size_t n_elements,\n                                                     size_t elem_size, void* chunks[]);\n    \n    /*\n     mspace_independent_comalloc behaves as independent_comalloc, but\n     operates within the given space.\n     */\n    DLMALLOC_EXPORT void** mspace_independent_comalloc(mspace msp, size_t n_elements,\n                                                       size_t sizes[], void* chunks[]);\n    \n    /*\n     mspace_footprint() returns the number of bytes obtained from the\n     system for this space.\n     */\n    DLMALLOC_EXPORT size_t mspace_footprint(mspace msp);\n    \n    /*\n     mspace_max_footprint() returns the peak number of bytes obtained from the\n     system for this space.\n     */\n    DLMALLOC_EXPORT size_t mspace_max_footprint(mspace msp);\n    \n    \n#if !NO_MALLINFO\n    /*\n     mspace_mallinfo behaves as mallinfo, but reports properties of\n     the given space.\n     */\n    DLMALLOC_EXPORT struct mallinfo mspace_mallinfo(mspace msp);\n#endif /* NO_MALLINFO */\n    \n    /*\n     malloc_usable_size(void* p) behaves the same as malloc_usable_size;\n     */\n    DLMALLOC_EXPORT size_t mspace_usable_size(const void* mem);\n    \n    /*\n     mspace_malloc_stats behaves as malloc_stats, but reports\n     properties of the given space.\n     */\n    DLMALLOC_EXPORT void mspace_malloc_stats(mspace msp);\n    \n    /*\n     mspace_trim behaves as malloc_trim, but\n     operates within the given space.\n     */\n    DLMALLOC_EXPORT int mspace_trim(mspace msp, size_t pad);\n    \n    /*\n     An alias for mallopt.\n     */\n    DLMALLOC_EXPORT int mspace_mallopt(int, int);\n    \n#endif /* MSPACES */\n    \n#ifdef __cplusplus\n}  /* end of extern \"C\" */\n#endif /* __cplusplus */\n\n/*\n ========================================================================\n To make a fully customizable malloc.h header file, cut everything\n above this line, put into file malloc.h, edit to suit, and #include it\n on the next line, as well as in programs that use this malloc.\n ========================================================================\n */\n\n/* #include \"malloc.h\" */\n\n/*------------------------------ internal #includes ---------------------- */\n\n#ifdef _MSC_VER\n#pragma warning( disable : 4146 ) /* no \"unsigned\" warnings */\n#endif /* _MSC_VER */\n#if !NO_MALLOC_STATS\n#include <stdio.h>       /* for printing in malloc_stats */\n#endif /* NO_MALLOC_STATS */\n#ifndef LACKS_ERRNO_H\n#include <errno.h>       /* for MALLOC_FAILURE_ACTION */\n#endif /* LACKS_ERRNO_H */\n#ifdef DEBUG\n#if ABORT_ON_ASSERT_FAILURE\n#undef assert\n#define assert(x) if(!(x)) ABORT\n#else /* ABORT_ON_ASSERT_FAILURE */\n#include <assert.h>\n#endif /* ABORT_ON_ASSERT_FAILURE */\n#else  /* DEBUG */\n#ifndef assert\n#define assert(x)\n#endif\n#define DEBUG 0\n#endif /* DEBUG */\n#if !defined(WIN32) && !defined(LACKS_TIME_H)\n#include <time.h>        /* for magic initialization */\n#endif /* WIN32 */\n#ifndef LACKS_STDLIB_H\n#include <stdlib.h>      /* for abort() */\n#endif /* LACKS_STDLIB_H */\n#ifndef LACKS_STRING_H\n#include <string.h>      /* for memset etc */\n#endif  /* LACKS_STRING_H */\n#if USE_BUILTIN_FFS\n#ifndef LACKS_STRINGS_H\n#include <strings.h>     /* for ffs */\n#endif /* LACKS_STRINGS_H */\n#endif /* USE_BUILTIN_FFS */\n#if HAVE_MMAP\n#ifndef LACKS_SYS_MMAN_H\n/* On some versions of linux, mremap decl in mman.h needs __USE_GNU set */\n#if (defined(linux) && !defined(__USE_GNU))\n#define __USE_GNU 1\n#include <sys/mman.h>    /* for mmap */\n#undef __USE_GNU\n#else\n#include <sys/mman.h>    /* for mmap */\n#endif /* linux */\n#endif /* LACKS_SYS_MMAN_H */\n#ifndef LACKS_FCNTL_H\n#include <fcntl.h>\n#endif /* LACKS_FCNTL_H */\n#endif /* HAVE_MMAP */\n#ifndef LACKS_UNISTD_H\n#include <unistd.h>     /* for sbrk, sysconf */\n#else /* LACKS_UNISTD_H */\n#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)\nextern void*     sbrk(ptrdiff_t);\n#endif /* FreeBSD etc */\n#endif /* LACKS_UNISTD_H */\n\n/* Declarations for locking */\n#if USE_LOCKS\n#ifndef WIN32\n#if defined (__SVR4) && defined (__sun)  /* solaris */\n#include <thread.h>\n#elif !defined(LACKS_SCHED_H)\n#include <sched.h>\n#endif /* solaris or LACKS_SCHED_H */\n#if (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0) || !USE_SPIN_LOCKS\n#include <pthread.h>\n#endif /* USE_RECURSIVE_LOCKS ... */\n#elif defined(_MSC_VER)\n#ifndef _M_AMD64\n/* These are already defined on AMD64 builds */\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n    LONG __cdecl _InterlockedCompareExchange(LONG volatile *Dest, LONG Exchange, LONG Comp);\n    LONG __cdecl _InterlockedExchange(LONG volatile *Target, LONG Value);\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n#endif /* _M_AMD64 */\n#pragma intrinsic (_InterlockedCompareExchange)\n#pragma intrinsic (_InterlockedExchange)\n#define interlockedcompareexchange _InterlockedCompareExchange\n#define interlockedexchange _InterlockedExchange\n#elif defined(WIN32) && defined(__GNUC__)\n#define interlockedcompareexchange(a, b, c) __sync_val_compare_and_swap(a, c, b)\n#define interlockedexchange __sync_lock_test_and_set\n#endif /* Win32 */\n#else /* USE_LOCKS */\n#endif /* USE_LOCKS */\n\n#ifndef LOCK_AT_FORK\n#define LOCK_AT_FORK 0\n#endif\n\n/* Declarations for bit scanning on win32 */\n#if defined(_MSC_VER) && _MSC_VER>=1300\n#ifndef BitScanForward /* Try to avoid pulling in WinNT.h */\n#ifdef __cplusplus\nextern \"C\" {\n#endif /* __cplusplus */\n    unsigned char _BitScanForward(unsigned long *index, unsigned long mask);\n    unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);\n#ifdef __cplusplus\n}\n#endif /* __cplusplus */\n\n#define BitScanForward _BitScanForward\n#define BitScanReverse _BitScanReverse\n#pragma intrinsic(_BitScanForward)\n#pragma intrinsic(_BitScanReverse)\n#endif /* BitScanForward */\n#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */\n\n#ifndef WIN32\n#ifndef malloc_getpagesize\n#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */\n#    ifndef _SC_PAGE_SIZE\n#      define _SC_PAGE_SIZE _SC_PAGESIZE\n#    endif\n#  endif\n#  ifdef _SC_PAGE_SIZE\n#    if defined(__EMSCRIPTEN__)\n#      define malloc_getpagesize (4096) /* avoid sysconf calls during startup */\n#    else\n#      define malloc_getpagesize sysconf(_SC_PAGE_SIZE)\n#    endif\n#  else\n#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)\nextern size_t getpagesize();\n#      define malloc_getpagesize getpagesize()\n#    else\n#      ifdef WIN32 /* use supplied emulation of getpagesize */\n#        define malloc_getpagesize getpagesize()\n#      else\n#        ifndef LACKS_SYS_PARAM_H\n#          include <sys/param.h>\n#        endif\n#        ifdef EXEC_PAGESIZE\n#          define malloc_getpagesize EXEC_PAGESIZE\n#        else\n#          ifdef NBPG\n#            ifndef CLSIZE\n#              define malloc_getpagesize NBPG\n#            else\n#              define malloc_getpagesize (NBPG * CLSIZE)\n#            endif\n#          else\n#            ifdef NBPC\n#              define malloc_getpagesize NBPC\n#            else\n#              ifdef PAGESIZE\n#                define malloc_getpagesize PAGESIZE\n#              else /* just guess */\n#                define malloc_getpagesize ((size_t)4096U)\n#              endif\n#            endif\n#          endif\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n#endif\n\n/* ------------------- size_t and alignment properties -------------------- */\n\n/* The byte and bit size of a size_t */\n#define SIZE_T_SIZE         (sizeof(size_t))\n#define SIZE_T_BITSIZE      (sizeof(size_t) << 3)\n\n/* Some constants coerced to size_t */\n/* Annoying but necessary to avoid errors on some platforms */\n#define SIZE_T_ZERO         ((size_t)0)\n#define SIZE_T_ONE          ((size_t)1)\n#define SIZE_T_TWO          ((size_t)2)\n#define SIZE_T_FOUR         ((size_t)4)\n#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)\n#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)\n#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)\n#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)\n\n/* The bit mask value corresponding to MALLOC_ALIGNMENT */\n#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)\n\n/* True if address a has acceptable alignment */\n#define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)\n\n/* the number of bytes to offset an address to align it */\n#define align_offset(A)\\\n((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\\\n((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))\n\n/* -------------------------- MMAP preliminaries ------------------------- */\n\n/*\n If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and\n checks to fail so compiler optimizer can delete code rather than\n using so many \"#if\"s.\n */\n\n\n/* MORECORE and MMAP must return MFAIL on failure */\n#define MFAIL                ((void*)(MAX_SIZE_T))\n#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */\n\n#if HAVE_MMAP\n\n#ifndef WIN32\n#define MUNMAP_DEFAULT(a, s)  munmap((a), (s))\n#define MMAP_PROT            (PROT_READ|PROT_WRITE)\n#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n#define MAP_ANONYMOUS        MAP_ANON\n#endif /* MAP_ANON */\n#ifdef MAP_ANONYMOUS\n#define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)\n#define MMAP_DEFAULT(s)       mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)\n#else /* MAP_ANONYMOUS */\n/*\n Nearly all versions of mmap support MAP_ANONYMOUS, so the following\n is unlikely to be needed, but is supplied just in case.\n */\n#define MMAP_FLAGS           (MAP_PRIVATE)\nstatic int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */\n#define MMAP_DEFAULT(s) ((dev_zero_fd < 0) ? \\\n(dev_zero_fd = open(\"/dev/zero\", O_RDWR), \\\nmmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \\\nmmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))\n#endif /* MAP_ANONYMOUS */\n\n#define DIRECT_MMAP_DEFAULT(s) MMAP_DEFAULT(s)\n\n#else /* WIN32 */\n\n/* Win32 MMAP via VirtualAlloc */\nstatic FORCEINLINE void* win32mmap(size_t size) {\n    void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n    return (ptr != 0)? ptr: MFAIL;\n}\n\n/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */\nstatic FORCEINLINE void* win32direct_mmap(size_t size) {\n    void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,\n                             PAGE_READWRITE);\n    return (ptr != 0)? ptr: MFAIL;\n}\n\n/* This function supports releasing coalesed segments */\nstatic FORCEINLINE int win32munmap(void* ptr, size_t size) {\n    MEMORY_BASIC_INFORMATION minfo;\n    char* cptr = (char*)ptr;\n    while (size) {\n        if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)\n            return -1;\n        if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||\n            minfo.State != MEM_COMMIT || minfo.RegionSize > size)\n            return -1;\n        if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)\n            return -1;\n        cptr += minfo.RegionSize;\n        size -= minfo.RegionSize;\n    }\n    return 0;\n}\n\n#define MMAP_DEFAULT(s)             win32mmap(s)\n#define MUNMAP_DEFAULT(a, s)        win32munmap((a), (s))\n#define DIRECT_MMAP_DEFAULT(s)      win32direct_mmap(s)\n#endif /* WIN32 */\n#endif /* HAVE_MMAP */\n\n#if HAVE_MREMAP\n#ifndef WIN32\n#define MREMAP_DEFAULT(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))\n#endif /* WIN32 */\n#endif /* HAVE_MREMAP */\n\n/**\n * Define CALL_MORECORE\n */\n#if HAVE_MORECORE\n#ifdef MORECORE\n#define CALL_MORECORE(S)    MORECORE(S)\n#else  /* MORECORE */\n#define CALL_MORECORE(S)    MORECORE_DEFAULT(S)\n#endif /* MORECORE */\n#else  /* HAVE_MORECORE */\n#define CALL_MORECORE(S)        MFAIL\n#endif /* HAVE_MORECORE */\n\n/**\n * Define CALL_MMAP/CALL_MUNMAP/CALL_DIRECT_MMAP\n */\n#if HAVE_MMAP\n#define USE_MMAP_BIT            (SIZE_T_ONE)\n\n#ifdef MMAP\n#define CALL_MMAP(s)        MMAP(s)\n#else /* MMAP */\n#define CALL_MMAP(s)        MMAP_DEFAULT(s)\n#endif /* MMAP */\n#ifdef MUNMAP\n#define CALL_MUNMAP(a, s)   MUNMAP((a), (s))\n#else /* MUNMAP */\n#define CALL_MUNMAP(a, s)   MUNMAP_DEFAULT((a), (s))\n#endif /* MUNMAP */\n#ifdef DIRECT_MMAP\n#define CALL_DIRECT_MMAP(s) DIRECT_MMAP(s)\n#else /* DIRECT_MMAP */\n#define CALL_DIRECT_MMAP(s) DIRECT_MMAP_DEFAULT(s)\n#endif /* DIRECT_MMAP */\n#else  /* HAVE_MMAP */\n#define USE_MMAP_BIT            (SIZE_T_ZERO)\n\n#define MMAP(s)                 MFAIL\n#define MUNMAP(a, s)            (-1)\n#define DIRECT_MMAP(s)          MFAIL\n#define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)\n#define CALL_MMAP(s)            MMAP(s)\n#define CALL_MUNMAP(a, s)       MUNMAP((a), (s))\n#endif /* HAVE_MMAP */\n\n/**\n * Define CALL_MREMAP\n */\n#if HAVE_MMAP && HAVE_MREMAP\n#ifdef MREMAP\n#define CALL_MREMAP(addr, osz, nsz, mv) MREMAP((addr), (osz), (nsz), (mv))\n#else /* MREMAP */\n#define CALL_MREMAP(addr, osz, nsz, mv) MREMAP_DEFAULT((addr), (osz), (nsz), (mv))\n#endif /* MREMAP */\n#else  /* HAVE_MMAP && HAVE_MREMAP */\n#define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL\n#endif /* HAVE_MMAP && HAVE_MREMAP */\n\n/* mstate bit set if continguous morecore disabled or failed */\n#define USE_NONCONTIGUOUS_BIT (4U)\n\n/* segment bit set in create_mspace_with_base */\n#define EXTERN_BIT            (8U)\n\n\n/* --------------------------- Lock preliminaries ------------------------ */\n\n/*\n When locks are defined, there is one global lock, plus\n one per-mspace lock.\n \n The global lock_ensures that mparams.magic and other unique\n mparams values are initialized only once. It also protects\n sequences of calls to MORECORE.  In many cases sys_alloc requires\n two calls, that should not be interleaved with calls by other\n threads.  This does not protect against direct calls to MORECORE\n by other threads not using this lock, so there is still code to\n cope the best we can on interference.\n \n Per-mspace locks surround calls to malloc, free, etc.\n By default, locks are simple non-reentrant mutexes.\n \n Because lock-protected regions generally have bounded times, it is\n OK to use the supplied simple spinlocks. Spinlocks are likely to\n improve performance for lightly contended applications, but worsen\n performance under heavy contention.\n \n If USE_LOCKS is > 1, the definitions of lock routines here are\n bypassed, in which case you will need to define the type MLOCK_T,\n and at least INITIAL_LOCK, DESTROY_LOCK, ACQUIRE_LOCK, RELEASE_LOCK\n and TRY_LOCK.  You must also declare a\n static MLOCK_T malloc_global_mutex = { initialization values };.\n \n */\n\n#if !USE_LOCKS\n#define USE_LOCK_BIT               (0U)\n#define INITIAL_LOCK(l)            (0)\n#define DESTROY_LOCK(l)            (0)\n#define ACQUIRE_MALLOC_GLOBAL_LOCK()\n#define RELEASE_MALLOC_GLOBAL_LOCK()\n\n#else\n#if USE_LOCKS > 1\n/* -----------------------  User-defined locks ------------------------ */\n/* Define your own lock implementation here */\n/* #define INITIAL_LOCK(lk)  ... */\n/* #define DESTROY_LOCK(lk)  ... */\n/* #define ACQUIRE_LOCK(lk)  ... */\n/* #define RELEASE_LOCK(lk)  ... */\n/* #define TRY_LOCK(lk) ... */\n/* static MLOCK_T malloc_global_mutex = ... */\n\n#elif USE_SPIN_LOCKS\n\n/* First, define CAS_LOCK and CLEAR_LOCK on ints */\n/* Note CAS_LOCK defined to return 0 on success */\n\n#if defined(__GNUC__)&& (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))\n#define CAS_LOCK(sl)     __sync_lock_test_and_set(sl, 1)\n#define CLEAR_LOCK(sl)   __sync_lock_release(sl)\n\n#elif (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))\n/* Custom spin locks for older gcc on x86 */\nstatic FORCEINLINE int x86_cas_lock(int *sl) {\n    int ret;\n    int val = 1;\n    int cmp = 0;\n    __asm__ __volatile__  (\"lock; cmpxchgl %1, %2\"\n                           : \"=a\" (ret)\n                           : \"r\" (val), \"m\" (*(sl)), \"0\"(cmp)\n                           : \"memory\", \"cc\");\n    return ret;\n}\n\nstatic FORCEINLINE void x86_clear_lock(int* sl) {\n    assert(*sl != 0);\n    int prev = 0;\n    int ret;\n    __asm__ __volatile__ (\"lock; xchgl %0, %1\"\n                          : \"=r\" (ret)\n                          : \"m\" (*(sl)), \"0\"(prev)\n                          : \"memory\");\n}\n\n#define CAS_LOCK(sl)     x86_cas_lock(sl)\n#define CLEAR_LOCK(sl)   x86_clear_lock(sl)\n\n#else /* Win32 MSC */\n#define CAS_LOCK(sl)     interlockedexchange(sl, (LONG)1)\n#define CLEAR_LOCK(sl)   interlockedexchange (sl, (LONG)0)\n\n#endif /* ... gcc spins locks ... */\n\n/* How to yield for a spin lock */\n#define SPINS_PER_YIELD       63\n#if defined(_MSC_VER)\n#define SLEEP_EX_DURATION     50 /* delay for yield/sleep */\n#define SPIN_LOCK_YIELD  SleepEx(SLEEP_EX_DURATION, FALSE)\n#elif defined (__SVR4) && defined (__sun) /* solaris */\n#define SPIN_LOCK_YIELD   thr_yield();\n#elif !defined(LACKS_SCHED_H)\n#define SPIN_LOCK_YIELD   sched_yield();\n#else\n#define SPIN_LOCK_YIELD\n#endif /* ... yield ... */\n\n#if !defined(USE_RECURSIVE_LOCKS) || USE_RECURSIVE_LOCKS == 0\n/* Plain spin locks use single word (embedded in malloc_states) */\nstatic int spin_acquire_lock(int *sl) {\n    int spins = 0;\n    while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {\n        if ((++spins & SPINS_PER_YIELD) == 0) {\n            SPIN_LOCK_YIELD;\n        }\n    }\n    return 0;\n}\n\n#define MLOCK_T               int\n#define TRY_LOCK(sl)          !CAS_LOCK(sl)\n#define RELEASE_LOCK(sl)      CLEAR_LOCK(sl)\n#define ACQUIRE_LOCK(sl)      (CAS_LOCK(sl)? spin_acquire_lock(sl) : 0)\n#define INITIAL_LOCK(sl)      (*sl = 0)\n#define DESTROY_LOCK(sl)      (0)\nstatic MLOCK_T malloc_global_mutex = 0;\n\n#else /* USE_RECURSIVE_LOCKS */\n/* types for lock owners */\n#ifdef WIN32\n#define THREAD_ID_T           DWORD\n#define CURRENT_THREAD        GetCurrentThreadId()\n#define EQ_OWNER(X,Y)         ((X) == (Y))\n#else\n/*\n Note: the following assume that pthread_t is a type that can be\n initialized to (casted) zero. If this is not the case, you will need to\n somehow redefine these or not use spin locks.\n */\n#define THREAD_ID_T           pthread_t\n#define CURRENT_THREAD        pthread_self()\n#define EQ_OWNER(X,Y)         pthread_equal(X, Y)\n#endif\n\nstruct malloc_recursive_lock {\n    int sl;\n    unsigned int c;\n    THREAD_ID_T threadid;\n};\n\n#define MLOCK_T  struct malloc_recursive_lock\nstatic MLOCK_T malloc_global_mutex = { 0, 0, (THREAD_ID_T)0};\n\nstatic FORCEINLINE void recursive_release_lock(MLOCK_T *lk) {\n    assert(lk->sl != 0);\n    if (--lk->c == 0) {\n        CLEAR_LOCK(&lk->sl);\n    }\n}\n\nstatic FORCEINLINE int recursive_acquire_lock(MLOCK_T *lk) {\n    THREAD_ID_T mythreadid = CURRENT_THREAD;\n    int spins = 0;\n    for (;;) {\n        if (*((volatile int *)(&lk->sl)) == 0) {\n            if (!CAS_LOCK(&lk->sl)) {\n                lk->threadid = mythreadid;\n                lk->c = 1;\n                return 0;\n            }\n        }\n        else if (EQ_OWNER(lk->threadid, mythreadid)) {\n            ++lk->c;\n            return 0;\n        }\n        if ((++spins & SPINS_PER_YIELD) == 0) {\n            SPIN_LOCK_YIELD;\n        }\n    }\n}\n\nstatic FORCEINLINE int recursive_try_lock(MLOCK_T *lk) {\n    THREAD_ID_T mythreadid = CURRENT_THREAD;\n    if (*((volatile int *)(&lk->sl)) == 0) {\n        if (!CAS_LOCK(&lk->sl)) {\n            lk->threadid = mythreadid;\n            lk->c = 1;\n            return 1;\n        }\n    }\n    else if (EQ_OWNER(lk->threadid, mythreadid)) {\n        ++lk->c;\n        return 1;\n    }\n    return 0;\n}\n\n#define RELEASE_LOCK(lk)      recursive_release_lock(lk)\n#define TRY_LOCK(lk)          recursive_try_lock(lk)\n#define ACQUIRE_LOCK(lk)      recursive_acquire_lock(lk)\n#define INITIAL_LOCK(lk)      ((lk)->threadid = (THREAD_ID_T)0, (lk)->sl = 0, (lk)->c = 0)\n#define DESTROY_LOCK(lk)      (0)\n#endif /* USE_RECURSIVE_LOCKS */\n\n#elif defined(WIN32) /* Win32 critical sections */\n#define MLOCK_T               CRITICAL_SECTION\n#define ACQUIRE_LOCK(lk)      (EnterCriticalSection(lk), 0)\n#define RELEASE_LOCK(lk)      LeaveCriticalSection(lk)\n#define TRY_LOCK(lk)          TryEnterCriticalSection(lk)\n#define INITIAL_LOCK(lk)      (!InitializeCriticalSectionAndSpinCount((lk), 0x80000000|4000))\n#define DESTROY_LOCK(lk)      (DeleteCriticalSection(lk), 0)\n#define NEED_GLOBAL_LOCK_INIT\n\nstatic MLOCK_T malloc_global_mutex;\nstatic volatile LONG malloc_global_mutex_status;\n\n/* Use spin loop to initialize global lock */\nstatic void init_malloc_global_mutex() {\n    for (;;) {\n        long stat = malloc_global_mutex_status;\n        if (stat > 0)\n            return;\n        /* transition to < 0 while initializing, then to > 0) */\n        if (stat == 0 &&\n            interlockedcompareexchange(&malloc_global_mutex_status, (LONG)-1, (LONG)0) == 0) {\n            InitializeCriticalSection(&malloc_global_mutex);\n            interlockedexchange(&malloc_global_mutex_status, (LONG)1);\n            return;\n        }\n        SleepEx(0, FALSE);\n    }\n}\n\n#else /* pthreads-based locks */\n\n#define MLOCK_T               pthread_mutex_t\n#define ACQUIRE_LOCK(lk)      pthread_mutex_lock(lk)\n#define RELEASE_LOCK(lk)      pthread_mutex_unlock(lk)\n#define TRY_LOCK(lk)          (!pthread_mutex_trylock(lk))\n#define INITIAL_LOCK(lk)      pthread_init_lock(lk)\n#define DESTROY_LOCK(lk)      pthread_mutex_destroy(lk)\n\n#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0 && defined(linux) && !defined(PTHREAD_MUTEX_RECURSIVE)\n/* Cope with old-style linux recursive lock initialization by adding */\n/* skipped internal declaration from pthread.h */\nextern int pthread_mutexattr_setkind_np __P ((pthread_mutexattr_t *__attr,\n                                              int __kind));\n#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP\n#define pthread_mutexattr_settype(x,y) pthread_mutexattr_setkind_np(x,y)\n#endif /* USE_RECURSIVE_LOCKS ... */\n\nstatic MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;\n\nstatic int pthread_init_lock (MLOCK_T *lk) {\n    pthread_mutexattr_t attr;\n    if (pthread_mutexattr_init(&attr)) return 1;\n#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0\n    if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;\n#endif\n    if (pthread_mutex_init(lk, &attr)) return 1;\n    if (pthread_mutexattr_destroy(&attr)) return 1;\n    return 0;\n}\n\n#endif /* ... lock types ... */\n\n/* Common code for all lock types */\n#define USE_LOCK_BIT               (2U)\n\n#ifndef ACQUIRE_MALLOC_GLOBAL_LOCK\n#define ACQUIRE_MALLOC_GLOBAL_LOCK()  ACQUIRE_LOCK(&malloc_global_mutex);\n#endif\n\n#ifndef RELEASE_MALLOC_GLOBAL_LOCK\n#define RELEASE_MALLOC_GLOBAL_LOCK()  RELEASE_LOCK(&malloc_global_mutex);\n#endif\n\n#endif /* USE_LOCKS */\n\n/* -----------------------  Chunk representations ------------------------ */\n\n/*\n (The following includes lightly edited explanations by Colin Plumb.)\n \n The malloc_chunk declaration below is misleading (but accurate and\n necessary).  It declares a \"view\" into memory allowing access to\n necessary fields at known offsets from a given base.\n \n Chunks of memory are maintained using a `boundary tag' method as\n originally described by Knuth.  (See the paper by Paul Wilson\n ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such\n techniques.)  Sizes of free chunks are stored both in the front of\n each chunk and at the end.  This makes consolidating fragmented\n chunks into bigger chunks fast.  The head fields also hold bits\n representing whether chunks are free or in use.\n \n Here are some pictures to make it clearer.  They are \"exploded\" to\n show that the state of a chunk can be thought of as extending from\n the high 31 bits of the head field of its header through the\n prev_foot and PINUSE_BIT bit of the following chunk header.\n \n A chunk that's in use looks like:\n \n chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n | Size of previous chunk (if P = 0)                             |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|\n | Size of this chunk                                         1| +-+\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                                                               |\n +-                                                             -+\n |                                                               |\n +-                                                             -+\n |                                                               :\n +-      size - sizeof(size_t) available payload bytes          -+\n :                                                               |\n chunk-> +-                                                             -+\n |                                                               |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|\n | Size of next chunk (may or may not be in use)               | +-+\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \n And if it's free, it looks like this:\n \n chunk-> +-                                                             -+\n | User payload (must be in use, or we would have merged!)       |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|\n | Size of this chunk                                         0| +-+\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n | Next pointer                                                  |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n | Prev pointer                                                  |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                                                               :\n +-      size - sizeof(struct chunk) unused bytes               -+\n :                                                               |\n chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n | Size of this chunk                                            |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|\n | Size of next chunk (must be in use, or we would have merged)| +-+\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                                                               :\n +- User payload                                                -+\n :                                                               |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |0|\n +-+\n Note that since we always merge adjacent free chunks, the chunks\n adjacent to a free chunk must be in use.\n \n Given a pointer to a chunk (which can be derived trivially from the\n payload pointer) we can, in O(1) time, find out whether the adjacent\n chunks are free, and if so, unlink them from the lists that they\n are on and merge them with the current chunk.\n \n Chunks always begin on even word boundaries, so the mem portion\n (which is returned to the user) is also on an even word boundary, and\n thus at least double-word aligned.\n \n The P (PINUSE_BIT) bit, stored in the unused low-order bit of the\n chunk size (which is always a multiple of two words), is an in-use\n bit for the *previous* chunk.  If that bit is *clear*, then the\n word before the current chunk size contains the previous chunk\n size, and can be used to find the front of the previous chunk.\n The very first chunk allocated always has this bit set, preventing\n access to non-existent (or non-owned) memory. If pinuse is set for\n any given chunk, then you CANNOT determine the size of the\n previous chunk, and might even get a memory addressing fault when\n trying to do so.\n \n The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of\n the chunk size redundantly records whether the current chunk is\n inuse (unless the chunk is mmapped). This redundancy enables usage\n checks within free and realloc, and reduces indirection when freeing\n and consolidating chunks.\n \n Each freshly allocated chunk must have both cinuse and pinuse set.\n That is, each allocated chunk borders either a previously allocated\n and still in-use chunk, or the base of its memory arena. This is\n ensured by making all allocations from the `lowest' part of any\n found chunk.  Further, no free chunk physically borders another one,\n so each free chunk is known to be preceded and followed by either\n inuse chunks or the ends of memory.\n \n Note that the `foot' of the current chunk is actually represented\n as the prev_foot of the NEXT chunk. This makes it easier to\n deal with alignments etc but can be very confusing when trying\n to extend or adapt this code.\n \n The exceptions to all this are\n \n 1. The special chunk `top' is the top-most available chunk (i.e.,\n the one bordering the end of available memory). It is treated\n specially.  Top is never included in any bin, is used only if\n no other chunk is available, and is released back to the\n system if it is very large (see M_TRIM_THRESHOLD).  In effect,\n the top chunk is treated as larger (and thus less well\n fitting) than any other available chunk.  The top chunk\n doesn't update its trailing size field since there is no next\n contiguous chunk that would have to index off it. However,\n space is still allocated for it (TOP_FOOT_SIZE) to enable\n separation or merging when space is extended.\n \n 3. Chunks allocated via mmap, have both cinuse and pinuse bits\n cleared in their head fields.  Because they are allocated\n one-by-one, each must carry its own prev_foot field, which is\n also used to hold the offset this chunk has within its mmapped\n region, which is needed to preserve alignment. Each mmapped\n chunk is trailed by the first two fields of a fake next-chunk\n for sake of usage checks.\n \n */\n\nstruct malloc_chunk {\n    size_t               prev_foot;  /* Size of previous chunk (if free).  */\n    size_t               head;       /* Size and inuse bits. */\n    struct malloc_chunk* fd;         /* double links -- used only if free. */\n    struct malloc_chunk* bk;\n};\n\ntypedef struct malloc_chunk  mchunk;\ntypedef struct malloc_chunk* mchunkptr;\ntypedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */\ntypedef unsigned int bindex_t;         /* Described below */\ntypedef unsigned int binmap_t;         /* Described below */\ntypedef unsigned int flag_t;           /* The type of various bit flag sets */\n\n/* ------------------- Chunks sizes and alignments ----------------------- */\n\n#define MCHUNK_SIZE         (sizeof(mchunk))\n\n#if FOOTERS\n#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)\n#else /* FOOTERS */\n#define CHUNK_OVERHEAD      (SIZE_T_SIZE)\n#endif /* FOOTERS */\n\n/* MMapped chunks need a second word of overhead ... */\n#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)\n/* ... and additional padding for fake next-chunk at foot */\n#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)\n\n/* The smallest size we can malloc is an aligned minimal chunk */\n#define MIN_CHUNK_SIZE \\\n((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)\n\n/* conversion from malloc headers to user pointers, and back */\n#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))\n#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))\n/* chunk associated with aligned address A */\n#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))\n\n/* Bounds on request (not chunk) sizes. */\n#define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)\n#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)\n\n/* pad request bytes into a usable size */\n#define pad_request(req) \\\n(((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)\n\n/* pad request, checking for minimum (but not maximum) */\n#define request2size(req) \\\n(((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))\n\n\n/* ------------------ Operations on head and foot fields ----------------- */\n\n/*\n The head field of a chunk is or'ed with PINUSE_BIT when previous\n adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in\n use, unless mmapped, in which case both bits are cleared.\n \n FLAG4_BIT is not used by this malloc, but might be useful in extensions.\n */\n\n#define PINUSE_BIT          (SIZE_T_ONE)\n#define CINUSE_BIT          (SIZE_T_TWO)\n#define FLAG4_BIT           (SIZE_T_FOUR)\n#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)\n#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)\n\n/* Head value for fenceposts */\n#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)\n\n/* extraction of fields from head words */\n#define cinuse(p)           ((p)->head & CINUSE_BIT)\n#define pinuse(p)           ((p)->head & PINUSE_BIT)\n#define flag4inuse(p)       ((p)->head & FLAG4_BIT)\n#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)\n#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)\n\n#define chunksize(p)        ((p)->head & ~(FLAG_BITS))\n\n#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)\n#define set_flag4(p)        ((p)->head |= FLAG4_BIT)\n#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)\n\n/* Treat space at ptr +/- offset as a chunk */\n#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))\n#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))\n\n/* Ptr to next or previous physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))\n#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))\n\n/* extract next chunk's pinuse bit */\n#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)\n\n/* Get/set size at footer */\n#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)\n#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))\n\n/* Set size, pinuse bit, and foot */\n#define set_size_and_pinuse_of_free_chunk(p, s)\\\n((p)->head = (s|PINUSE_BIT), set_foot(p, s))\n\n/* Set size, pinuse bit, foot, and clear next pinuse */\n#define set_free_with_pinuse(p, s, n)\\\n(clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))\n\n/* Get the internal overhead associated with chunk p */\n#define overhead_for(p)\\\n(is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)\n\n/* Return true if malloced space is not necessarily cleared */\n#if MMAP_CLEARS\n#define calloc_must_clear(p) (!is_mmapped(p))\n#else /* MMAP_CLEARS */\n#define calloc_must_clear(p) (1)\n#endif /* MMAP_CLEARS */\n\n/* ---------------------- Overlaid data structures ----------------------- */\n\n/*\n When chunks are not in use, they are treated as nodes of either\n lists or trees.\n \n \"Small\"  chunks are stored in circular doubly-linked lists, and look\n like this:\n \n chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Size of previous chunk                            |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n `head:' |             Size of chunk, in bytes                         |P|\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Forward pointer to next chunk in list             |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Back pointer to previous chunk in list            |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Unused space (may be 0 bytes long)                .\n .                                                               .\n .                                                               |\n nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n `foot:' |             Size of chunk, in bytes                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \n Larger chunks are kept in a form of bitwise digital trees (aka\n tries) keyed on chunksizes.  Because malloc_tree_chunks are only for\n free chunks greater than 256 bytes, their size doesn't impose any\n constraints on user chunk sizes.  Each node looks like:\n \n chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Size of previous chunk                            |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n `head:' |             Size of chunk, in bytes                         |P|\n mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Forward pointer to next chunk of same size        |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Back pointer to previous chunk of same size       |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Pointer to left child (child[0])                  |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Pointer to right child (child[1])                 |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Pointer to parent                                 |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             bin index of this chunk                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |             Unused space                                      .\n .                                                               |\n nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n `foot:' |             Size of chunk, in bytes                           |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n \n Each tree holding treenodes is a tree of unique chunk sizes.  Chunks\n of the same size are arranged in a circularly-linked list, with only\n the oldest chunk (the next to be used, in our FIFO ordering)\n actually in the tree.  (Tree members are distinguished by a non-null\n parent pointer.)  If a chunk with the same size an an existing node\n is inserted, it is linked off the existing node using pointers that\n work in the same way as fd/bk pointers of small chunks.\n \n Each tree contains a power of 2 sized range of chunk sizes (the\n smallest is 0x100 <= x < 0x180), which is is divided in half at each\n tree level, with the chunks in the smaller half of the range (0x100\n <= x < 0x140 for the top nose) in the left subtree and the larger\n half (0x140 <= x < 0x180) in the right subtree.  This is, of course,\n done by inspecting individual bits.\n \n Using these rules, each node's left subtree contains all smaller\n sizes than its right subtree.  However, the node at the root of each\n subtree has no particular ordering relationship to either.  (The\n dividing line between the subtree sizes is based on trie relation.)\n If we remove the last chunk of a given size from the interior of the\n tree, we need to replace it with a leaf node.  The tree ordering\n rules permit a node to be replaced by any leaf below it.\n \n The smallest chunk in a tree (a common operation in a best-fit\n allocator) can be found by walking a path to the leftmost leaf in\n the tree.  Unlike a usual binary tree, where we follow left child\n pointers until we reach a null, here we follow the right child\n pointer any time the left one is null, until we reach a leaf with\n both child pointers null. The smallest chunk in the tree will be\n somewhere along that path.\n \n The worst case number of steps to add, find, or remove a node is\n bounded by the number of bits differentiating chunks within\n bins. Under current bin calculations, this ranges from 6 up to 21\n (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case\n is of course much better.\n */\n\nstruct malloc_tree_chunk {\n    /* The first four fields must be compatible with malloc_chunk */\n    size_t                    prev_foot;\n    size_t                    head;\n    struct malloc_tree_chunk* fd;\n    struct malloc_tree_chunk* bk;\n    \n    struct malloc_tree_chunk* child[2];\n    struct malloc_tree_chunk* parent;\n    bindex_t                  index;\n};\n\ntypedef struct malloc_tree_chunk  tchunk;\ntypedef struct malloc_tree_chunk* tchunkptr;\ntypedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */\n\n/* A little helper macro for trees */\n#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])\n\n/* ----------------------------- Segments -------------------------------- */\n\n/*\n Each malloc space may include non-contiguous segments, held in a\n list headed by an embedded malloc_segment record representing the\n top-most space. Segments also include flags holding properties of\n the space. Large chunks that are directly allocated by mmap are not\n included in this list. They are instead independently created and\n destroyed without otherwise keeping track of them.\n \n Segment management mainly comes into play for spaces allocated by\n MMAP.  Any call to MMAP might or might not return memory that is\n adjacent to an existing segment.  MORECORE normally contiguously\n extends the current space, so this space is almost always adjacent,\n which is simpler and faster to deal with. (This is why MORECORE is\n used preferentially to MMAP when both are available -- see\n sys_alloc.)  When allocating using MMAP, we don't use any of the\n hinting mechanisms (inconsistently) supported in various\n implementations of unix mmap, or distinguish reserving from\n committing memory. Instead, we just ask for space, and exploit\n contiguity when we get it.  It is probably possible to do\n better than this on some systems, but no general scheme seems\n to be significantly better.\n \n Management entails a simpler variant of the consolidation scheme\n used for chunks to reduce fragmentation -- new adjacent memory is\n normally prepended or appended to an existing segment. However,\n there are limitations compared to chunk consolidation that mostly\n reflect the fact that segment processing is relatively infrequent\n (occurring only when getting memory from system) and that we\n don't expect to have huge numbers of segments:\n \n * Segments are not indexed, so traversal requires linear scans.  (It\n would be possible to index these, but is not worth the extra\n overhead and complexity for most programs on most platforms.)\n * New segments are only appended to old ones when holding top-most\n memory; if they cannot be prepended to others, they are held in\n different segments.\n \n Except for the top-most segment of an mstate, each segment record\n is kept at the tail of its segment. Segments are added by pushing\n segment records onto the list headed by &mstate.seg for the\n containing mstate.\n \n Segment flags control allocation/merge/deallocation policies:\n * If EXTERN_BIT set, then we did not allocate this segment,\n and so should not try to deallocate or merge with others.\n (This currently holds only for the initial segment passed\n into create_mspace_with_base.)\n * If USE_MMAP_BIT set, the segment may be merged with\n other surrounding mmapped segments and trimmed/de-allocated\n using munmap.\n * If neither bit is set, then the segment was obtained using\n MORECORE so can be merged with surrounding MORECORE'd segments\n and deallocated/trimmed using MORECORE with negative arguments.\n */\n\nstruct malloc_segment {\n    char*        base;             /* base address */\n    size_t       size;             /* allocated size */\n    struct malloc_segment* next;   /* ptr to next segment */\n    flag_t       sflags;           /* mmap and extern flag */\n};\n\n#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT)\n#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)\n\ntypedef struct malloc_segment  msegment;\ntypedef struct malloc_segment* msegmentptr;\n\n/* ---------------------------- malloc_state ----------------------------- */\n\n/*\n A malloc_state holds all of the bookkeeping for a space.\n The main fields are:\n \n Top\n The topmost chunk of the currently active segment. Its size is\n cached in topsize.  The actual size of topmost space is\n topsize+TOP_FOOT_SIZE, which includes space reserved for adding\n fenceposts and segment records if necessary when getting more\n space from the system.  The size at which to autotrim top is\n cached from mparams in trim_check, except that it is disabled if\n an autotrim fails.\n \n Designated victim (dv)\n This is the preferred chunk for servicing small requests that\n don't have exact fits.  It is normally the chunk split off most\n recently to service another small request.  Its size is cached in\n dvsize. The link fields of this chunk are not maintained since it\n is not kept in a bin.\n \n SmallBins\n An array of bin headers for free chunks.  These bins hold chunks\n with sizes less than MIN_LARGE_SIZE bytes. Each bin contains\n chunks of all the same size, spaced 8 bytes apart.  To simplify\n use in double-linked lists, each bin header acts as a malloc_chunk\n pointing to the real first node, if it exists (else pointing to\n itself).  This avoids special-casing for headers.  But to avoid\n waste, we allocate only the fd/bk pointers of bins, and then use\n repositioning tricks to treat these as the fields of a chunk.\n \n TreeBins\n Treebins are pointers to the roots of trees holding a range of\n sizes. There are 2 equally spaced treebins for each power of two\n from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything\n larger.\n \n Bin maps\n There is one bit map for small bins (\"smallmap\") and one for\n treebins (\"treemap).  Each bin sets its bit when non-empty, and\n clears the bit when empty.  Bit operations are then used to avoid\n bin-by-bin searching -- nearly all \"search\" is done without ever\n looking at bins that won't be selected.  The bit maps\n conservatively use 32 bits per map word, even if on 64bit system.\n For a good description of some of the bit-based techniques used\n here, see Henry S. Warren Jr's book \"Hacker's Delight\" (and\n supplement at http://hackersdelight.org/). Many of these are\n intended to reduce the branchiness of paths through malloc etc, as\n well as to reduce the number of memory locations read or written.\n \n Segments\n A list of segments headed by an embedded malloc_segment record\n representing the initial space.\n \n Address check support\n The least_addr field is the least address ever obtained from\n MORECORE or MMAP. Attempted frees and reallocs of any address less\n than this are trapped (unless INSECURE is defined).\n \n Magic tag\n A cross-check field that should always hold same value as mparams.magic.\n \n Max allowed footprint\n The maximum allowed bytes to allocate from system (zero means no limit)\n \n Flags\n Bits recording whether to use MMAP, locks, or contiguous MORECORE\n \n Statistics\n Each space keeps track of current and maximum system memory\n obtained via MORECORE or MMAP.\n \n Trim support\n Fields holding the amount of unused topmost memory that should trigger\n trimming, and a counter to force periodic scanning to release unused\n non-topmost segments.\n \n Locking\n If USE_LOCKS is defined, the \"mutex\" lock is acquired and released\n around every public call using this mspace.\n \n Extension support\n A void* pointer and a size_t field that can be used to help implement\n extensions to this malloc.\n */\n\n/* Bin types, widths and sizes */\n#define NSMALLBINS        (32U)\n#define NTREEBINS         (32U)\n#define SMALLBIN_SHIFT    (3U)\n#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)\n#define TREEBIN_SHIFT     (8U)\n#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)\n#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)\n#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)\n\nstruct malloc_state {\n    binmap_t   smallmap;\n    binmap_t   treemap;\n    size_t     dvsize;\n    size_t     topsize;\n    char*      least_addr;\n    mchunkptr  dv;\n    mchunkptr  top;\n    size_t     trim_check;\n    size_t     release_checks;\n    size_t     magic;\n    mchunkptr  smallbins[(NSMALLBINS+1)*2];\n    tbinptr    treebins[NTREEBINS];\n    size_t     footprint;\n    size_t     max_footprint;\n    size_t     footprint_limit; /* zero means no limit */\n    flag_t     mflags;\n#if USE_LOCKS\n    MLOCK_T    mutex;     /* locate lock among fields that rarely change */\n#endif /* USE_LOCKS */\n    msegment   seg;\n    void*      extp;      /* Unused but available for extensions */\n    size_t     exts;\n};\n\ntypedef struct malloc_state*    mstate;\n\n/* ------------- Global malloc_state and malloc_params ------------------- */\n\n/*\n malloc_params holds global properties, including those that can be\n dynamically set using mallopt. There is a single instance, mparams,\n initialized in init_mparams. Note that the non-zeroness of \"magic\"\n also serves as an initialization flag.\n */\n\nstruct malloc_params {\n    size_t magic;\n    size_t page_size;\n    size_t granularity;\n    size_t mmap_threshold;\n    size_t trim_threshold;\n    flag_t default_mflags;\n};\n\nstatic struct malloc_params mparams;\n\n/* Ensure mparams initialized */\n#define ensure_initialization() (void)(mparams.magic != 0 || init_mparams())\n\n#if !ONLY_MSPACES\n\n/* The global malloc_state used for all non-\"mspace\" calls */\nstatic struct malloc_state _gm_;\n#define gm                 (&_gm_)\n#define is_global(M)       ((M) == &_gm_)\n\n#endif /* !ONLY_MSPACES */\n\n#define is_initialized(M)  ((M)->top != 0)\n\n/* -------------------------- system alloc setup ------------------------- */\n\n/* Operations on mflags */\n\n#define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)\n#define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)\n#if USE_LOCKS\n#define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)\n#else\n#define disable_lock(M)\n#endif\n\n#define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)\n#define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)\n#if HAVE_MMAP\n#define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)\n#else\n#define disable_mmap(M)\n#endif\n\n#define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)\n#define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)\n\n#define set_lock(M,L)\\\n((M)->mflags = (L)?\\\n((M)->mflags | USE_LOCK_BIT) :\\\n((M)->mflags & ~USE_LOCK_BIT))\n\n/* page-align a size */\n#define page_align(S)\\\n(((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))\n\n/* granularity-align a size */\n#define granularity_align(S)\\\n(((S) + (mparams.granularity - SIZE_T_ONE))\\\n& ~(mparams.granularity - SIZE_T_ONE))\n\n\n/* For mmap, use granularity alignment on windows, else page-align */\n#ifdef WIN32\n#define mmap_align(S) granularity_align(S)\n#else\n#define mmap_align(S) page_align(S)\n#endif\n\n/* For sys_alloc, enough padding to ensure can malloc request on success */\n#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)\n\n#define is_page_aligned(S)\\\n(((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)\n#define is_granularity_aligned(S)\\\n(((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)\n\n/*  True if segment S holds address A */\n#define segment_holds(S, A)\\\n((char*)(A) >= S->base && (char*)(A) < S->base + S->size)\n\n/* Return segment holding given address */\nstatic msegmentptr segment_holding(mstate m, char* addr) {\n    msegmentptr sp = &m->seg;\n    for (;;) {\n        if (addr >= sp->base && addr < sp->base + sp->size)\n            return sp;\n        if ((sp = sp->next) == 0)\n            return 0;\n    }\n}\n\n/* Return true if segment contains a segment link */\nstatic int has_segment_link(mstate m, msegmentptr ss) {\n    msegmentptr sp = &m->seg;\n    for (;;) {\n        if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)\n            return 1;\n        if ((sp = sp->next) == 0)\n            return 0;\n    }\n}\n\n#ifndef MORECORE_CANNOT_TRIM\n#define should_trim(M,s)  ((s) > (M)->trim_check)\n#else  /* MORECORE_CANNOT_TRIM */\n#define should_trim(M,s)  (0)\n#endif /* MORECORE_CANNOT_TRIM */\n\n/*\n TOP_FOOT_SIZE is padding at the end of a segment, including space\n that may be needed to place segment records and fenceposts when new\n noncontiguous segments are added.\n */\n#define TOP_FOOT_SIZE \\\n(align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)\n\n\n/* -------------------------------  Hooks -------------------------------- */\n\n/*\n PREACTION should be defined to return 0 on success, and nonzero on\n failure. If you are not using locking, you can redefine these to do\n anything you like.\n */\n\n#if USE_LOCKS\n#define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)\n#define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }\n#else /* USE_LOCKS */\n\n#ifndef PREACTION\n#define PREACTION(M) (0)\n#endif  /* PREACTION */\n\n#ifndef POSTACTION\n#define POSTACTION(M)\n#endif  /* POSTACTION */\n\n#endif /* USE_LOCKS */\n\n/*\n CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.\n USAGE_ERROR_ACTION is triggered on detected bad frees and\n reallocs. The argument p is an address that might have triggered the\n fault. It is ignored by the two predefined actions, but might be\n useful in custom actions that try to help diagnose errors.\n */\n\n#if PROCEED_ON_ERROR\n\n/* A count of the number of corruption errors causing resets */\nint malloc_corruption_error_count;\n\n/* default corruption action */\nstatic void reset_on_error(mstate m);\n\n#define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)\n#define USAGE_ERROR_ACTION(m, p)\n\n#else /* PROCEED_ON_ERROR */\n\n#ifndef CORRUPTION_ERROR_ACTION\n#define CORRUPTION_ERROR_ACTION(m) ABORT\n#endif /* CORRUPTION_ERROR_ACTION */\n\n#ifndef USAGE_ERROR_ACTION\n#define USAGE_ERROR_ACTION(m,p) ABORT\n#endif /* USAGE_ERROR_ACTION */\n\n#endif /* PROCEED_ON_ERROR */\n\n\n/* -------------------------- Debugging setup ---------------------------- */\n\n#if ! DEBUG\n\n#define check_free_chunk(M,P)\n#define check_inuse_chunk(M,P)\n#define check_malloced_chunk(M,P,N)\n#define check_mmapped_chunk(M,P)\n#define check_malloc_state(M)\n#define check_top_chunk(M,P)\n\n#else /* DEBUG */\n#define check_free_chunk(M,P)       do_check_free_chunk(M,P)\n#define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)\n#define check_top_chunk(M,P)        do_check_top_chunk(M,P)\n#define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)\n#define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)\n#define check_malloc_state(M)       do_check_malloc_state(M)\n\nstatic void   do_check_any_chunk(mstate m, mchunkptr p);\nstatic void   do_check_top_chunk(mstate m, mchunkptr p);\nstatic void   do_check_mmapped_chunk(mstate m, mchunkptr p);\nstatic void   do_check_inuse_chunk(mstate m, mchunkptr p);\nstatic void   do_check_free_chunk(mstate m, mchunkptr p);\nstatic void   do_check_malloced_chunk(mstate m, void* mem, size_t s);\nstatic void   do_check_tree(mstate m, tchunkptr t);\nstatic void   do_check_treebin(mstate m, bindex_t i);\nstatic void   do_check_smallbin(mstate m, bindex_t i);\nstatic void   do_check_malloc_state(mstate m);\nstatic int    bin_find(mstate m, mchunkptr x);\nstatic size_t traverse_and_check(mstate m);\n#endif /* DEBUG */\n\n/* ---------------------------- Indexing Bins ---------------------------- */\n\n#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)\n#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)\n#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)\n#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))\n\n/* addressing by index. See above about smallbin repositioning */\n#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))\n#define treebin_at(M,i)     (&((M)->treebins[i]))\n\n/* assign tree index for size S to variable I. Use x86 asm if possible  */\n#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__) || defined(__EMSCRIPTEN__))\n#define compute_tree_index(S, I)\\\n{\\\nunsigned int X = S >> TREEBIN_SHIFT;\\\nif (X == 0)\\\nI = 0;\\\nelse if (X > 0xFFFF)\\\nI = NTREEBINS-1;\\\nelse {\\\nunsigned int K = (unsigned) sizeof(X)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(X); \\\nI =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\\\n}\\\n}\n\n#elif defined (__INTEL_COMPILER)\n#define compute_tree_index(S, I)\\\n{\\\nsize_t X = S >> TREEBIN_SHIFT;\\\nif (X == 0)\\\nI = 0;\\\nelse if (X > 0xFFFF)\\\nI = NTREEBINS-1;\\\nelse {\\\nunsigned int K = _bit_scan_reverse (X); \\\nI =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\\\n}\\\n}\n\n#elif defined(_MSC_VER) && _MSC_VER>=1300\n#define compute_tree_index(S, I)\\\n{\\\nsize_t X = S >> TREEBIN_SHIFT;\\\nif (X == 0)\\\nI = 0;\\\nelse if (X > 0xFFFF)\\\nI = NTREEBINS-1;\\\nelse {\\\nunsigned int K;\\\n_BitScanReverse((DWORD *) &K, (DWORD) X);\\\nI =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\\\n}\\\n}\n\n#else /* GNUC */\n#define compute_tree_index(S, I)\\\n{\\\nsize_t X = S >> TREEBIN_SHIFT;\\\nif (X == 0)\\\nI = 0;\\\nelse if (X > 0xFFFF)\\\nI = NTREEBINS-1;\\\nelse {\\\nunsigned int Y = (unsigned int)X;\\\nunsigned int N = ((Y - 0x100) >> 16) & 8;\\\nunsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\\\nN += K;\\\nN += K = (((Y <<= K) - 0x4000) >> 16) & 2;\\\nK = 14 - N + ((Y <<= K) >> 15);\\\nI = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\\\n}\\\n}\n#endif /* GNUC */\n\n/* Bit representing maximum resolved size in a treebin at i */\n#define bit_for_tree_index(i) \\\n(i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)\n\n/* Shift placing maximum resolved bit in a treebin at i as sign bit */\n#define leftshift_for_tree_index(i) \\\n((i == NTREEBINS-1)? 0 : \\\n((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))\n\n/* The size of the smallest chunk held in bin with index i */\n#define minsize_for_tree_index(i) \\\n((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \\\n(((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))\n\n\n/* ------------------------ Operations on bin maps ----------------------- */\n\n/* bit corresponding to given index */\n#define idx2bit(i)              ((binmap_t)(1) << (i))\n\n/* Mark/Clear bits with given index */\n#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))\n#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))\n#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))\n\n#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))\n#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))\n#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))\n\n/* isolate the least set bit of a bitmap */\n#define least_bit(x)         ((x) & -(x))\n\n/* mask with all bits to left of least bit of x on */\n#define left_bits(x)         ((x<<1) | -(x<<1))\n\n/* mask with all bits to left of or equal to least bit of x on */\n#define same_or_left_bits(x) ((x) | -(x))\n\n/* index corresponding to given bit. Use x86 asm if possible */\n\n#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__) || defined(__EMSCRIPTEN__))\n#define compute_bit2idx(X, I)\\\n{\\\nunsigned int J;\\\nJ = __builtin_ctz(X); \\\nI = (bindex_t)J;\\\n}\n\n#elif defined (__INTEL_COMPILER)\n#define compute_bit2idx(X, I)\\\n{\\\nunsigned int J;\\\nJ = _bit_scan_forward (X); \\\nI = (bindex_t)J;\\\n}\n\n#elif defined(_MSC_VER) && _MSC_VER>=1300\n#define compute_bit2idx(X, I)\\\n{\\\nunsigned int J;\\\n_BitScanForward((DWORD *) &J, X);\\\nI = (bindex_t)J;\\\n}\n\n#elif USE_BUILTIN_FFS\n#define compute_bit2idx(X, I) I = ffs(X)-1\n\n#else\n#define compute_bit2idx(X, I)\\\n{\\\nunsigned int Y = X - 1;\\\nunsigned int K = Y >> (16-4) & 16;\\\nunsigned int N = K;        Y >>= K;\\\nN += K = Y >> (8-3) &  8;  Y >>= K;\\\nN += K = Y >> (4-2) &  4;  Y >>= K;\\\nN += K = Y >> (2-1) &  2;  Y >>= K;\\\nN += K = Y >> (1-0) &  1;  Y >>= K;\\\nI = (bindex_t)(N + Y);\\\n}\n#endif /* GNUC */\n\n\n/* ----------------------- Runtime Check Support ------------------------- */\n\n/*\n For security, the main invariant is that malloc/free/etc never\n writes to a static address other than malloc_state, unless static\n malloc_state itself has been corrupted, which cannot occur via\n malloc (because of these checks). In essence this means that we\n believe all pointers, sizes, maps etc held in malloc_state, but\n check all of those linked or offsetted from other embedded data\n structures.  These checks are interspersed with main code in a way\n that tends to minimize their run-time cost.\n \n When FOOTERS is defined, in addition to range checking, we also\n verify footer fields of inuse chunks, which can be used guarantee\n that the mstate controlling malloc/free is intact.  This is a\n streamlined version of the approach described by William Robertson\n et al in \"Run-time Detection of Heap-based Overflows\" LISA'03\n http://www.usenix.org/events/lisa03/tech/robertson.html The footer\n of an inuse chunk holds the xor of its mstate and a random seed,\n that is checked upon calls to free() and realloc().  This is\n (probabalistically) unguessable from outside the program, but can be\n computed by any code successfully malloc'ing any chunk, so does not\n itself provide protection against code that has already broken\n security through some other means.  Unlike Robertson et al, we\n always dynamically check addresses of all offset chunks (previous,\n next, etc). This turns out to be cheaper than relying on hashes.\n */\n\n#if !INSECURE\n/* Check if address a is at least as high as any from MORECORE or MMAP */\n#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)\n/* Check if address of next chunk n is higher than base chunk p */\n#define ok_next(p, n)    ((char*)(p) < (char*)(n))\n/* Check if p has inuse status */\n#define ok_inuse(p)     is_inuse(p)\n/* Check if p has its pinuse bit on */\n#define ok_pinuse(p)     pinuse(p)\n\n#else /* !INSECURE */\n#define ok_address(M, a) (1)\n#define ok_next(b, n)    (1)\n#define ok_inuse(p)      (1)\n#define ok_pinuse(p)     (1)\n#endif /* !INSECURE */\n\n#if (FOOTERS && !INSECURE)\n/* Check if (alleged) mstate m has expected magic field */\n#define ok_magic(M)      ((M)->magic == mparams.magic)\n#else  /* (FOOTERS && !INSECURE) */\n#define ok_magic(M)      (1)\n#endif /* (FOOTERS && !INSECURE) */\n\n/* In gcc, use __builtin_expect to minimize impact of checks */\n#if !INSECURE\n#if defined(__GNUC__) && __GNUC__ >= 3\n#define RTCHECK(e)  __builtin_expect(e, 1)\n#else /* GNUC */\n#define RTCHECK(e)  (e)\n#endif /* GNUC */\n#else /* !INSECURE */\n#define RTCHECK(e)  (1)\n#endif /* !INSECURE */\n\n/* macros to set up inuse chunks with or without footers */\n\n#if !FOOTERS\n\n#define mark_inuse_foot(M,p,s)\n\n/* Macros for setting head/foot of non-mmapped chunks */\n\n/* Set cinuse bit and pinuse bit of next chunk */\n#define set_inuse(M,p,s)\\\n((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\\\n((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)\n\n/* Set cinuse and pinuse of this chunk and pinuse of next chunk */\n#define set_inuse_and_pinuse(M,p,s)\\\n((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\\\n((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)\n\n/* Set size, cinuse and pinuse bit of this chunk */\n#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\\\n((p)->head = (s|PINUSE_BIT|CINUSE_BIT))\n\n#else /* FOOTERS */\n\n/* Set foot of inuse chunk to be xor of mstate and seed */\n#define mark_inuse_foot(M,p,s)\\\n(((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))\n\n#define get_mstate_for(p)\\\n((mstate)(((mchunkptr)((char*)(p) +\\\n(chunksize(p))))->prev_foot ^ mparams.magic))\n\n#define set_inuse(M,p,s)\\\n((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\\\n(((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \\\nmark_inuse_foot(M,p,s))\n\n#define set_inuse_and_pinuse(M,p,s)\\\n((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\\\n(((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\\\nmark_inuse_foot(M,p,s))\n\n#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\\\n((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\\\nmark_inuse_foot(M, p, s))\n\n#endif /* !FOOTERS */\n\n/* ---------------------------- setting mparams -------------------------- */\n\n#if LOCK_AT_FORK\nstatic void pre_fork(void)         { ACQUIRE_LOCK(&(gm)->mutex); }\nstatic void post_fork_parent(void) { RELEASE_LOCK(&(gm)->mutex); }\nstatic void post_fork_child(void)  { INITIAL_LOCK(&(gm)->mutex); }\n#endif /* LOCK_AT_FORK */\n\n/* Initialize mparams */\nstatic int init_mparams(void) {\n#ifdef NEED_GLOBAL_LOCK_INIT\n    if (malloc_global_mutex_status <= 0)\n        init_malloc_global_mutex();\n#endif\n    \n    ACQUIRE_MALLOC_GLOBAL_LOCK();\n    if (mparams.magic == 0) {\n        size_t magic;\n        size_t psize;\n        size_t gsize;\n        \n#ifndef WIN32\n        psize = malloc_getpagesize;\n        gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);\n#else /* WIN32 */\n        {\n            SYSTEM_INFO system_info;\n            GetSystemInfo(&system_info);\n            psize = system_info.dwPageSize;\n            gsize = ((DEFAULT_GRANULARITY != 0)?\n                     DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);\n        }\n#endif /* WIN32 */\n        \n        /* Sanity-check configuration:\n         size_t must be unsigned and as wide as pointer type.\n         ints must be at least 4 bytes.\n         alignment must be at least 8.\n         Alignment, min chunk size, and page size must all be powers of 2.\n         */\n        if ((sizeof(size_t) != sizeof(char*)) ||\n            (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||\n            (sizeof(int) < 4)  ||\n            (MALLOC_ALIGNMENT < (size_t)8U) ||\n            ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||\n            ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||\n            ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||\n            ((psize            & (psize-SIZE_T_ONE))            != 0))\n            ABORT;\n        mparams.granularity = gsize;\n        mparams.page_size = psize;\n        mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;\n        mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;\n#if MORECORE_CONTIGUOUS\n        mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;\n#else  /* MORECORE_CONTIGUOUS */\n        mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;\n#endif /* MORECORE_CONTIGUOUS */\n        \n#if !ONLY_MSPACES\n        /* Set up lock for main malloc area */\n        gm->mflags = mparams.default_mflags;\n        (void)INITIAL_LOCK(&gm->mutex);\n#endif\n#if LOCK_AT_FORK\n        pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);\n#endif\n        \n        {\n#if USE_DEV_RANDOM\n            int fd;\n            unsigned char buf[sizeof(size_t)];\n            /* Try to use /dev/urandom, else fall back on using time */\n            if ((fd = open(\"/dev/urandom\", O_RDONLY)) >= 0 &&\n                read(fd, buf, sizeof(buf)) == sizeof(buf)) {\n                magic = *((size_t *) buf);\n                close(fd);\n            }\n            else\n#endif /* USE_DEV_RANDOM */\n#ifdef WIN32\n                magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);\n#elif defined(LACKS_TIME_H) || defined(__EMSCRIPTEN__)\n            magic = (size_t)&magic ^ (size_t)0x55555555U;\n#else\n            magic = (size_t)(time(0) ^ (size_t)0x55555555U);\n#endif\n            magic |= (size_t)8U;    /* ensure nonzero */\n            magic &= ~(size_t)7U;   /* improve chances of fault for bad values */\n            /* Until memory modes commonly available, use volatile-write */\n            (*(volatile size_t *)(&(mparams.magic))) = magic;\n        }\n    }\n    \n    RELEASE_MALLOC_GLOBAL_LOCK();\n    return 1;\n}\n\n/* support for mallopt */\nstatic int change_mparam(int param_number, int value) {\n    size_t val;\n    ensure_initialization();\n    val = (value == -1)? MAX_SIZE_T : (size_t)value;\n    switch(param_number) {\n        case M_TRIM_THRESHOLD:\n            mparams.trim_threshold = val;\n            return 1;\n        case M_GRANULARITY:\n            if (val >= mparams.page_size && ((val & (val-1)) == 0)) {\n                mparams.granularity = val;\n                return 1;\n            }\n            else\n                return 0;\n        case M_MMAP_THRESHOLD:\n            mparams.mmap_threshold = val;\n            return 1;\n        default:\n            return 0;\n    }\n}\n\n#if DEBUG\n/* ------------------------- Debugging Support --------------------------- */\n\n/* Check properties of any chunk, whether free, inuse, mmapped etc  */\nstatic void do_check_any_chunk(mstate m, mchunkptr p) {\n    assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n    assert(ok_address(m, p));\n}\n\n/* Check properties of top chunk */\nstatic void do_check_top_chunk(mstate m, mchunkptr p) {\n    msegmentptr sp = segment_holding(m, (char*)p);\n    size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */\n    assert(sp != 0);\n    assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n    assert(ok_address(m, p));\n    assert(sz == m->topsize);\n    assert(sz > 0);\n    assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);\n    assert(pinuse(p));\n    assert(!pinuse(chunk_plus_offset(p, sz)));\n}\n\n/* Check properties of (inuse) mmapped chunks */\nstatic void do_check_mmapped_chunk(mstate m, mchunkptr p) {\n    size_t  sz = chunksize(p);\n    size_t len = (sz + (p->prev_foot) + MMAP_FOOT_PAD);\n    assert(is_mmapped(p));\n    assert(use_mmap(m));\n    assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));\n    assert(ok_address(m, p));\n    assert(!is_small(sz));\n    assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);\n    assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);\n    assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0);\n}\n\n/* Check properties of inuse chunks */\nstatic void do_check_inuse_chunk(mstate m, mchunkptr p) {\n    do_check_any_chunk(m, p);\n    assert(is_inuse(p));\n    assert(next_pinuse(p));\n    /* If not pinuse and not mmapped, previous chunk has OK offset */\n    assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);\n    if (is_mmapped(p))\n        do_check_mmapped_chunk(m, p);\n}\n\n/* Check properties of free chunks */\nstatic void do_check_free_chunk(mstate m, mchunkptr p) {\n    size_t sz = chunksize(p);\n    mchunkptr next = chunk_plus_offset(p, sz);\n    do_check_any_chunk(m, p);\n    assert(!is_inuse(p));\n    assert(!next_pinuse(p));\n    assert (!is_mmapped(p));\n    if (p != m->dv && p != m->top) {\n        if (sz >= MIN_CHUNK_SIZE) {\n            assert((sz & CHUNK_ALIGN_MASK) == 0);\n            assert(is_aligned(chunk2mem(p)));\n            assert(next->prev_foot == sz);\n            assert(pinuse(p));\n            assert (next == m->top || is_inuse(next));\n            assert(p->fd->bk == p);\n            assert(p->bk->fd == p);\n        }\n        else  /* markers are always of size SIZE_T_SIZE */\n            assert(sz == SIZE_T_SIZE);\n    }\n}\n\n/* Check properties of malloced chunks at the point they are malloced */\nstatic void do_check_malloced_chunk(mstate m, void* mem, size_t s) {\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n        size_t sz = p->head & ~INUSE_BITS;\n        do_check_inuse_chunk(m, p);\n        assert((sz & CHUNK_ALIGN_MASK) == 0);\n        assert(sz >= MIN_CHUNK_SIZE);\n        assert(sz >= s);\n        /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */\n        assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));\n    }\n}\n\n/* Check a tree and its subtrees.  */\nstatic void do_check_tree(mstate m, tchunkptr t) {\n    tchunkptr head = 0;\n    tchunkptr u = t;\n    bindex_t tindex = t->index;\n    size_t tsize = chunksize(t);\n    bindex_t idx;\n    compute_tree_index(tsize, idx);\n    assert(tindex == idx);\n    assert(tsize >= MIN_LARGE_SIZE);\n    assert(tsize >= minsize_for_tree_index(idx));\n    assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));\n    \n    do { /* traverse through chain of same-sized nodes */\n        do_check_any_chunk(m, ((mchunkptr)u));\n        assert(u->index == tindex);\n        assert(chunksize(u) == tsize);\n        assert(!is_inuse(u));\n        assert(!next_pinuse(u));\n        assert(u->fd->bk == u);\n        assert(u->bk->fd == u);\n        if (u->parent == 0) {\n            assert(u->child[0] == 0);\n            assert(u->child[1] == 0);\n        }\n        else {\n            assert(head == 0); /* only one node on chain has parent */\n            head = u;\n            assert(u->parent != u);\n            assert (u->parent->child[0] == u ||\n                    u->parent->child[1] == u ||\n                    *((tbinptr*)(u->parent)) == u);\n            if (u->child[0] != 0) {\n                assert(u->child[0]->parent == u);\n                assert(u->child[0] != u);\n                do_check_tree(m, u->child[0]);\n            }\n            if (u->child[1] != 0) {\n                assert(u->child[1]->parent == u);\n                assert(u->child[1] != u);\n                do_check_tree(m, u->child[1]);\n            }\n            if (u->child[0] != 0 && u->child[1] != 0) {\n                assert(chunksize(u->child[0]) < chunksize(u->child[1]));\n            }\n        }\n        u = u->fd;\n    } while (u != t);\n    assert(head != 0);\n}\n\n/*  Check all the chunks in a treebin.  */\nstatic void do_check_treebin(mstate m, bindex_t i) {\n    tbinptr* tb = treebin_at(m, i);\n    tchunkptr t = *tb;\n    int empty = (m->treemap & (1U << i)) == 0;\n    if (t == 0)\n        assert(empty);\n    if (!empty)\n        do_check_tree(m, t);\n}\n\n/*  Check all the chunks in a smallbin.  */\nstatic void do_check_smallbin(mstate m, bindex_t i) {\n    sbinptr b = smallbin_at(m, i);\n    mchunkptr p = b->bk;\n    unsigned int empty = (m->smallmap & (1U << i)) == 0;\n    if (p == b)\n        assert(empty);\n    if (!empty) {\n        for (; p != b; p = p->bk) {\n            size_t size = chunksize(p);\n            mchunkptr q;\n            /* each chunk claims to be free */\n            do_check_free_chunk(m, p);\n            /* chunk belongs in bin */\n            assert(small_index(size) == i);\n            assert(p->bk == b || chunksize(p->bk) == chunksize(p));\n            /* chunk is followed by an inuse chunk */\n            q = next_chunk(p);\n            if (q->head != FENCEPOST_HEAD)\n                do_check_inuse_chunk(m, q);\n        }\n    }\n}\n\n/* Find x in a bin. Used in other check functions. */\nstatic int bin_find(mstate m, mchunkptr x) {\n    size_t size = chunksize(x);\n    if (is_small(size)) {\n        bindex_t sidx = small_index(size);\n        sbinptr b = smallbin_at(m, sidx);\n        if (smallmap_is_marked(m, sidx)) {\n            mchunkptr p = b;\n            do {\n                if (p == x)\n                    return 1;\n            } while ((p = p->fd) != b);\n        }\n    }\n    else {\n        bindex_t tidx;\n        compute_tree_index(size, tidx);\n        if (treemap_is_marked(m, tidx)) {\n            tchunkptr t = *treebin_at(m, tidx);\n            size_t sizebits = size << leftshift_for_tree_index(tidx);\n            while (t != 0 && chunksize(t) != size) {\n                t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];\n                sizebits <<= 1;\n            }\n            if (t != 0) {\n                tchunkptr u = t;\n                do {\n                    if (u == (tchunkptr)x)\n                        return 1;\n                } while ((u = u->fd) != t);\n            }\n        }\n    }\n    return 0;\n}\n\n/* Traverse each chunk and check it; return total */\nstatic size_t traverse_and_check(mstate m) {\n    size_t sum = 0;\n    if (is_initialized(m)) {\n        msegmentptr s = &m->seg;\n        sum += m->topsize + TOP_FOOT_SIZE;\n        while (s != 0) {\n            mchunkptr q = align_as_chunk(s->base);\n            mchunkptr lastq = 0;\n            assert(pinuse(q));\n            while (segment_holds(s, q) &&\n                   q != m->top && q->head != FENCEPOST_HEAD) {\n                sum += chunksize(q);\n                if (is_inuse(q)) {\n                    assert(!bin_find(m, q));\n                    do_check_inuse_chunk(m, q);\n                }\n                else {\n                    assert(q == m->dv || bin_find(m, q));\n                    assert(lastq == 0 || is_inuse(lastq)); /* Not 2 consecutive free */\n                    do_check_free_chunk(m, q);\n                }\n                lastq = q;\n                q = next_chunk(q);\n            }\n            s = s->next;\n        }\n    }\n    return sum;\n}\n\n\n/* Check all properties of malloc_state. */\nstatic void do_check_malloc_state(mstate m) {\n    bindex_t i;\n    size_t total;\n    /* check bins */\n    for (i = 0; i < NSMALLBINS; ++i)\n        do_check_smallbin(m, i);\n    for (i = 0; i < NTREEBINS; ++i)\n        do_check_treebin(m, i);\n    \n    if (m->dvsize != 0) { /* check dv chunk */\n        do_check_any_chunk(m, m->dv);\n        assert(m->dvsize == chunksize(m->dv));\n        assert(m->dvsize >= MIN_CHUNK_SIZE);\n        assert(bin_find(m, m->dv) == 0);\n    }\n    \n    if (m->top != 0) {   /* check top chunk */\n        do_check_top_chunk(m, m->top);\n        /*assert(m->topsize == chunksize(m->top)); redundant */\n        assert(m->topsize > 0);\n        assert(bin_find(m, m->top) == 0);\n    }\n    \n    total = traverse_and_check(m);\n    assert(total <= m->footprint);\n    assert(m->footprint <= m->max_footprint);\n}\n#endif /* DEBUG */\n\n/* ----------------------------- statistics ------------------------------ */\n\n#if !NO_MALLINFO\nstatic struct mallinfo internal_mallinfo(mstate m) {\n    struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    ensure_initialization();\n    if (!PREACTION(m)) {\n        check_malloc_state(m);\n        if (is_initialized(m)) {\n            size_t nfree = SIZE_T_ONE; /* top always free */\n            size_t mfree = m->topsize + TOP_FOOT_SIZE;\n            size_t sum = mfree;\n            msegmentptr s = &m->seg;\n            while (s != 0) {\n                mchunkptr q = align_as_chunk(s->base);\n                while (segment_holds(s, q) &&\n                       q != m->top && q->head != FENCEPOST_HEAD) {\n                    size_t sz = chunksize(q);\n                    sum += sz;\n                    if (!is_inuse(q)) {\n                        mfree += sz;\n                        ++nfree;\n                    }\n                    q = next_chunk(q);\n                }\n                s = s->next;\n            }\n            \n            nm.arena    = sum;\n            nm.ordblks  = nfree;\n            nm.hblkhd   = m->footprint - sum;\n            nm.usmblks  = m->max_footprint;\n            nm.uordblks = m->footprint - mfree;\n            nm.fordblks = mfree;\n            nm.keepcost = m->topsize;\n        }\n        \n        POSTACTION(m);\n    }\n    return nm;\n}\n#endif /* !NO_MALLINFO */\n\n#if !NO_MALLOC_STATS\nstatic void internal_malloc_stats(mstate m) {\n    ensure_initialization();\n    if (!PREACTION(m)) {\n        size_t maxfp = 0;\n        size_t fp = 0;\n        size_t used = 0;\n        check_malloc_state(m);\n        if (is_initialized(m)) {\n            msegmentptr s = &m->seg;\n            maxfp = m->max_footprint;\n            fp = m->footprint;\n            used = fp - (m->topsize + TOP_FOOT_SIZE);\n            \n            while (s != 0) {\n                mchunkptr q = align_as_chunk(s->base);\n                while (segment_holds(s, q) &&\n                       q != m->top && q->head != FENCEPOST_HEAD) {\n                    if (!is_inuse(q))\n                        used -= chunksize(q);\n                    q = next_chunk(q);\n                }\n                s = s->next;\n            }\n        }\n        POSTACTION(m); /* drop lock */\n        fprintf(stderr, \"max system bytes = %10lu\\n\", (unsigned long)(maxfp));\n        fprintf(stderr, \"system bytes     = %10lu\\n\", (unsigned long)(fp));\n        fprintf(stderr, \"in use bytes     = %10lu\\n\", (unsigned long)(used));\n    }\n}\n#endif /* NO_MALLOC_STATS */\n\n/* ----------------------- Operations on smallbins ----------------------- */\n\n/*\n Various forms of linking and unlinking are defined as macros.  Even\n the ones for trees, which are very long but have very short typical\n paths.  This is ugly but reduces reliance on inlining support of\n compilers.\n */\n\n/* Link a free chunk into a smallbin  */\n#define insert_small_chunk(M, P, S) {\\\nbindex_t I  = small_index(S);\\\nmchunkptr B = smallbin_at(M, I);\\\nmchunkptr F = B;\\\nassert(S >= MIN_CHUNK_SIZE);\\\nif (!smallmap_is_marked(M, I))\\\nmark_smallmap(M, I);\\\nelse if (RTCHECK(ok_address(M, B->fd)))\\\nF = B->fd;\\\nelse {\\\nCORRUPTION_ERROR_ACTION(M);\\\n}\\\nB->fd = P;\\\nF->bk = P;\\\nP->fd = F;\\\nP->bk = B;\\\n}\n\n/* Unlink a chunk from a smallbin  */\n#define unlink_small_chunk(M, P, S) {\\\nmchunkptr F = P->fd;\\\nmchunkptr B = P->bk;\\\nbindex_t I = small_index(S);\\\nassert(P != B);\\\nassert(P != F);\\\nassert(chunksize(P) == small_index2size(I));\\\nif (RTCHECK(F == smallbin_at(M,I) || (ok_address(M, F) && F->bk == P))) { \\\nif (B == F) {\\\nclear_smallmap(M, I);\\\n}\\\nelse if (RTCHECK(B == smallbin_at(M,I) ||\\\n(ok_address(M, B) && B->fd == P))) {\\\nF->bk = B;\\\nB->fd = F;\\\n}\\\nelse {\\\nCORRUPTION_ERROR_ACTION(M);\\\n}\\\n}\\\nelse {\\\nCORRUPTION_ERROR_ACTION(M);\\\n}\\\n}\n\n/* Unlink the first chunk from a smallbin */\n#define unlink_first_small_chunk(M, B, P, I) {\\\nmchunkptr F = P->fd;\\\nassert(P != B);\\\nassert(P != F);\\\nassert(chunksize(P) == small_index2size(I));\\\nif (B == F) {\\\nclear_smallmap(M, I);\\\n}\\\nelse if (RTCHECK(ok_address(M, F) && F->bk == P)) {\\\nF->bk = B;\\\nB->fd = F;\\\n}\\\nelse {\\\nCORRUPTION_ERROR_ACTION(M);\\\n}\\\n}\n\n/* Replace dv node, binning the old one */\n/* Used only when dvsize known to be small */\n#define replace_dv(M, P, S) {\\\nsize_t DVS = M->dvsize;\\\nassert(is_small(DVS));\\\nif (DVS != 0) {\\\nmchunkptr DV = M->dv;\\\ninsert_small_chunk(M, DV, DVS);\\\n}\\\nM->dvsize = S;\\\nM->dv = P;\\\n}\n\n/* ------------------------- Operations on trees ------------------------- */\n\n/* Insert chunk into tree */\n#define insert_large_chunk(M, X, S) {\\\ntbinptr* H;\\\nbindex_t I;\\\ncompute_tree_index(S, I);\\\nH = treebin_at(M, I);\\\nX->index = I;\\\nX->child[0] = X->child[1] = 0;\\\nif (!treemap_is_marked(M, I)) {\\\nmark_treemap(M, I);\\\n*H = X;\\\nX->parent = (tchunkptr)H;\\\nX->fd = X->bk = X;\\\n}\\\nelse {\\\ntchunkptr T = *H;\\\nsize_t K = S << leftshift_for_tree_index(I);\\\nfor (;;) {\\\nif (chunksize(T) != S) {\\\ntchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\\\nK <<= 1;\\\nif (*C != 0)\\\nT = *C;\\\nelse if (RTCHECK(ok_address(M, C))) {\\\n*C = X;\\\nX->parent = T;\\\nX->fd = X->bk = X;\\\nbreak;\\\n}\\\nelse {\\\nCORRUPTION_ERROR_ACTION(M);\\\nbreak;\\\n}\\\n}\\\nelse {\\\ntchunkptr F = T->fd;\\\nif (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\\\nT->fd = F->bk = X;\\\nX->fd = F;\\\nX->bk = T;\\\nX->parent = 0;\\\nbreak;\\\n}\\\nelse {\\\nCORRUPTION_ERROR_ACTION(M);\\\nbreak;\\\n}\\\n}\\\n}\\\n}\\\n}\n\n/*\n Unlink steps:\n \n 1. If x is a chained node, unlink it from its same-sized fd/bk links\n and choose its bk node as its replacement.\n 2. If x was the last node of its size, but not a leaf node, it must\n be replaced with a leaf node (not merely one with an open left or\n right), to make sure that lefts and rights of descendents\n correspond properly to bit masks.  We use the rightmost descendent\n of x.  We could use any other leaf, but this is easy to locate and\n tends to counteract removal of leftmosts elsewhere, and so keeps\n paths shorter than minimally guaranteed.  This doesn't loop much\n because on average a node in a tree is near the bottom.\n 3. If x is the base of a chain (i.e., has parent links) relink\n x's parent and children to x's replacement (or null if none).\n */\n\n#define unlink_large_chunk(M, X) { \\\ntchunkptr XP = X->parent; \\\ntchunkptr R; \\\nif (X->bk != X) { \\\ntchunkptr F = X->fd; \\\nR = X->bk; \\\nif (RTCHECK(ok_address(M, F) && F->bk == X && R->fd == X)) { \\\nF->bk = R; \\\nR->fd = F; \\\n} \\\nelse { \\\nCORRUPTION_ERROR_ACTION(M); \\\n} \\\n} \\\nelse { \\\ntchunkptr* RP; \\\nif (((R = *(RP = &(X->child[1]))) != 0) || \\\n((R = *(RP = &(X->child[0]))) != 0)) { \\\ntchunkptr* CP; \\\nwhile ((*(CP = &(R->child[1])) != 0) || \\\n(*(CP = &(R->child[0])) != 0)) { \\\nR = *(RP = CP); \\\n} \\\nif (RTCHECK(ok_address(M, RP))) \\\n*RP = 0; \\\nelse { \\\nCORRUPTION_ERROR_ACTION(M); \\\n} \\\n} \\\n} \\\nif (XP != 0) { \\\ntbinptr* H = treebin_at(M, X->index); \\\nif (X == *H) { \\\nif ((*H = R) == 0) \\\nclear_treemap(M, X->index); \\\n} \\\nelse if (RTCHECK(ok_address(M, XP))) { \\\nif (XP->child[0] == X) \\\nXP->child[0] = R; \\\nelse \\\nXP->child[1] = R; \\\n} \\\nelse \\\nCORRUPTION_ERROR_ACTION(M); \\\nif (R != 0) { \\\nif (RTCHECK(ok_address(M, R))) { \\\ntchunkptr C0, C1; \\\nR->parent = XP; \\\nif ((C0 = X->child[0]) != 0) { \\\nif (RTCHECK(ok_address(M, C0))) { \\\nR->child[0] = C0; \\\nC0->parent = R; \\\n} \\\nelse \\\nCORRUPTION_ERROR_ACTION(M); \\\n} \\\nif ((C1 = X->child[1]) != 0) { \\\nif (RTCHECK(ok_address(M, C1))) { \\\nR->child[1] = C1; \\\nC1->parent = R; \\\n} \\\nelse \\\nCORRUPTION_ERROR_ACTION(M); \\\n} \\\n} \\\nelse \\\nCORRUPTION_ERROR_ACTION(M); \\\n} \\\n} \\\n}\n\n/* Relays to large vs small bin operations */\n\n#define insert_chunk(M, P, S) \\\nif (is_small(S)) insert_small_chunk(M, P, S) \\\nelse { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }\n\n#define unlink_chunk(M, P, S) \\\nif (is_small(S)) unlink_small_chunk(M, P, S) \\\nelse { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }\n\n\n/* Relays to internal calls to malloc/free from realloc, memalign etc */\n\n#if ONLY_MSPACES\n#define internal_malloc(m, b) mspace_malloc(m, b)\n#define internal_free(m, mem) mspace_free(m,mem);\n#else /* ONLY_MSPACES */\n#if MSPACES\n#define internal_malloc(m, b)\\\n((m == gm)? dlmalloc(b) : mspace_malloc(m, b))\n#define internal_free(m, mem)\\\nif (m == gm) dlfree(mem); else mspace_free(m,mem);\n#else /* MSPACES */\n#define internal_malloc(m, b) dlmalloc(b)\n#define internal_free(m, mem) dlfree(mem)\n#endif /* MSPACES */\n#endif /* ONLY_MSPACES */\n\n/* -----------------------  Direct-mmapping chunks ----------------------- */\n\n/*\n Directly mmapped chunks are set up with an offset to the start of\n the mmapped region stored in the prev_foot field of the chunk. This\n allows reconstruction of the required argument to MUNMAP when freed,\n and also allows adjustment of the returned chunk to meet alignment\n requirements (especially in memalign).\n */\n\n/* Malloc using mmap */\nstatic void* mmap_alloc(mstate m, size_t nb) {\n    size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n    if (m->footprint_limit != 0) {\n        size_t fp = m->footprint + mmsize;\n        if (fp <= m->footprint || fp > m->footprint_limit)\n            return 0;\n    }\n    if (mmsize > nb) {     /* Check for wrap around 0 */\n        char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));\n        if (mm != CMFAIL) {\n            size_t offset = align_offset(chunk2mem(mm));\n            size_t psize = mmsize - offset - MMAP_FOOT_PAD;\n            mchunkptr p = (mchunkptr)(mm + offset);\n            p->prev_foot = offset;\n            p->head = psize;\n            mark_inuse_foot(m, p, psize);\n            chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;\n            chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;\n            \n            if (m->least_addr == 0 || mm < m->least_addr)\n                m->least_addr = mm;\n            if ((m->footprint += mmsize) > m->max_footprint)\n                m->max_footprint = m->footprint;\n            assert(is_aligned(chunk2mem(p)));\n            check_mmapped_chunk(m, p);\n            return chunk2mem(p);\n        }\n    }\n    return 0;\n}\n\n/* Realloc using mmap */\nstatic mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {\n    size_t oldsize = chunksize(oldp);\n    (void)flags; /* placate people compiling -Wunused */\n    if (is_small(nb)) /* Can't shrink mmap regions below small size */\n        return 0;\n    /* Keep old chunk if big enough but not too big */\n    if (oldsize >= nb + SIZE_T_SIZE &&\n        (oldsize - nb) <= (mparams.granularity << 1))\n        return oldp;\n    else {\n        size_t offset = oldp->prev_foot;\n        size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;\n        size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n        char* cp = (char*)CALL_MREMAP((char*)oldp - offset,\n                                      oldmmsize, newmmsize, flags);\n        if (cp != CMFAIL) {\n            mchunkptr newp = (mchunkptr)(cp + offset);\n            size_t psize = newmmsize - offset - MMAP_FOOT_PAD;\n            newp->head = psize;\n            mark_inuse_foot(m, newp, psize);\n            chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;\n            chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;\n            \n            if (cp < m->least_addr)\n                m->least_addr = cp;\n            if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)\n                m->max_footprint = m->footprint;\n            check_mmapped_chunk(m, newp);\n            return newp;\n        }\n    }\n    return 0;\n}\n\n\n/* -------------------------- mspace management -------------------------- */\n\n/* Initialize top chunk and its size */\nstatic void init_top(mstate m, mchunkptr p, size_t psize) {\n    /* Ensure alignment */\n    size_t offset = align_offset(chunk2mem(p));\n    p = (mchunkptr)((char*)p + offset);\n    psize -= offset;\n    \n    m->top = p;\n    m->topsize = psize;\n    p->head = psize | PINUSE_BIT;\n    /* set size of fake trailing chunk holding overhead space only once */\n    chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;\n    m->trim_check = mparams.trim_threshold; /* reset on each update */\n}\n\n/* Initialize bins for a new mstate that is otherwise zeroed out */\nstatic void init_bins(mstate m) {\n    /* Establish circular links for smallbins */\n    bindex_t i;\n    for (i = 0; i < NSMALLBINS; ++i) {\n        sbinptr bin = smallbin_at(m,i);\n        bin->fd = bin->bk = bin;\n    }\n}\n\n#if PROCEED_ON_ERROR\n\n/* default corruption action */\nstatic void reset_on_error(mstate m) {\n    int i;\n    ++malloc_corruption_error_count;\n    /* Reinitialize fields to forget about all memory */\n    m->smallmap = m->treemap = 0;\n    m->dvsize = m->topsize = 0;\n    m->seg.base = 0;\n    m->seg.size = 0;\n    m->seg.next = 0;\n    m->top = m->dv = 0;\n    for (i = 0; i < NTREEBINS; ++i)\n        *treebin_at(m, i) = 0;\n    init_bins(m);\n}\n#endif /* PROCEED_ON_ERROR */\n\n/* Allocate chunk and prepend remainder with chunk in successor base. */\nstatic void* prepend_alloc(mstate m, char* newbase, char* oldbase,\n                           size_t nb) {\n    mchunkptr p = align_as_chunk(newbase);\n    mchunkptr oldfirst = align_as_chunk(oldbase);\n    size_t psize = (char*)oldfirst - (char*)p;\n    mchunkptr q = chunk_plus_offset(p, nb);\n    size_t qsize = psize - nb;\n    set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n    \n    assert((char*)oldfirst > (char*)q);\n    assert(pinuse(oldfirst));\n    assert(qsize >= MIN_CHUNK_SIZE);\n    \n    /* consolidate remainder with first chunk of old base */\n    if (oldfirst == m->top) {\n        size_t tsize = m->topsize += qsize;\n        m->top = q;\n        q->head = tsize | PINUSE_BIT;\n        check_top_chunk(m, q);\n    }\n    else if (oldfirst == m->dv) {\n        size_t dsize = m->dvsize += qsize;\n        m->dv = q;\n        set_size_and_pinuse_of_free_chunk(q, dsize);\n    }\n    else {\n        if (!is_inuse(oldfirst)) {\n            size_t nsize = chunksize(oldfirst);\n            unlink_chunk(m, oldfirst, nsize);\n            oldfirst = chunk_plus_offset(oldfirst, nsize);\n            qsize += nsize;\n        }\n        set_free_with_pinuse(q, qsize, oldfirst);\n        insert_chunk(m, q, qsize);\n        check_free_chunk(m, q);\n    }\n    \n    check_malloced_chunk(m, chunk2mem(p), nb);\n    return chunk2mem(p);\n}\n\n/* Add a segment to hold a new noncontiguous region */\nstatic void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {\n    /* Determine locations and sizes of segment, fenceposts, old top */\n    char* old_top = (char*)m->top;\n    msegmentptr oldsp = segment_holding(m, old_top);\n    char* old_end = oldsp->base + oldsp->size;\n    size_t ssize = pad_request(sizeof(struct malloc_segment));\n    char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);\n    size_t offset = align_offset(chunk2mem(rawsp));\n    char* asp = rawsp + offset;\n    char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;\n    mchunkptr sp = (mchunkptr)csp;\n    msegmentptr ss = (msegmentptr)(chunk2mem(sp));\n    mchunkptr tnext = chunk_plus_offset(sp, ssize);\n    mchunkptr p = tnext;\n    int nfences = 0;\n    \n    /* reset top to new space */\n    init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);\n    \n    /* Set up segment record */\n    assert(is_aligned(ss));\n    set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);\n    *ss = m->seg; /* Push current record */\n    m->seg.base = tbase;\n    m->seg.size = tsize;\n    m->seg.sflags = mmapped;\n    m->seg.next = ss;\n    \n    /* Insert trailing fenceposts */\n    for (;;) {\n        mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);\n        p->head = FENCEPOST_HEAD;\n        ++nfences;\n        if ((char*)(&(nextp->head)) < old_end)\n            p = nextp;\n        else\n            break;\n    }\n    assert(nfences >= 2);\n    \n    /* Insert the rest of old top into a bin as an ordinary free chunk */\n    if (csp != old_top) {\n        mchunkptr q = (mchunkptr)old_top;\n        size_t psize = csp - old_top;\n        mchunkptr tn = chunk_plus_offset(q, psize);\n        set_free_with_pinuse(q, psize, tn);\n        insert_chunk(m, q, psize);\n    }\n    \n    check_top_chunk(m, m->top);\n}\n\n/* -------------------------- System allocation -------------------------- */\n\n/* Get memory from system using MORECORE or MMAP */\nstatic void* sys_alloc(mstate m, size_t nb) {\n    char* tbase = CMFAIL;\n    size_t tsize = 0;\n    flag_t mmap_flag = 0;\n    size_t asize; /* allocation size */\n    \n    ensure_initialization();\n    \n    /* Directly map large chunks, but only if already initialized */\n    if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {\n        void* mem = mmap_alloc(m, nb);\n        if (mem != 0)\n            return mem;\n    }\n    \n    asize = granularity_align(nb + SYS_ALLOC_PADDING);\n    if (asize <= nb)\n        return 0; /* wraparound */\n    if (m->footprint_limit != 0) {\n        size_t fp = m->footprint + asize;\n        if (fp <= m->footprint || fp > m->footprint_limit)\n            return 0;\n    }\n    \n    /*\n     Try getting memory in any of three ways (in most-preferred to\n     least-preferred order):\n     1. A call to MORECORE that can normally contiguously extend memory.\n     (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or\n     or main space is mmapped or a previous contiguous call failed)\n     2. A call to MMAP new space (disabled if not HAVE_MMAP).\n     Note that under the default settings, if MORECORE is unable to\n     fulfill a request, and HAVE_MMAP is true, then mmap is\n     used as a noncontiguous system allocator. This is a useful backup\n     strategy for systems with holes in address spaces -- in this case\n     sbrk cannot contiguously expand the heap, but mmap may be able to\n     find space.\n     3. A call to MORECORE that cannot usually contiguously extend memory.\n     (disabled if not HAVE_MORECORE)\n     \n     In all cases, we need to request enough bytes from system to ensure\n     we can malloc nb bytes upon success, so pad with enough space for\n     top_foot, plus alignment-pad to make sure we don't lose bytes if\n     not on boundary, and round this up to a granularity unit.\n     */\n    \n    if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {\n        char* br = CMFAIL;\n        size_t ssize = asize; /* sbrk call size */\n        msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);\n        ACQUIRE_MALLOC_GLOBAL_LOCK();\n        \n        if (ss == 0) {  /* First time through or recovery */\n            char* base = (char*)CALL_MORECORE(0);\n            if (base != CMFAIL) {\n                size_t fp;\n                /* Adjust to end on a page boundary */\n                if (!is_page_aligned(base))\n                    ssize += (page_align((size_t)base) - (size_t)base);\n                fp = m->footprint + ssize; /* recheck limits */\n                if (ssize > nb &&\n                    (UNSIGNED_MORECORE || ssize < HALF_MAX_SIZE_T) &&\n                    (m->footprint_limit == 0 ||\n                     (fp > m->footprint && fp <= m->footprint_limit)) &&\n                    (br = (char*)(CALL_MORECORE(ssize))) == base) {\n                    tbase = base;\n                    tsize = ssize;\n                }\n            }\n        }\n        else {\n            /* Subtract out existing available top space from MORECORE request. */\n            ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);\n            /* Use mem here only if it did continuously extend old space */\n            if ((UNSIGNED_MORECORE || ssize < HALF_MAX_SIZE_T) &&\n                (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {\n                tbase = br;\n                tsize = ssize;\n            }\n        }\n        \n        if (tbase == CMFAIL) {    /* Cope with partial failure */\n            if (br != CMFAIL) {    /* Try to use/extend the space we did get */\n                if ((UNSIGNED_MORECORE || ssize < HALF_MAX_SIZE_T) &&\n                    ssize < nb + SYS_ALLOC_PADDING) {\n                    size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);\n                    if (UNSIGNED_MORECORE || esize < HALF_MAX_SIZE_T) {\n                        char* end = (char*)CALL_MORECORE(esize);\n                        if (end != CMFAIL)\n                            ssize += esize;\n                        else {            /* Can't use; try to release */\n                            if (!UNSIGNED_MORECORE) {\n                                (void) CALL_MORECORE(-ssize);\n                            }\n                            br = CMFAIL;\n                        }\n                    }\n                }\n            }\n            if (br != CMFAIL) {    /* Use the space we did get */\n                tbase = br;\n                tsize = ssize;\n            }\n            else\n                disable_contiguous(m); /* Don't try contiguous path in the future */\n        }\n        \n        RELEASE_MALLOC_GLOBAL_LOCK();\n    }\n    \n    if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */\n        char* mp = (char*)(CALL_MMAP(asize));\n        if (mp != CMFAIL) {\n            tbase = mp;\n            tsize = asize;\n            mmap_flag = USE_MMAP_BIT;\n        }\n    }\n    \n    if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */\n        if (UNSIGNED_MORECORE || asize < HALF_MAX_SIZE_T) {\n            char* br = CMFAIL;\n            char* end = CMFAIL;\n            ACQUIRE_MALLOC_GLOBAL_LOCK();\n            br = (char*)(CALL_MORECORE(asize));\n            end = (char*)(CALL_MORECORE(0));\n            RELEASE_MALLOC_GLOBAL_LOCK();\n            if (br != CMFAIL && end != CMFAIL && br < end) {\n                size_t ssize = end - br;\n                if (ssize > nb + TOP_FOOT_SIZE) {\n                    tbase = br;\n                    tsize = ssize;\n                }\n            }\n        }\n    }\n    \n    if (tbase != CMFAIL) {\n        \n        if ((m->footprint += tsize) > m->max_footprint)\n            m->max_footprint = m->footprint;\n        \n        if (!is_initialized(m)) { /* first-time initialization */\n            if (m->least_addr == 0 || tbase < m->least_addr)\n                m->least_addr = tbase;\n            m->seg.base = tbase;\n            m->seg.size = tsize;\n            m->seg.sflags = mmap_flag;\n            m->magic = mparams.magic;\n            m->release_checks = MAX_RELEASE_CHECK_RATE;\n            init_bins(m);\n#if !ONLY_MSPACES\n            if (is_global(m))\n                init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);\n            else\n#endif\n            {\n                /* Offset top by embedded malloc_state */\n                mchunkptr mn = next_chunk(mem2chunk(m));\n                init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);\n            }\n        }\n        \n        else {\n            /* Try to merge with an existing segment */\n            msegmentptr sp = &m->seg;\n            /* Only consider most recent segment if traversal suppressed */\n            while (sp != 0 && tbase != sp->base + sp->size)\n                sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;\n            if (sp != 0 &&\n                !is_extern_segment(sp) &&\n                (sp->sflags & USE_MMAP_BIT) == mmap_flag &&\n                segment_holds(sp, m->top)) { /* append */\n                sp->size += tsize;\n                init_top(m, m->top, m->topsize + tsize);\n            }\n            else {\n                if (tbase < m->least_addr)\n                    m->least_addr = tbase;\n                sp = &m->seg;\n                while (sp != 0 && sp->base != tbase + tsize)\n                    sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;\n                if (sp != 0 &&\n                    !is_extern_segment(sp) &&\n                    (sp->sflags & USE_MMAP_BIT) == mmap_flag) {\n                    char* oldbase = sp->base;\n                    sp->base = tbase;\n                    sp->size += tsize;\n                    return prepend_alloc(m, tbase, oldbase, nb);\n                }\n                else\n                    add_segment(m, tbase, tsize, mmap_flag);\n            }\n        }\n        \n        if (nb < m->topsize) { /* Allocate from new or extended top space */\n            size_t rsize = m->topsize -= nb;\n            mchunkptr p = m->top;\n            mchunkptr r = m->top = chunk_plus_offset(p, nb);\n            r->head = rsize | PINUSE_BIT;\n            set_size_and_pinuse_of_inuse_chunk(m, p, nb);\n            check_top_chunk(m, m->top);\n            check_malloced_chunk(m, chunk2mem(p), nb);\n            return chunk2mem(p);\n        }\n    }\n    \n    MALLOC_FAILURE_ACTION;\n    return 0;\n}\n\n/* -----------------------  system deallocation -------------------------- */\n\n/* Unmap and unlink any mmapped segments that don't contain used chunks */\nstatic size_t release_unused_segments(mstate m) {\n    size_t released = 0;\n    int nsegs = 0;\n    msegmentptr pred = &m->seg;\n    msegmentptr sp = pred->next;\n    while (sp != 0) {\n        char* base = sp->base;\n        size_t size = sp->size;\n        msegmentptr next = sp->next;\n        ++nsegs;\n        if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {\n            mchunkptr p = align_as_chunk(base);\n            size_t psize = chunksize(p);\n            /* Can unmap if first chunk holds entire segment and not pinned */\n            if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {\n                tchunkptr tp = (tchunkptr)p;\n                assert(segment_holds(sp, (char*)sp));\n                if (p == m->dv) {\n                    m->dv = 0;\n                    m->dvsize = 0;\n                }\n                else {\n                    unlink_large_chunk(m, tp);\n                }\n                if (CALL_MUNMAP(base, size) == 0) {\n                    released += size;\n                    m->footprint -= size;\n                    /* unlink obsoleted record */\n                    sp = pred;\n                    sp->next = next;\n                }\n                else { /* back out if cannot unmap */\n                    insert_large_chunk(m, tp, psize);\n                }\n            }\n        }\n        if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */\n            break;\n        pred = sp;\n        sp = next;\n    }\n    /* Reset check counter */\n    m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?\n                         (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);\n    return released;\n}\n\nstatic int sys_trim(mstate m, size_t pad) {\n    size_t released = 0;\n    ensure_initialization();\n    if (pad < MAX_REQUEST && is_initialized(m)) {\n        pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */\n        \n        if (m->topsize > pad) {\n            /* Shrink top space in granularity-size units, keeping at least one */\n            size_t unit = mparams.granularity;\n            size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -\n                            SIZE_T_ONE) * unit;\n            msegmentptr sp = segment_holding(m, (char*)m->top);\n            \n            if (!is_extern_segment(sp)) {\n                if (is_mmapped_segment(sp)) {\n                    if (HAVE_MMAP &&\n                        sp->size >= extra &&\n                        !has_segment_link(m, sp)) { /* can't shrink if pinned */\n                        size_t newsize = sp->size - extra;\n                        (void)newsize; /* placate people compiling -Wunused-variable */\n                        /* Prefer mremap, fall back to munmap */\n                        if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||\n                            (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {\n                            released = extra;\n                        }\n                    }\n                }\n                else if (HAVE_MORECORE) {\n#ifndef MORECORE_CANNOT_TRIM\n                    if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */\n                        extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;\n                    ACQUIRE_MALLOC_GLOBAL_LOCK();\n                    {\n                        /* Make sure end of memory is where we last set it. */\n                        char* old_br = (char*)(CALL_MORECORE(0));\n                        if (old_br == sp->base + sp->size) {\n                            char* rel_br = (char*)(CALL_MORECORE(-extra));\n                            char* new_br = (char*)(CALL_MORECORE(0));\n                            if (rel_br != CMFAIL && new_br < old_br)\n                                released = old_br - new_br;\n                        }\n                    }\n                    RELEASE_MALLOC_GLOBAL_LOCK();\n#endif\n                }\n            }\n            \n            if (released != 0) {\n                sp->size -= released;\n                m->footprint -= released;\n                init_top(m, m->top, m->topsize - released);\n                check_top_chunk(m, m->top);\n            }\n        }\n        \n        /* Unmap any unused mmapped segments */\n        if (HAVE_MMAP)\n            released += release_unused_segments(m);\n        \n        /* On failure, disable autotrim to avoid repeated failed future calls */\n        if (released == 0 && m->topsize > m->trim_check)\n            m->trim_check = MAX_SIZE_T;\n    }\n    \n    return (released != 0)? 1 : 0;\n}\n\n/* Consolidate and bin a chunk. Differs from exported versions\n of free mainly in that the chunk need not be marked as inuse.\n */\nstatic void dispose_chunk(mstate m, mchunkptr p, size_t psize) {\n    mchunkptr next = chunk_plus_offset(p, psize);\n    if (!pinuse(p)) {\n        mchunkptr prev;\n        size_t prevsize = p->prev_foot;\n        if (is_mmapped(p)) {\n            psize += prevsize + MMAP_FOOT_PAD;\n            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)\n                m->footprint -= psize;\n            return;\n        }\n        prev = chunk_minus_offset(p, prevsize);\n        psize += prevsize;\n        p = prev;\n        if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */\n            if (p != m->dv) {\n                unlink_chunk(m, p, prevsize);\n            }\n            else if ((next->head & INUSE_BITS) == INUSE_BITS) {\n                m->dvsize = psize;\n                set_free_with_pinuse(p, psize, next);\n                return;\n            }\n        }\n        else {\n            CORRUPTION_ERROR_ACTION(m);\n            return;\n        }\n    }\n    if (RTCHECK(ok_address(m, next))) {\n        if (!cinuse(next)) {  /* consolidate forward */\n            if (next == m->top) {\n                size_t tsize = m->topsize += psize;\n                m->top = p;\n                p->head = tsize | PINUSE_BIT;\n                if (p == m->dv) {\n                    m->dv = 0;\n                    m->dvsize = 0;\n                }\n                return;\n            }\n            else if (next == m->dv) {\n                size_t dsize = m->dvsize += psize;\n                m->dv = p;\n                set_size_and_pinuse_of_free_chunk(p, dsize);\n                return;\n            }\n            else {\n                size_t nsize = chunksize(next);\n                psize += nsize;\n                unlink_chunk(m, next, nsize);\n                set_size_and_pinuse_of_free_chunk(p, psize);\n                if (p == m->dv) {\n                    m->dvsize = psize;\n                    return;\n                }\n            }\n        }\n        else {\n            set_free_with_pinuse(p, psize, next);\n        }\n        insert_chunk(m, p, psize);\n    }\n    else {\n        CORRUPTION_ERROR_ACTION(m);\n    }\n}\n\n/* ---------------------------- malloc --------------------------- */\n\n/* allocate a large request from the best fitting chunk in a treebin */\nstatic void* tmalloc_large(mstate m, size_t nb) {\n    tchunkptr v = 0;\n    size_t rsize = -nb; /* Unsigned negation */\n    tchunkptr t;\n    bindex_t idx;\n    compute_tree_index(nb, idx);\n    if ((t = *treebin_at(m, idx)) != 0) {\n        /* Traverse tree for this bin looking for node with size == nb */\n        size_t sizebits = nb << leftshift_for_tree_index(idx);\n        tchunkptr rst = 0;  /* The deepest untaken right subtree */\n        for (;;) {\n            tchunkptr rt;\n            size_t trem = chunksize(t) - nb;\n            if (trem < rsize) {\n                v = t;\n                if ((rsize = trem) == 0)\n                    break;\n            }\n            rt = t->child[1];\n            t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];\n            if (rt != 0 && rt != t)\n                rst = rt;\n            if (t == 0) {\n                t = rst; /* set t to least subtree holding sizes > nb */\n                break;\n            }\n            sizebits <<= 1;\n        }\n    }\n    if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */\n        binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;\n        if (leftbits != 0) {\n            bindex_t i;\n            binmap_t leastbit = least_bit(leftbits);\n            compute_bit2idx(leastbit, i);\n            t = *treebin_at(m, i);\n        }\n    }\n    \n    while (t != 0) { /* find smallest of tree or subtree */\n        size_t trem = chunksize(t) - nb;\n        if (trem < rsize) {\n            rsize = trem;\n            v = t;\n        }\n        t = leftmost_child(t);\n    }\n    \n    /*  If dv is a better fit, return 0 so malloc will use it */\n    if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {\n        if (RTCHECK(ok_address(m, v))) { /* split */\n            mchunkptr r = chunk_plus_offset(v, nb);\n            assert(chunksize(v) == rsize + nb);\n            if (RTCHECK(ok_next(v, r))) {\n                unlink_large_chunk(m, v);\n                if (rsize < MIN_CHUNK_SIZE)\n                    set_inuse_and_pinuse(m, v, (rsize + nb));\n                else {\n                    set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n                    set_size_and_pinuse_of_free_chunk(r, rsize);\n                    insert_chunk(m, r, rsize);\n                }\n                return chunk2mem(v);\n            }\n        }\n        CORRUPTION_ERROR_ACTION(m);\n    }\n    return 0;\n}\n\n/* allocate a small request from the best fitting chunk in a treebin */\nstatic void* tmalloc_small(mstate m, size_t nb) {\n    tchunkptr t, v;\n    size_t rsize;\n    bindex_t i;\n    binmap_t leastbit = least_bit(m->treemap);\n    compute_bit2idx(leastbit, i);\n    v = t = *treebin_at(m, i);\n    rsize = chunksize(t) - nb;\n    \n    while ((t = leftmost_child(t)) != 0) {\n        size_t trem = chunksize(t) - nb;\n        if (trem < rsize) {\n            rsize = trem;\n            v = t;\n        }\n    }\n    \n    if (RTCHECK(ok_address(m, v))) {\n        mchunkptr r = chunk_plus_offset(v, nb);\n        assert(chunksize(v) == rsize + nb);\n        if (RTCHECK(ok_next(v, r))) {\n            unlink_large_chunk(m, v);\n            if (rsize < MIN_CHUNK_SIZE)\n                set_inuse_and_pinuse(m, v, (rsize + nb));\n            else {\n                set_size_and_pinuse_of_inuse_chunk(m, v, nb);\n                set_size_and_pinuse_of_free_chunk(r, rsize);\n                replace_dv(m, r, rsize);\n            }\n            return chunk2mem(v);\n        }\n    }\n    \n    CORRUPTION_ERROR_ACTION(m);\n    return 0;\n}\n\n#if !ONLY_MSPACES\n\nvoid* dlmalloc(size_t bytes) {\n    /*\n     Basic algorithm:\n     If a small request (< 256 bytes minus per-chunk overhead):\n     1. If one exists, use a remainderless chunk in associated smallbin.\n     (Remainderless means that there are too few excess bytes to\n     represent as a chunk.)\n     2. If it is big enough, use the dv chunk, which is normally the\n     chunk adjacent to the one used for the most recent small request.\n     3. If one exists, split the smallest available chunk in a bin,\n     saving remainder in dv.\n     4. If it is big enough, use the top chunk.\n     5. If available, get memory from system and use it\n     Otherwise, for a large request:\n     1. Find the smallest available binned chunk that fits, and use it\n     if it is better fitting than dv chunk, splitting if necessary.\n     2. If better fitting than any binned chunk, use the dv chunk.\n     3. If it is big enough, use the top chunk.\n     4. If request size >= mmap threshold, try to directly mmap this chunk.\n     5. If available, get memory from system and use it\n     \n     The ugly goto's here ensure that postaction occurs along all paths.\n     */\n    \n#if USE_LOCKS\n    ensure_initialization(); /* initialize in sys_alloc if not using locks */\n#endif\n    \n    if (!PREACTION(gm)) {\n        void* mem;\n        size_t nb;\n        if (bytes <= MAX_SMALL_REQUEST) {\n            bindex_t idx;\n            binmap_t smallbits;\n            nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);\n            idx = small_index(nb);\n            smallbits = gm->smallmap >> idx;\n            \n            if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */\n                mchunkptr b, p;\n                idx += ~smallbits & 1;       /* Uses next bin if idx empty */\n                b = smallbin_at(gm, idx);\n                p = b->fd;\n                assert(chunksize(p) == small_index2size(idx));\n                unlink_first_small_chunk(gm, b, p, idx);\n                set_inuse_and_pinuse(gm, p, small_index2size(idx));\n                mem = chunk2mem(p);\n                check_malloced_chunk(gm, mem, nb);\n                goto postaction;\n            }\n            \n            else if (nb > gm->dvsize) {\n                if (smallbits != 0) { /* Use chunk in next nonempty smallbin */\n                    mchunkptr b, p, r;\n                    size_t rsize;\n                    bindex_t i;\n                    binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));\n                    binmap_t leastbit = least_bit(leftbits);\n                    compute_bit2idx(leastbit, i);\n                    b = smallbin_at(gm, i);\n                    p = b->fd;\n                    assert(chunksize(p) == small_index2size(i));\n                    unlink_first_small_chunk(gm, b, p, i);\n                    rsize = small_index2size(i) - nb;\n                    /* Fit here cannot be remainderless if 4byte sizes */\n                    if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)\n                        set_inuse_and_pinuse(gm, p, small_index2size(i));\n                    else {\n                        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);\n                        r = chunk_plus_offset(p, nb);\n                        set_size_and_pinuse_of_free_chunk(r, rsize);\n                        replace_dv(gm, r, rsize);\n                    }\n                    mem = chunk2mem(p);\n                    check_malloced_chunk(gm, mem, nb);\n                    goto postaction;\n                }\n                \n                else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {\n                    check_malloced_chunk(gm, mem, nb);\n                    goto postaction;\n                }\n            }\n        }\n        else if (bytes >= MAX_REQUEST)\n            nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */\n        else {\n            nb = pad_request(bytes);\n            if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {\n                check_malloced_chunk(gm, mem, nb);\n                goto postaction;\n            }\n        }\n        \n        if (nb <= gm->dvsize) {\n            size_t rsize = gm->dvsize - nb;\n            mchunkptr p = gm->dv;\n            if (rsize >= MIN_CHUNK_SIZE) { /* split dv */\n                mchunkptr r = gm->dv = chunk_plus_offset(p, nb);\n                gm->dvsize = rsize;\n                set_size_and_pinuse_of_free_chunk(r, rsize);\n                set_size_and_pinuse_of_inuse_chunk(gm, p, nb);\n            }\n            else { /* exhaust dv */\n                size_t dvs = gm->dvsize;\n                gm->dvsize = 0;\n                gm->dv = 0;\n                set_inuse_and_pinuse(gm, p, dvs);\n            }\n            mem = chunk2mem(p);\n            check_malloced_chunk(gm, mem, nb);\n            goto postaction;\n        }\n        \n        else if (nb < gm->topsize) { /* Split top */\n            size_t rsize = gm->topsize -= nb;\n            mchunkptr p = gm->top;\n            mchunkptr r = gm->top = chunk_plus_offset(p, nb);\n            r->head = rsize | PINUSE_BIT;\n            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);\n            mem = chunk2mem(p);\n            check_top_chunk(gm, gm->top);\n            check_malloced_chunk(gm, mem, nb);\n            goto postaction;\n        }\n        \n        mem = sys_alloc(gm, nb);\n        \n    postaction:\n        POSTACTION(gm);\n#if __EMSCRIPTEN__\n        /* XXX Emscripten Tracing API. */\n        emscripten_trace_record_allocation(mem, bytes);\n#endif\n        return mem;\n    }\n    \n    return 0;\n}\n\n/* ---------------------------- free --------------------------- */\n\nvoid dlfree(void* mem) {\n    /*\n     Consolidate freed chunks with preceeding or succeeding bordering\n     free chunks, if they exist, and then place in a bin.  Intermixed\n     with special cases for top, dv, mmapped chunks, and usage errors.\n     */\n    \n    if (mem != 0) {\n#if __EMSCRIPTEN__\n        /* XXX Emscripten Tracing API. */\n        emscripten_trace_record_free(mem);\n#endif\n        mchunkptr p  = mem2chunk(mem);\n#if FOOTERS\n        mstate fm = get_mstate_for(p);\n        if (!ok_magic(fm)) {\n            USAGE_ERROR_ACTION(fm, p);\n            return;\n        }\n#else /* FOOTERS */\n#define fm gm\n#endif /* FOOTERS */\n        if (!PREACTION(fm)) {\n            check_inuse_chunk(fm, p);\n            if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {\n                size_t psize = chunksize(p);\n                mchunkptr next = chunk_plus_offset(p, psize);\n                if (!pinuse(p)) {\n                    size_t prevsize = p->prev_foot;\n                    if (is_mmapped(p)) {\n                        psize += prevsize + MMAP_FOOT_PAD;\n                        if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)\n                            fm->footprint -= psize;\n                        goto postaction;\n                    }\n                    else {\n                        mchunkptr prev = chunk_minus_offset(p, prevsize);\n                        psize += prevsize;\n                        p = prev;\n                        if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */\n                            if (p != fm->dv) {\n                                unlink_chunk(fm, p, prevsize);\n                            }\n                            else if ((next->head & INUSE_BITS) == INUSE_BITS) {\n                                fm->dvsize = psize;\n                                set_free_with_pinuse(p, psize, next);\n                                goto postaction;\n                            }\n                        }\n                        else\n                            goto erroraction;\n                    }\n                }\n                \n                if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {\n                    if (!cinuse(next)) {  /* consolidate forward */\n                        if (next == fm->top) {\n                            size_t tsize = fm->topsize += psize;\n                            fm->top = p;\n                            p->head = tsize | PINUSE_BIT;\n                            if (p == fm->dv) {\n                                fm->dv = 0;\n                                fm->dvsize = 0;\n                            }\n                            if (should_trim(fm, tsize))\n                                sys_trim(fm, 0);\n                            goto postaction;\n                        }\n                        else if (next == fm->dv) {\n                            size_t dsize = fm->dvsize += psize;\n                            fm->dv = p;\n                            set_size_and_pinuse_of_free_chunk(p, dsize);\n                            goto postaction;\n                        }\n                        else {\n                            size_t nsize = chunksize(next);\n                            psize += nsize;\n                            unlink_chunk(fm, next, nsize);\n                            set_size_and_pinuse_of_free_chunk(p, psize);\n                            if (p == fm->dv) {\n                                fm->dvsize = psize;\n                                goto postaction;\n                            }\n                        }\n                    }\n                    else\n                        set_free_with_pinuse(p, psize, next);\n                    \n                    if (is_small(psize)) {\n                        insert_small_chunk(fm, p, psize);\n                        check_free_chunk(fm, p);\n                    }\n                    else {\n                        tchunkptr tp = (tchunkptr)p;\n                        insert_large_chunk(fm, tp, psize);\n                        check_free_chunk(fm, p);\n                        if (--fm->release_checks == 0)\n                            release_unused_segments(fm);\n                    }\n                    goto postaction;\n                }\n            }\n        erroraction:\n            USAGE_ERROR_ACTION(fm, p);\n        postaction:\n            POSTACTION(fm);\n        }\n    }\n#if !FOOTERS\n#undef fm\n#endif /* FOOTERS */\n}\n\nvoid* dlcalloc(size_t n_elements, size_t elem_size) {\n    void* mem;\n    size_t req = 0;\n    if (n_elements != 0) {\n        req = n_elements * elem_size;\n        if (((n_elements | elem_size) & ~(size_t)0xffff) &&\n            (req / n_elements != elem_size))\n            req = MAX_SIZE_T; /* force downstream failure on overflow */\n    }\n    mem = dlmalloc(req);\n    if (mem != 0 && calloc_must_clear(mem2chunk(mem)))\n        memset(mem, 0, req);\n    return mem;\n}\n\n#endif /* !ONLY_MSPACES */\n\n/* ------------ Internal support for realloc, memalign, etc -------------- */\n\n/* Try to realloc; only in-place unless can_move true */\nstatic mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,\n                                   int can_move) {\n    mchunkptr newp = 0;\n    size_t oldsize = chunksize(p);\n    mchunkptr next = chunk_plus_offset(p, oldsize);\n    if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&\n                ok_next(p, next) && ok_pinuse(next))) {\n        if (is_mmapped(p)) {\n            newp = mmap_resize(m, p, nb, can_move);\n        }\n        else if (oldsize >= nb) {             /* already big enough */\n            size_t rsize = oldsize - nb;\n            if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */\n                mchunkptr r = chunk_plus_offset(p, nb);\n                set_inuse(m, p, nb);\n                set_inuse(m, r, rsize);\n                dispose_chunk(m, r, rsize);\n            }\n            newp = p;\n        }\n        else if (next == m->top) {  /* extend into top */\n            if (oldsize + m->topsize > nb) {\n                size_t newsize = oldsize + m->topsize;\n                size_t newtopsize = newsize - nb;\n                mchunkptr newtop = chunk_plus_offset(p, nb);\n                set_inuse(m, p, nb);\n                newtop->head = newtopsize |PINUSE_BIT;\n                m->top = newtop;\n                m->topsize = newtopsize;\n                newp = p;\n            }\n        }\n        else if (next == m->dv) { /* extend into dv */\n            size_t dvs = m->dvsize;\n            if (oldsize + dvs >= nb) {\n                size_t dsize = oldsize + dvs - nb;\n                if (dsize >= MIN_CHUNK_SIZE) {\n                    mchunkptr r = chunk_plus_offset(p, nb);\n                    mchunkptr n = chunk_plus_offset(r, dsize);\n                    set_inuse(m, p, nb);\n                    set_size_and_pinuse_of_free_chunk(r, dsize);\n                    clear_pinuse(n);\n                    m->dvsize = dsize;\n                    m->dv = r;\n                }\n                else { /* exhaust dv */\n                    size_t newsize = oldsize + dvs;\n                    set_inuse(m, p, newsize);\n                    m->dvsize = 0;\n                    m->dv = 0;\n                }\n                newp = p;\n            }\n        }\n        else if (!cinuse(next)) { /* extend into next free chunk */\n            size_t nextsize = chunksize(next);\n            if (oldsize + nextsize >= nb) {\n                size_t rsize = oldsize + nextsize - nb;\n                unlink_chunk(m, next, nextsize);\n                if (rsize < MIN_CHUNK_SIZE) {\n                    size_t newsize = oldsize + nextsize;\n                    set_inuse(m, p, newsize);\n                }\n                else {\n                    mchunkptr r = chunk_plus_offset(p, nb);\n                    set_inuse(m, p, nb);\n                    set_inuse(m, r, rsize);\n                    dispose_chunk(m, r, rsize);\n                }\n                newp = p;\n            }\n        }\n    }\n    else {\n        USAGE_ERROR_ACTION(m, chunk2mem(p));\n    }\n    return newp;\n}\n\nstatic void* internal_memalign(mstate m, size_t alignment, size_t bytes) {\n    void* mem = 0;\n    if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */\n        alignment = MIN_CHUNK_SIZE;\n    if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */\n        size_t a = MALLOC_ALIGNMENT << 1;\n        while (a < alignment) a <<= 1;\n        alignment = a;\n    }\n    if (bytes >= MAX_REQUEST - alignment) {\n        if (m != 0)  { /* Test isn't needed but avoids compiler warning */\n            MALLOC_FAILURE_ACTION;\n        }\n    }\n    else {\n        size_t nb = request2size(bytes);\n        size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;\n        mem = internal_malloc(m, req);\n        if (mem != 0) {\n            mchunkptr p = mem2chunk(mem);\n            if (PREACTION(m))\n                return 0;\n            if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */\n                /*\n                 Find an aligned spot inside chunk.  Since we need to give\n                 back leading space in a chunk of at least MIN_CHUNK_SIZE, if\n                 the first calculation places us at a spot with less than\n                 MIN_CHUNK_SIZE leader, we can move to the next aligned spot.\n                 We've allocated enough total room so that this is always\n                 possible.\n                 */\n                char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -\n                                                               SIZE_T_ONE)) &\n                                                     -alignment));\n                char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?\n                br : br+alignment;\n                mchunkptr newp = (mchunkptr)pos;\n                size_t leadsize = pos - (char*)(p);\n                size_t newsize = chunksize(p) - leadsize;\n                \n                if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */\n                    newp->prev_foot = p->prev_foot + leadsize;\n                    newp->head = newsize;\n                }\n                else { /* Otherwise, give back leader, use the rest */\n                    set_inuse(m, newp, newsize);\n                    set_inuse(m, p, leadsize);\n                    dispose_chunk(m, p, leadsize);\n                }\n                p = newp;\n            }\n            \n            /* Give back spare room at the end */\n            if (!is_mmapped(p)) {\n                size_t size = chunksize(p);\n                if (size > nb + MIN_CHUNK_SIZE) {\n                    size_t remainder_size = size - nb;\n                    mchunkptr remainder = chunk_plus_offset(p, nb);\n                    set_inuse(m, p, nb);\n                    set_inuse(m, remainder, remainder_size);\n                    dispose_chunk(m, remainder, remainder_size);\n                }\n            }\n            \n            mem = chunk2mem(p);\n            assert (chunksize(p) >= nb);\n            assert(((size_t)mem & (alignment - 1)) == 0);\n            check_inuse_chunk(m, p);\n            POSTACTION(m);\n        }\n    }\n    return mem;\n}\n\n/*\n Common support for independent_X routines, handling\n all of the combinations that can result.\n The opts arg has:\n bit 0 set if all elements are same size (using sizes[0])\n bit 1 set if elements should be zeroed\n */\nstatic void** ialloc(mstate m,\n                     size_t n_elements,\n                     size_t* sizes,\n                     int opts,\n                     void* chunks[]) {\n    \n    size_t    element_size;   /* chunksize of each element, if all same */\n    size_t    contents_size;  /* total size of elements */\n    size_t    array_size;     /* request size of pointer array */\n    void*     mem;            /* malloced aggregate space */\n    mchunkptr p;              /* corresponding chunk */\n    size_t    remainder_size; /* remaining bytes while splitting */\n    void**    marray;         /* either \"chunks\" or malloced ptr array */\n    mchunkptr array_chunk;    /* chunk for malloced ptr array */\n    flag_t    was_enabled;    /* to disable mmap */\n    size_t    size;\n    size_t    i;\n    \n    ensure_initialization();\n    /* compute array length, if needed */\n    if (chunks != 0) {\n        if (n_elements == 0)\n            return chunks; /* nothing to do */\n        marray = chunks;\n        array_size = 0;\n    }\n    else {\n        /* if empty req, must still return chunk representing empty array */\n        if (n_elements == 0)\n            return (void**)internal_malloc(m, 0);\n        marray = 0;\n        array_size = request2size(n_elements * (sizeof(void*)));\n    }\n    \n    /* compute total element size */\n    if (opts & 0x1) { /* all-same-size */\n        element_size = request2size(*sizes);\n        contents_size = n_elements * element_size;\n    }\n    else { /* add up all the sizes */\n        element_size = 0;\n        contents_size = 0;\n        for (i = 0; i != n_elements; ++i)\n            contents_size += request2size(sizes[i]);\n    }\n    \n    size = contents_size + array_size;\n    \n    /*\n     Allocate the aggregate chunk.  First disable direct-mmapping so\n     malloc won't use it, since we would not be able to later\n     free/realloc space internal to a segregated mmap region.\n     */\n    was_enabled = use_mmap(m);\n    disable_mmap(m);\n    mem = internal_malloc(m, size - CHUNK_OVERHEAD);\n    if (was_enabled)\n        enable_mmap(m);\n    if (mem == 0)\n        return 0;\n    \n    if (PREACTION(m)) return 0;\n    p = mem2chunk(mem);\n    remainder_size = chunksize(p);\n    \n    assert(!is_mmapped(p));\n    \n    if (opts & 0x2) {       /* optionally clear the elements */\n        memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);\n    }\n    \n    /* If not provided, allocate the pointer array as final part of chunk */\n    if (marray == 0) {\n        size_t  array_chunk_size;\n        array_chunk = chunk_plus_offset(p, contents_size);\n        array_chunk_size = remainder_size - contents_size;\n        marray = (void**) (chunk2mem(array_chunk));\n        set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);\n        remainder_size = contents_size;\n    }\n    \n    /* split out elements */\n    for (i = 0; ; ++i) {\n        marray[i] = chunk2mem(p);\n        if (i != n_elements-1) {\n            if (element_size != 0)\n                size = element_size;\n            else\n                size = request2size(sizes[i]);\n            remainder_size -= size;\n            set_size_and_pinuse_of_inuse_chunk(m, p, size);\n            p = chunk_plus_offset(p, size);\n        }\n        else { /* the final element absorbs any overallocation slop */\n            set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);\n            break;\n        }\n    }\n    \n#if DEBUG\n    if (marray != chunks) {\n        /* final element must have exactly exhausted chunk */\n        if (element_size != 0) {\n            assert(remainder_size == element_size);\n        }\n        else {\n            assert(remainder_size == request2size(sizes[i]));\n        }\n        check_inuse_chunk(m, mem2chunk(marray));\n    }\n    for (i = 0; i != n_elements; ++i)\n        check_inuse_chunk(m, mem2chunk(marray[i]));\n    \n#endif /* DEBUG */\n    \n    POSTACTION(m);\n    return marray;\n}\n\n/* Try to free all pointers in the given array.\n Note: this could be made faster, by delaying consolidation,\n at the price of disabling some user integrity checks, We\n still optimize some consolidations by combining adjacent\n chunks before freeing, which will occur often if allocated\n with ialloc or the array is sorted.\n */\nstatic size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {\n    size_t unfreed = 0;\n    if (!PREACTION(m)) {\n        void** a;\n        void** fence = &(array[nelem]);\n        for (a = array; a != fence; ++a) {\n            void* mem = *a;\n            if (mem != 0) {\n                mchunkptr p = mem2chunk(mem);\n                size_t psize = chunksize(p);\n#if FOOTERS\n                if (get_mstate_for(p) != m) {\n                    ++unfreed;\n                    continue;\n                }\n#endif\n                check_inuse_chunk(m, p);\n                *a = 0;\n                if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {\n                    void ** b = a + 1; /* try to merge with next chunk */\n                    mchunkptr next = next_chunk(p);\n                    if (b != fence && *b == chunk2mem(next)) {\n                        size_t newsize = chunksize(next) + psize;\n                        set_inuse(m, p, newsize);\n                        *b = chunk2mem(p);\n                    }\n                    else\n                        dispose_chunk(m, p, psize);\n                }\n                else {\n                    CORRUPTION_ERROR_ACTION(m);\n                    break;\n                }\n            }\n        }\n        if (should_trim(m, m->topsize))\n            sys_trim(m, 0);\n        POSTACTION(m);\n    }\n    return unfreed;\n}\n\n/* Traversal */\n#if MALLOC_INSPECT_ALL\nstatic void internal_inspect_all(mstate m,\n                                 void(*handler)(void *start,\n                                                void *end,\n                                                size_t used_bytes,\n                                                void* callback_arg),\n                                 void* arg) {\n    if (is_initialized(m)) {\n        mchunkptr top = m->top;\n        msegmentptr s;\n        for (s = &m->seg; s != 0; s = s->next) {\n            mchunkptr q = align_as_chunk(s->base);\n            while (segment_holds(s, q) && q->head != FENCEPOST_HEAD) {\n                mchunkptr next = next_chunk(q);\n                size_t sz = chunksize(q);\n                size_t used;\n                void* start;\n                if (is_inuse(q)) {\n                    used = sz - CHUNK_OVERHEAD; /* must not be mmapped */\n                    start = chunk2mem(q);\n                }\n                else {\n                    used = 0;\n                    if (is_small(sz)) {     /* offset by possible bookkeeping */\n                        start = (void*)((char*)q + sizeof(struct malloc_chunk));\n                    }\n                    else {\n                        start = (void*)((char*)q + sizeof(struct malloc_tree_chunk));\n                    }\n                }\n                if (start < (void*)next)  /* skip if all space is bookkeeping */\n                    handler(start, next, used, arg);\n                if (q == top)\n                    break;\n                q = next;\n            }\n        }\n    }\n}\n#endif /* MALLOC_INSPECT_ALL */\n\n/* ------------------ Exported realloc, memalign, etc -------------------- */\n\n#if !ONLY_MSPACES\n\nvoid* dlrealloc(void* oldmem, size_t bytes) {\n    void* mem = 0;\n    if (oldmem == 0) {\n        mem = dlmalloc(bytes);\n    }\n    else if (bytes >= MAX_REQUEST) {\n        MALLOC_FAILURE_ACTION;\n    }\n#ifdef REALLOC_ZERO_BYTES_FREES\n    else if (bytes == 0) {\n        dlfree(oldmem);\n    }\n#endif /* REALLOC_ZERO_BYTES_FREES */\n    else {\n        size_t nb = request2size(bytes);\n        mchunkptr oldp = mem2chunk(oldmem);\n#if ! FOOTERS\n        mstate m = gm;\n#else /* FOOTERS */\n        mstate m = get_mstate_for(oldp);\n        if (!ok_magic(m)) {\n            USAGE_ERROR_ACTION(m, oldmem);\n            return 0;\n        }\n#endif /* FOOTERS */\n        if (!PREACTION(m)) {\n            mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);\n            POSTACTION(m);\n            if (newp != 0) {\n                check_inuse_chunk(m, newp);\n                mem = chunk2mem(newp);\n#if __EMSCRIPTEN__\n                /* XXX Emscripten Tracing API. */\n                emscripten_trace_record_reallocation(oldmem, mem, bytes);\n#endif\n            }\n            else {\n                mem = internal_malloc(m, bytes);\n                if (mem != 0) {\n                    size_t oc = chunksize(oldp) - overhead_for(oldp);\n                    memcpy(mem, oldmem, (oc < bytes)? oc : bytes);\n                    internal_free(m, oldmem);\n                }\n            }\n        }\n    }\n    return mem;\n}\n\nvoid* dlrealloc_in_place(void* oldmem, size_t bytes) {\n    void* mem = 0;\n    if (oldmem != 0) {\n        if (bytes >= MAX_REQUEST) {\n            MALLOC_FAILURE_ACTION;\n        }\n        else {\n            size_t nb = request2size(bytes);\n            mchunkptr oldp = mem2chunk(oldmem);\n#if ! FOOTERS\n            mstate m = gm;\n#else /* FOOTERS */\n            mstate m = get_mstate_for(oldp);\n            if (!ok_magic(m)) {\n                USAGE_ERROR_ACTION(m, oldmem);\n                return 0;\n            }\n#endif /* FOOTERS */\n            if (!PREACTION(m)) {\n                mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);\n                POSTACTION(m);\n                if (newp == oldp) {\n                    check_inuse_chunk(m, newp);\n                    mem = oldmem;\n                }\n            }\n        }\n    }\n#if __EMSCRIPTEN__\n    /* XXX Emscripten Tracing API. */\n    emscripten_trace_record_reallocation(oldmem, mem, bytes);\n#endif\n    return mem;\n}\n\nvoid* dlmemalign(size_t alignment, size_t bytes) {\n    if (alignment <= MALLOC_ALIGNMENT) {\n        return dlmalloc(bytes);\n    }\n    return internal_memalign(gm, alignment, bytes);\n}\n\nint dlposix_memalign(void** pp, size_t alignment, size_t bytes) {\n    void* mem = 0;\n    if (alignment == MALLOC_ALIGNMENT)\n        mem = dlmalloc(bytes);\n    else {\n        size_t d = alignment / sizeof(void*);\n        size_t r = alignment % sizeof(void*);\n        if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)\n            return EINVAL;\n        else if (bytes <= MAX_REQUEST - alignment) {\n            if (alignment <  MIN_CHUNK_SIZE)\n                alignment = MIN_CHUNK_SIZE;\n            mem = internal_memalign(gm, alignment, bytes);\n        }\n    }\n    if (mem == 0)\n        return ENOMEM;\n    else {\n        *pp = mem;\n        return 0;\n    }\n}\n\nvoid* dlvalloc(size_t bytes) {\n    size_t pagesz;\n    ensure_initialization();\n    pagesz = mparams.page_size;\n    return dlmemalign(pagesz, bytes);\n}\n\nvoid* dlpvalloc(size_t bytes) {\n    size_t pagesz;\n    ensure_initialization();\n    pagesz = mparams.page_size;\n    return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));\n}\n\nvoid** dlindependent_calloc(size_t n_elements, size_t elem_size,\n                            void* chunks[]) {\n    size_t sz = elem_size; /* serves as 1-element array */\n    return ialloc(gm, n_elements, &sz, 3, chunks);\n}\n\nvoid** dlindependent_comalloc(size_t n_elements, size_t sizes[],\n                              void* chunks[]) {\n    return ialloc(gm, n_elements, sizes, 0, chunks);\n}\n\nsize_t dlbulk_free(void* array[], size_t nelem) {\n    return internal_bulk_free(gm, array, nelem);\n}\n\n#if MALLOC_INSPECT_ALL\nvoid dlmalloc_inspect_all(void(*handler)(void *start,\n                                         void *end,\n                                         size_t used_bytes,\n                                         void* callback_arg),\n                          void* arg) {\n    ensure_initialization();\n    if (!PREACTION(gm)) {\n        internal_inspect_all(gm, handler, arg);\n        POSTACTION(gm);\n    }\n}\n#endif /* MALLOC_INSPECT_ALL */\n\nint dlmalloc_trim(size_t pad) {\n    int result = 0;\n    ensure_initialization();\n    if (!PREACTION(gm)) {\n        result = sys_trim(gm, pad);\n        POSTACTION(gm);\n    }\n    return result;\n}\n\nsize_t dlmalloc_footprint(void) {\n    return gm->footprint;\n}\n\nsize_t dlmalloc_max_footprint(void) {\n    return gm->max_footprint;\n}\n\nsize_t dlmalloc_footprint_limit(void) {\n    size_t maf = gm->footprint_limit;\n    return maf == 0 ? MAX_SIZE_T : maf;\n}\n\nsize_t dlmalloc_set_footprint_limit(size_t bytes) {\n    size_t result;  /* invert sense of 0 */\n    if (bytes == 0)\n        result = granularity_align(1); /* Use minimal size */\n    if (bytes == MAX_SIZE_T)\n        result = 0;                    /* disable */\n    else\n        result = granularity_align(bytes);\n    return gm->footprint_limit = result;\n}\n\n#if !NO_MALLINFO\nstruct mallinfo dlmallinfo(void) {\n    return internal_mallinfo(gm);\n}\n#endif /* NO_MALLINFO */\n\n#if !NO_MALLOC_STATS\nvoid dlmalloc_stats() {\n    internal_malloc_stats(gm);\n}\n#endif /* NO_MALLOC_STATS */\n\nint dlmallopt(int param_number, int value) {\n    return change_mparam(param_number, value);\n}\n\nsize_t dlmalloc_usable_size(void* mem) {\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n        if (is_inuse(p))\n            return chunksize(p) - overhead_for(p);\n    }\n    return 0;\n}\n\n#endif /* !ONLY_MSPACES */\n\n/* ----------------------------- user mspaces ---------------------------- */\n\n#if MSPACES\n\nstatic mstate init_user_mstate(char* tbase, size_t tsize) {\n    size_t msize = pad_request(sizeof(struct malloc_state));\n    mchunkptr mn;\n    mchunkptr msp = align_as_chunk(tbase);\n    mstate m = (mstate)(chunk2mem(msp));\n    memset(m, 0, msize);\n    (void)INITIAL_LOCK(&m->mutex);\n    msp->head = (msize|INUSE_BITS);\n    m->seg.base = m->least_addr = tbase;\n    m->seg.size = m->footprint = m->max_footprint = tsize;\n    m->magic = mparams.magic;\n    m->release_checks = MAX_RELEASE_CHECK_RATE;\n    m->mflags = mparams.default_mflags;\n    m->extp = 0;\n    m->exts = 0;\n    disable_contiguous(m);\n    init_bins(m);\n    mn = next_chunk(mem2chunk(m));\n    init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);\n    check_top_chunk(m, m->top);\n    return m;\n}\n\nmspace create_mspace(size_t capacity, int locked) {\n    mstate m = 0;\n    size_t msize;\n    ensure_initialization();\n    msize = pad_request(sizeof(struct malloc_state));\n    if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {\n        size_t rs = ((capacity == 0)? mparams.granularity :\n                     (capacity + TOP_FOOT_SIZE + msize));\n        size_t tsize = granularity_align(rs);\n        char* tbase = (char*)(CALL_MMAP(tsize));\n        if (tbase != CMFAIL) {\n            m = init_user_mstate(tbase, tsize);\n            m->seg.sflags = USE_MMAP_BIT;\n            set_lock(m, locked);\n        }\n    }\n    return (mspace)m;\n}\n\nmspace create_mspace_with_base(void* base, size_t capacity, int locked) {\n    mstate m = 0;\n    size_t msize;\n    ensure_initialization();\n    msize = pad_request(sizeof(struct malloc_state));\n    if (capacity > msize + TOP_FOOT_SIZE &&\n        capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {\n        m = init_user_mstate((char*)base, capacity);\n        m->seg.sflags = EXTERN_BIT;\n        set_lock(m, locked);\n    }\n    return (mspace)m;\n}\n\nint mspace_track_large_chunks(mspace msp, int enable) {\n    int ret = 0;\n    mstate ms = (mstate)msp;\n    if (!PREACTION(ms)) {\n        if (!use_mmap(ms)) {\n            ret = 1;\n        }\n        if (!enable) {\n            enable_mmap(ms);\n        } else {\n            disable_mmap(ms);\n        }\n        POSTACTION(ms);\n    }\n    return ret;\n}\n\nsize_t destroy_mspace(mspace msp) {\n    size_t freed = 0;\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        msegmentptr sp = &ms->seg;\n        (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */\n        while (sp != 0) {\n            char* base = sp->base;\n            size_t size = sp->size;\n            flag_t flag = sp->sflags;\n            (void)base; /* placate people compiling -Wunused-variable */\n            sp = sp->next;\n            if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&\n                CALL_MUNMAP(base, size) == 0)\n                freed += size;\n        }\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return freed;\n}\n\n/*\n mspace versions of routines are near-clones of the global\n versions. This is not so nice but better than the alternatives.\n */\n\nvoid* mspace_malloc(mspace msp, size_t bytes) {\n    mstate ms = (mstate)msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms,ms);\n        return 0;\n    }\n    if (!PREACTION(ms)) {\n        void* mem;\n        size_t nb;\n        if (bytes <= MAX_SMALL_REQUEST) {\n            bindex_t idx;\n            binmap_t smallbits;\n            nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);\n            idx = small_index(nb);\n            smallbits = ms->smallmap >> idx;\n            \n            if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */\n                mchunkptr b, p;\n                idx += ~smallbits & 1;       /* Uses next bin if idx empty */\n                b = smallbin_at(ms, idx);\n                p = b->fd;\n                assert(chunksize(p) == small_index2size(idx));\n                unlink_first_small_chunk(ms, b, p, idx);\n                set_inuse_and_pinuse(ms, p, small_index2size(idx));\n                mem = chunk2mem(p);\n                check_malloced_chunk(ms, mem, nb);\n                goto postaction;\n            }\n            \n            else if (nb > ms->dvsize) {\n                if (smallbits != 0) { /* Use chunk in next nonempty smallbin */\n                    mchunkptr b, p, r;\n                    size_t rsize;\n                    bindex_t i;\n                    binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));\n                    binmap_t leastbit = least_bit(leftbits);\n                    compute_bit2idx(leastbit, i);\n                    b = smallbin_at(ms, i);\n                    p = b->fd;\n                    assert(chunksize(p) == small_index2size(i));\n                    unlink_first_small_chunk(ms, b, p, i);\n                    rsize = small_index2size(i) - nb;\n                    /* Fit here cannot be remainderless if 4byte sizes */\n                    if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)\n                        set_inuse_and_pinuse(ms, p, small_index2size(i));\n                    else {\n                        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n                        r = chunk_plus_offset(p, nb);\n                        set_size_and_pinuse_of_free_chunk(r, rsize);\n                        replace_dv(ms, r, rsize);\n                    }\n                    mem = chunk2mem(p);\n                    check_malloced_chunk(ms, mem, nb);\n                    goto postaction;\n                }\n                \n                else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {\n                    check_malloced_chunk(ms, mem, nb);\n                    goto postaction;\n                }\n            }\n        }\n        else if (bytes >= MAX_REQUEST)\n            nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */\n        else {\n            nb = pad_request(bytes);\n            if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {\n                check_malloced_chunk(ms, mem, nb);\n                goto postaction;\n            }\n        }\n        \n        if (nb <= ms->dvsize) {\n            size_t rsize = ms->dvsize - nb;\n            mchunkptr p = ms->dv;\n            if (rsize >= MIN_CHUNK_SIZE) { /* split dv */\n                mchunkptr r = ms->dv = chunk_plus_offset(p, nb);\n                ms->dvsize = rsize;\n                set_size_and_pinuse_of_free_chunk(r, rsize);\n                set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n            }\n            else { /* exhaust dv */\n                size_t dvs = ms->dvsize;\n                ms->dvsize = 0;\n                ms->dv = 0;\n                set_inuse_and_pinuse(ms, p, dvs);\n            }\n            mem = chunk2mem(p);\n            check_malloced_chunk(ms, mem, nb);\n            goto postaction;\n        }\n        \n        else if (nb < ms->topsize) { /* Split top */\n            size_t rsize = ms->topsize -= nb;\n            mchunkptr p = ms->top;\n            mchunkptr r = ms->top = chunk_plus_offset(p, nb);\n            r->head = rsize | PINUSE_BIT;\n            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);\n            mem = chunk2mem(p);\n            check_top_chunk(ms, ms->top);\n            check_malloced_chunk(ms, mem, nb);\n            goto postaction;\n        }\n        \n        mem = sys_alloc(ms, nb);\n        \n    postaction:\n        POSTACTION(ms);\n        return mem;\n    }\n    \n    return 0;\n}\n\nvoid mspace_free(mspace msp, void* mem) {\n    if (mem != 0) {\n        mchunkptr p  = mem2chunk(mem);\n#if FOOTERS\n        mstate fm = get_mstate_for(p);\n        (void)msp; /* placate people compiling -Wunused */\n#else /* FOOTERS */\n        mstate fm = (mstate)msp;\n#endif /* FOOTERS */\n        if (!ok_magic(fm)) {\n            USAGE_ERROR_ACTION(fm, p);\n            return;\n        }\n        if (!PREACTION(fm)) {\n            check_inuse_chunk(fm, p);\n            if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {\n                size_t psize = chunksize(p);\n                mchunkptr next = chunk_plus_offset(p, psize);\n                if (!pinuse(p)) {\n                    size_t prevsize = p->prev_foot;\n                    if (is_mmapped(p)) {\n                        psize += prevsize + MMAP_FOOT_PAD;\n                        if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)\n                            fm->footprint -= psize;\n                        goto postaction;\n                    }\n                    else {\n                        mchunkptr prev = chunk_minus_offset(p, prevsize);\n                        psize += prevsize;\n                        p = prev;\n                        if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */\n                            if (p != fm->dv) {\n                                unlink_chunk(fm, p, prevsize);\n                            }\n                            else if ((next->head & INUSE_BITS) == INUSE_BITS) {\n                                fm->dvsize = psize;\n                                set_free_with_pinuse(p, psize, next);\n                                goto postaction;\n                            }\n                        }\n                        else\n                            goto erroraction;\n                    }\n                }\n                \n                if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {\n                    if (!cinuse(next)) {  /* consolidate forward */\n                        if (next == fm->top) {\n                            size_t tsize = fm->topsize += psize;\n                            fm->top = p;\n                            p->head = tsize | PINUSE_BIT;\n                            if (p == fm->dv) {\n                                fm->dv = 0;\n                                fm->dvsize = 0;\n                            }\n                            if (should_trim(fm, tsize))\n                                sys_trim(fm, 0);\n                            goto postaction;\n                        }\n                        else if (next == fm->dv) {\n                            size_t dsize = fm->dvsize += psize;\n                            fm->dv = p;\n                            set_size_and_pinuse_of_free_chunk(p, dsize);\n                            goto postaction;\n                        }\n                        else {\n                            size_t nsize = chunksize(next);\n                            psize += nsize;\n                            unlink_chunk(fm, next, nsize);\n                            set_size_and_pinuse_of_free_chunk(p, psize);\n                            if (p == fm->dv) {\n                                fm->dvsize = psize;\n                                goto postaction;\n                            }\n                        }\n                    }\n                    else\n                        set_free_with_pinuse(p, psize, next);\n                    \n                    if (is_small(psize)) {\n                        insert_small_chunk(fm, p, psize);\n                        check_free_chunk(fm, p);\n                    }\n                    else {\n                        tchunkptr tp = (tchunkptr)p;\n                        insert_large_chunk(fm, tp, psize);\n                        check_free_chunk(fm, p);\n                        if (--fm->release_checks == 0)\n                            release_unused_segments(fm);\n                    }\n                    goto postaction;\n                }\n            }\n        erroraction:\n            USAGE_ERROR_ACTION(fm, p);\n        postaction:\n            POSTACTION(fm);\n        }\n    }\n}\n\nvoid* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {\n    void* mem;\n    size_t req = 0;\n    mstate ms = (mstate)msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms,ms);\n        return 0;\n    }\n    if (n_elements != 0) {\n        req = n_elements * elem_size;\n        if (((n_elements | elem_size) & ~(size_t)0xffff) &&\n            (req / n_elements != elem_size))\n            req = MAX_SIZE_T; /* force downstream failure on overflow */\n    }\n    mem = internal_malloc(ms, req);\n    if (mem != 0 && calloc_must_clear(mem2chunk(mem)))\n        memset(mem, 0, req);\n    return mem;\n}\n\nvoid* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {\n    void* mem = 0;\n    if (oldmem == 0) {\n        mem = mspace_malloc(msp, bytes);\n    }\n    else if (bytes >= MAX_REQUEST) {\n        MALLOC_FAILURE_ACTION;\n    }\n#ifdef REALLOC_ZERO_BYTES_FREES\n    else if (bytes == 0) {\n        mspace_free(msp, oldmem);\n    }\n#endif /* REALLOC_ZERO_BYTES_FREES */\n    else {\n        size_t nb = request2size(bytes);\n        mchunkptr oldp = mem2chunk(oldmem);\n#if ! FOOTERS\n        mstate m = (mstate)msp;\n#else /* FOOTERS */\n        mstate m = get_mstate_for(oldp);\n        if (!ok_magic(m)) {\n            USAGE_ERROR_ACTION(m, oldmem);\n            return 0;\n        }\n#endif /* FOOTERS */\n        if (!PREACTION(m)) {\n            mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);\n            POSTACTION(m);\n            if (newp != 0) {\n                check_inuse_chunk(m, newp);\n                mem = chunk2mem(newp);\n            }\n            else {\n                mem = mspace_malloc(m, bytes);\n                if (mem != 0) {\n                    size_t oc = chunksize(oldp) - overhead_for(oldp);\n                    memcpy(mem, oldmem, (oc < bytes)? oc : bytes);\n                    mspace_free(m, oldmem);\n                }\n            }\n        }\n    }\n    return mem;\n}\n\nvoid* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {\n    void* mem = 0;\n    if (oldmem != 0) {\n        if (bytes >= MAX_REQUEST) {\n            MALLOC_FAILURE_ACTION;\n        }\n        else {\n            size_t nb = request2size(bytes);\n            mchunkptr oldp = mem2chunk(oldmem);\n#if ! FOOTERS\n            mstate m = (mstate)msp;\n#else /* FOOTERS */\n            mstate m = get_mstate_for(oldp);\n            (void)msp; /* placate people compiling -Wunused */\n            if (!ok_magic(m)) {\n                USAGE_ERROR_ACTION(m, oldmem);\n                return 0;\n            }\n#endif /* FOOTERS */\n            if (!PREACTION(m)) {\n                mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);\n                POSTACTION(m);\n                if (newp == oldp) {\n                    check_inuse_chunk(m, newp);\n                    mem = oldmem;\n                }\n            }\n        }\n    }\n    return mem;\n}\n\nvoid* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {\n    mstate ms = (mstate)msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms,ms);\n        return 0;\n    }\n    if (alignment <= MALLOC_ALIGNMENT)\n        return mspace_malloc(msp, bytes);\n    return internal_memalign(ms, alignment, bytes);\n}\n\nvoid** mspace_independent_calloc(mspace msp, size_t n_elements,\n                                 size_t elem_size, void* chunks[]) {\n    size_t sz = elem_size; /* serves as 1-element array */\n    mstate ms = (mstate)msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms,ms);\n        return 0;\n    }\n    return ialloc(ms, n_elements, &sz, 3, chunks);\n}\n\nvoid** mspace_independent_comalloc(mspace msp, size_t n_elements,\n                                   size_t sizes[], void* chunks[]) {\n    mstate ms = (mstate)msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms,ms);\n        return 0;\n    }\n    return ialloc(ms, n_elements, sizes, 0, chunks);\n}\n\nsize_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {\n    return internal_bulk_free((mstate)msp, array, nelem);\n}\n\n#if MALLOC_INSPECT_ALL\nvoid mspace_inspect_all(mspace msp,\n                        void(*handler)(void *start,\n                                       void *end,\n                                       size_t used_bytes,\n                                       void* callback_arg),\n                        void* arg) {\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        if (!PREACTION(ms)) {\n            internal_inspect_all(ms, handler, arg);\n            POSTACTION(ms);\n        }\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n}\n#endif /* MALLOC_INSPECT_ALL */\n\nint mspace_trim(mspace msp, size_t pad) {\n    int result = 0;\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        if (!PREACTION(ms)) {\n            result = sys_trim(ms, pad);\n            POSTACTION(ms);\n        }\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return result;\n}\n\n#if !NO_MALLOC_STATS\nvoid mspace_malloc_stats(mspace msp) {\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        internal_malloc_stats(ms);\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n}\n#endif /* NO_MALLOC_STATS */\n\nsize_t mspace_footprint(mspace msp) {\n    size_t result = 0;\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        result = ms->footprint;\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return result;\n}\n\nsize_t mspace_max_footprint(mspace msp) {\n    size_t result = 0;\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        result = ms->max_footprint;\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return result;\n}\n\nsize_t mspace_footprint_limit(mspace msp) {\n    size_t result = 0;\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        size_t maf = ms->footprint_limit;\n        result = (maf == 0) ? MAX_SIZE_T : maf;\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return result;\n}\n\nsize_t mspace_set_footprint_limit(mspace msp, size_t bytes) {\n    size_t result = 0;\n    mstate ms = (mstate)msp;\n    if (ok_magic(ms)) {\n        if (bytes == 0)\n            result = granularity_align(1); /* Use minimal size */\n        if (bytes == MAX_SIZE_T)\n            result = 0;                    /* disable */\n        else\n            result = granularity_align(bytes);\n        ms->footprint_limit = result;\n    }\n    else {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return result;\n}\n\n#if !NO_MALLINFO\nstruct mallinfo mspace_mallinfo(mspace msp) {\n    mstate ms = (mstate)msp;\n    if (!ok_magic(ms)) {\n        USAGE_ERROR_ACTION(ms,ms);\n    }\n    return internal_mallinfo(ms);\n}\n#endif /* NO_MALLINFO */\n\nsize_t mspace_usable_size(const void* mem) {\n    if (mem != 0) {\n        mchunkptr p = mem2chunk(mem);\n        if (is_inuse(p))\n            return chunksize(p) - overhead_for(p);\n    }\n    return 0;\n}\n\nint mspace_mallopt(int param_number, int value) {\n    return change_mparam(param_number, value);\n}\n\n#endif /* MSPACES */\n\n// Export malloc and free as duplicate names emscripten_builtin_malloc and\n// emscripten_builtin_free so that applications can replace malloc and free\n// in their code, and make those replacements refer to the original dlmalloc\n// and dlfree from this file.\n// This allows an easy mechanism for hooking into memory allocation.\n#if defined(__EMSCRIPTEN__) && !ONLY_MSPACES\nextern __typeof(malloc) emscripten_builtin_malloc __attribute__((alias(\"dlmalloc\")));\nextern __typeof(realloc) emscripten_builtin_realloc __attribute__((alias(\"dlrealloc\")));\nextern __typeof(calloc) emscripten_builtin_calloc __attribute__((alias(\"dlcalloc\")));\nextern __typeof(free) emscripten_builtin_free __attribute__((alias(\"dlfree\")));\nextern __typeof(memalign) emscripten_builtin_memalign __attribute__((alias(\"dlmemalign\")));\n#endif\n\n/* -------------------- Alternative MORECORE functions ------------------- */\n\n/*\n Guidelines for creating a custom version of MORECORE:\n \n * For best performance, MORECORE should allocate in multiples of pagesize.\n * MORECORE may allocate more memory than requested. (Or even less,\n but this will usually result in a malloc failure.)\n * MORECORE must not allocate memory when given argument zero, but\n instead return one past the end address of memory from previous\n nonzero call.\n * For best performance, consecutive calls to MORECORE with positive\n arguments should return increasing addresses, indicating that\n space has been contiguously extended.\n * Even though consecutive calls to MORECORE need not return contiguous\n addresses, it must be OK for malloc'ed chunks to span multiple\n regions in those cases where they do happen to be contiguous.\n * MORECORE need not handle negative arguments -- it may instead\n just return MFAIL when given negative arguments.\n Negative arguments are always multiples of pagesize. MORECORE\n must not misinterpret negative args as large positive unsigned\n args unless UNSIGNED_MORECORE is defined. You can suppress all such calls\n from even occurring by defining MORECORE_CANNOT_TRIM,\n \n As an example alternative MORECORE, here is a custom allocator\n kindly contributed for pre-OSX macOS.  It uses virtually but not\n necessarily physically contiguous non-paged memory (locked in,\n present and won't get swapped out).  You can use it by uncommenting\n this section, adding some #includes, and setting up the appropriate\n defines above:\n \n #define MORECORE osMoreCore\n \n There is also a shutdown routine that should somehow be called for\n cleanup upon program exit.\n \n #define MAX_POOL_ENTRIES 100\n #define MINIMUM_MORECORE_SIZE  (64 * 1024U)\n static int next_os_pool;\n void *our_os_pools[MAX_POOL_ENTRIES];\n \n void *osMoreCore(int size)\n {\n void *ptr = 0;\n static void *sbrk_top = 0;\n \n if (size > 0)\n {\n if (size < MINIMUM_MORECORE_SIZE)\n size = MINIMUM_MORECORE_SIZE;\n if (CurrentExecutionLevel() == kTaskLevel)\n ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);\n if (ptr == 0)\n {\n return (void *) MFAIL;\n }\n // save ptrs so they can be freed during cleanup\n our_os_pools[next_os_pool] = ptr;\n next_os_pool++;\n ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);\n sbrk_top = (char *) ptr + size;\n return ptr;\n }\n else if (size < 0)\n {\n // we don't currently support shrink behavior\n return (void *) MFAIL;\n }\n else\n {\n return sbrk_top;\n }\n }\n \n // cleanup any allocated memory pools\n // called as last thing before shutting down driver\n \n void osCleanupMem(void)\n {\n void **ptr;\n \n for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)\n if (*ptr)\n {\n PoolDeallocate(*ptr);\n *ptr = 0;\n }\n }\n \n */\n\n\n/* -----------------------------------------------------------------------\n History:\n v2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea\n * fix bad comparison in dlposix_memalign\n * don't reuse adjusted asize in sys_alloc\n * add LOCK_AT_FORK -- thanks to Kirill Artamonov for the suggestion\n * reduce compiler warnings -- thanks to all who reported/suggested these\n \n v2.8.5 Sun May 22 10:26:02 2011  Doug Lea  (dl at gee)\n * Always perform unlink checks unless INSECURE\n * Add posix_memalign.\n * Improve realloc to expand in more cases; expose realloc_in_place.\n Thanks to Peter Buhr for the suggestion.\n * Add footprint_limit, inspect_all, bulk_free. Thanks\n to Barry Hayes and others for the suggestions.\n * Internal refactorings to avoid calls while holding locks\n * Use non-reentrant locks by default. Thanks to Roland McGrath\n for the suggestion.\n * Small fixes to mspace_destroy, reset_on_error.\n * Various configuration extensions/changes. Thanks\n to all who contributed these.\n \n V2.8.4a Thu Apr 28 14:39:43 2011 (dl at gee.cs.oswego.edu)\n * Update Creative Commons URL\n \n V2.8.4 Wed May 27 09:56:23 2009  Doug Lea  (dl at gee)\n * Use zeros instead of prev foot for is_mmapped\n * Add mspace_track_large_chunks; thanks to Jean Brouwers\n * Fix set_inuse in internal_realloc; thanks to Jean Brouwers\n * Fix insufficient sys_alloc padding when using 16byte alignment\n * Fix bad error check in mspace_footprint\n * Adaptations for ptmalloc; thanks to Wolfram Gloger.\n * Reentrant spin locks; thanks to Earl Chew and others\n * Win32 improvements; thanks to Niall Douglas and Earl Chew\n * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options\n * Extension hook in malloc_state\n * Various small adjustments to reduce warnings on some compilers\n * Various configuration extensions/changes for more platforms. Thanks\n to all who contributed these.\n \n V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)\n * Add max_footprint functions\n * Ensure all appropriate literals are size_t\n * Fix conditional compilation problem for some #define settings\n * Avoid concatenating segments with the one provided\n in create_mspace_with_base\n * Rename some variables to avoid compiler shadowing warnings\n * Use explicit lock initialization.\n * Better handling of sbrk interference.\n * Simplify and fix segment insertion, trimming and mspace_destroy\n * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x\n * Thanks especially to Dennis Flanagan for help on these.\n \n V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)\n * Fix memalign brace error.\n \n V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)\n * Fix improper #endif nesting in C++\n * Add explicit casts needed for C++\n \n V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)\n * Use trees for large bins\n * Support mspaces\n * Use segments to unify sbrk-based and mmap-based system allocation,\n removing need for emulation on most platforms without sbrk.\n * Default safety checks\n * Optional footer checks. Thanks to William Robertson for the idea.\n * Internal code refactoring\n * Incorporate suggestions and platform-specific changes.\n Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,\n Aaron Bachmann,  Emery Berger, and others.\n * Speed up non-fastbin processing enough to remove fastbins.\n * Remove useless cfree() to avoid conflicts with other apps.\n * Remove internal memcpy, memset. Compilers handle builtins better.\n * Remove some options that no one ever used and rename others.\n \n V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)\n * Fix malloc_state bitmap array misdeclaration\n \n V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)\n * Allow tuning of FIRST_SORTED_BIN_SIZE\n * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.\n * Better detection and support for non-contiguousness of MORECORE.\n Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger\n * Bypass most of malloc if no frees. Thanks To Emery Berger.\n * Fix freeing of old top non-contiguous chunk im sysmalloc.\n * Raised default trim and map thresholds to 256K.\n * Fix mmap-related #defines. Thanks to Lubos Lunak.\n * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.\n * Branch-free bin calculation\n * Default trim and mmap thresholds now 256K.\n \n V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)\n * Introduce independent_comalloc and independent_calloc.\n Thanks to Michael Pachos for motivation and help.\n * Make optional .h file available\n * Allow > 2GB requests on 32bit systems.\n * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.\n Thanks also to Andreas Mueller <a.mueller at paradatec.de>,\n and Anonymous.\n * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for\n helping test this.)\n * memalign: check alignment arg\n * realloc: don't try to shift chunks backwards, since this\n leads to  more fragmentation in some programs and doesn't\n seem to help in any others.\n * Collect all cases in malloc requiring system memory into sysmalloc\n * Use mmap as backup to sbrk\n * Place all internal state in malloc_state\n * Introduce fastbins (although similar to 2.5.1)\n * Many minor tunings and cosmetic improvements\n * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK\n * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS\n Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.\n * Include errno.h to support default failure action.\n \n V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)\n * return null for negative arguments\n * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>\n * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'\n (e.g. WIN32 platforms)\n * Cleanup header file inclusion for WIN32 platforms\n * Cleanup code to avoid Microsoft Visual C++ compiler complaints\n * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing\n memory allocation routines\n * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)\n * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to\n usage of 'assert' in non-WIN32 code\n * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to\n avoid infinite loop\n * Always call 'fREe()' rather than 'free()'\n \n V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)\n * Fixed ordering problem with boundary-stamping\n \n V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)\n * Added pvalloc, as recommended by H.J. Liu\n * Added 64bit pointer support mainly from Wolfram Gloger\n * Added anonymously donated WIN32 sbrk emulation\n * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen\n * malloc_extend_top: fix mask error that caused wastage after\n foreign sbrks\n * Add linux mremap support code from HJ Liu\n \n V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)\n * Integrated most documentation with the code.\n * Add support for mmap, with help from\n Wolfram Gloger (Gloger@lrz.uni-muenchen.de).\n * Use last_remainder in more cases.\n * Pack bins using idea from  colin@nyx10.cs.du.edu\n * Use ordered bins instead of best-fit threshhold\n * Eliminate block-local decls to simplify tracing and debugging.\n * Support another case of realloc via move into top\n * Fix error occuring when initial sbrk_base not word-aligned.\n * Rely on page size for units instead of SBRK_UNIT to\n avoid surprises about sbrk alignment conventions.\n * Add mallinfo, mallopt. Thanks to Raymond Nijssen\n (raymond@es.ele.tue.nl) for the suggestion.\n * Add `pad' argument to malloc_trim and top_pad mallopt parameter.\n * More precautions for cases where other routines call sbrk,\n courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).\n * Added macros etc., allowing use in linux libc from\n H.J. Lu (hjl@gnu.ai.mit.edu)\n * Inverted this history list\n \n V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)\n * Re-tuned and fixed to behave more nicely with V2.6.0 changes.\n * Removed all preallocation code since under current scheme\n the work required to undo bad preallocations exceeds\n the work saved in good cases for most test programs.\n * No longer use return list or unconsolidated bins since\n no scheme using them consistently outperforms those that don't\n given above changes.\n * Use best fit for very large chunks to prevent some worst-cases.\n * Added some support for debugging\n \n V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)\n * Removed footers when chunks are in use. Thanks to\n Paul Wilson (wilson@cs.texas.edu) for the suggestion.\n \n V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)\n * Added malloc_trim, with help from Wolfram Gloger\n (wmglo@Dent.MED.Uni-Muenchen.DE).\n \n V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)\n \n V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)\n * realloc: try to expand in both directions\n * malloc: swap order of clean-bin strategy;\n * realloc: only conditionally expand backwards\n * Try not to scavenge used bins\n * Use bin counts as a guide to preallocation\n * Occasionally bin return list chunks in first scan\n * Add a few optimizations from colin@nyx10.cs.du.edu\n \n V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)\n * faster bin computation & slightly different binning\n * merged all consolidations to one part of malloc proper\n (eliminating old malloc_find_space & malloc_clean_bin)\n * Scan 2 returns chunks (not just 1)\n * Propagate failure in realloc if malloc returns 0\n * Add stuff to allow compilation on non-ANSI compilers\n from kpv@research.att.com\n \n V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)\n * removed potential for odd address access in prev_chunk\n * removed dependency on getpagesize.h\n * misc cosmetics and a bit more internal documentation\n * anticosmetics: mangled names in macros to evade debugger strangeness\n * tested on sparc, hp-700, dec-mips, rs6000\n with gcc & native cc (hp, dec only) allowing\n Detlefs & Zorn comparison study (in SIGPLAN Notices.)\n \n Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)\n * Based loosely on libg++-1.2X malloc. (It retains some of the overall\n structure of old version,  but most details differ.)\n \n */\n",".globl _emscripten_stack_restore\n.globl _emscripten_stack_alloc\n.globl emscripten_stack_get_current\n\n#ifdef __wasm64__\n#define PTR i64\n#define MASK 0xfffffffffffffff0\n#else\n#define PTR i32\n#define MASK 0xfffffff0\n#endif\n\n.globaltype __stack_pointer, PTR\n\n_emscripten_stack_restore:\n  .functype _emscripten_stack_restore(PTR) -> ()\n  local.get 0\n  global.set __stack_pointer\n  end_function\n\n_emscripten_stack_alloc:\n  .functype _emscripten_stack_alloc(PTR) -> (PTR)\n  .local PTR, PTR\n  global.get __stack_pointer\n  # Get arg 0 -> number of bytes to allocate\n  local.get 0\n  # Stack grows down.  Subtract arg0 from __stack_pointer\n  PTR.sub\n  # Align result by anding with ~15\n  PTR.const MASK\n  PTR.and\n  local.tee 1\n  global.set __stack_pointer\n  local.get 1\n  end_function\n\nemscripten_stack_get_current:\n  .functype emscripten_stack_get_current () -> (PTR)\n  global.get __stack_pointer\n  end_function\n","/*!\n\\brief Implementation of the Texture Decompression functions.\n\\file PVRCore/texture/PVRTDecompress.cpp\n\\author PowerVR by Imagination, Developer Technology Team\n\\copyright Copyright (c) Imagination Technologies Limited.\n*/\n//!\\cond NO_DOXYGEN\n\n#include <cstdlib>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include \"PVRTDecompress.h\"\n#include <cassert>\n#include <vector>\n\n//namespace pvr {\nenum\n{\n\tETC_MIN_TEXWIDTH = 4,\n\tETC_MIN_TEXHEIGHT = 4,\n\tDXT_MIN_TEXWIDTH = 4,\n\tDXT_MIN_TEXHEIGHT = 4,\n};\n\nstruct Pixel32\n{\n\tuint8_t red, green, blue, alpha;\n};\n\nstruct Pixel128S\n{\n\tint32_t red, green, blue, alpha;\n};\n\nstruct PVRTCWord\n{\n\tuint32_t modulationData;\n\tuint32_t colorData;\n};\n\nstruct PVRTCWordIndices\n{\n\tint P[2], Q[2], R[2], S[2];\n};\n\nstatic Pixel32 getColorA(uint32_t colorData)\n{\n\tPixel32 color;\n\n\t// Opaque Color Mode - RGB 554\n\tif ((colorData & 0x8000) != 0)\n\t{\n\t\tcolor.red = static_cast<uint8_t>((colorData & 0x7c00) >> 10); // 5->5 bits\n\t\tcolor.green = static_cast<uint8_t>((colorData & 0x3e0) >> 5); // 5->5 bits\n\t\tcolor.blue = static_cast<uint8_t>(colorData & 0x1e) | ((colorData & 0x1e) >> 4); // 4->5 bits\n\t\tcolor.alpha = static_cast<uint8_t>(0xf); // 0->4 bits\n\t}\n\t// Transparent Color Mode - ARGB 3443\n\telse\n\t{\n\t\tcolor.red = static_cast<uint8_t>((colorData & 0xf00) >> 7) | ((colorData & 0xf00) >> 11); // 4->5 bits\n\t\tcolor.green = static_cast<uint8_t>((colorData & 0xf0) >> 3) | ((colorData & 0xf0) >> 7); // 4->5 bits\n\t\tcolor.blue = static_cast<uint8_t>((colorData & 0xe) << 1) | ((colorData & 0xe) >> 2); // 3->5 bits\n\t\tcolor.alpha = static_cast<uint8_t>((colorData & 0x7000) >> 11); // 3->4 bits - note 0 at right\n\t}\n\n\treturn color;\n}\n\nstatic Pixel32 getColorB(uint32_t colorData)\n{\n\tPixel32 color;\n\n\t// Opaque Color Mode - RGB 555\n\tif (colorData & 0x80000000)\n\t{\n\t\tcolor.red = static_cast<uint8_t>((colorData & 0x7c000000) >> 26); // 5->5 bits\n\t\tcolor.green = static_cast<uint8_t>((colorData & 0x3e00000) >> 21); // 5->5 bits\n\t\tcolor.blue = static_cast<uint8_t>((colorData & 0x1f0000) >> 16); // 5->5 bits\n\t\tcolor.alpha = static_cast<uint8_t>(0xf); // 0 bits\n\t}\n\t// Transparent Color Mode - ARGB 3444\n\telse\n\t{\n\t\tcolor.red = static_cast<uint8_t>(((colorData & 0xf000000) >> 23) | ((colorData & 0xf000000) >> 27)); // 4->5 bits\n\t\tcolor.green = static_cast<uint8_t>(((colorData & 0xf00000) >> 19) | ((colorData & 0xf00000) >> 23)); // 4->5 bits\n\t\tcolor.blue = static_cast<uint8_t>(((colorData & 0xf0000) >> 15) | ((colorData & 0xf0000) >> 19)); // 4->5 bits\n\t\tcolor.alpha = static_cast<uint8_t>((colorData & 0x70000000) >> 27); // 3->4 bits - note 0 at right\n\t}\n\n\treturn color;\n}\n\nstatic void interpolateColors(Pixel32 P, Pixel32 Q, Pixel32 R, Pixel32 S, Pixel128S* pPixel, uint8_t bpp)\n{\n\tuint32_t wordWidth = 4;\n\tuint32_t wordHeight = 4;\n\tif (bpp == 2) { wordWidth = 8; }\n\n\t// Convert to int 32.\n\tPixel128S hP = { static_cast<int32_t>(P.red), static_cast<int32_t>(P.green), static_cast<int32_t>(P.blue), static_cast<int32_t>(P.alpha) };\n\tPixel128S hQ = { static_cast<int32_t>(Q.red), static_cast<int32_t>(Q.green), static_cast<int32_t>(Q.blue), static_cast<int32_t>(Q.alpha) };\n\tPixel128S hR = { static_cast<int32_t>(R.red), static_cast<int32_t>(R.green), static_cast<int32_t>(R.blue), static_cast<int32_t>(R.alpha) };\n\tPixel128S hS = { static_cast<int32_t>(S.red), static_cast<int32_t>(S.green), static_cast<int32_t>(S.blue), static_cast<int32_t>(S.alpha) };\n\n\t// Get vectors.\n\tPixel128S QminusP = { hQ.red - hP.red, hQ.green - hP.green, hQ.blue - hP.blue, hQ.alpha - hP.alpha };\n\tPixel128S SminusR = { hS.red - hR.red, hS.green - hR.green, hS.blue - hR.blue, hS.alpha - hR.alpha };\n\n\t// Multiply colors.\n\thP.red *= wordWidth;\n\thP.green *= wordWidth;\n\thP.blue *= wordWidth;\n\thP.alpha *= wordWidth;\n\thR.red *= wordWidth;\n\thR.green *= wordWidth;\n\thR.blue *= wordWidth;\n\thR.alpha *= wordWidth;\n\n\tif (bpp == 2)\n\t{\n\t\t// Loop through pixels to achieve results.\n\t\tfor (uint32_t x = 0; x < wordWidth; x++)\n\t\t{\n\t\t\tPixel128S result = { 4 * hP.red, 4 * hP.green, 4 * hP.blue, 4 * hP.alpha };\n\t\t\tPixel128S dY = { hR.red - hP.red, hR.green - hP.green, hR.blue - hP.blue, hR.alpha - hP.alpha };\n\n\t\t\tfor (uint32_t y = 0; y < wordHeight; y++)\n\t\t\t{\n\t\t\t\tpPixel[y * wordWidth + x].red = static_cast<int32_t>((result.red >> 7) + (result.red >> 2));\n\t\t\t\tpPixel[y * wordWidth + x].green = static_cast<int32_t>((result.green >> 7) + (result.green >> 2));\n\t\t\t\tpPixel[y * wordWidth + x].blue = static_cast<int32_t>((result.blue >> 7) + (result.blue >> 2));\n\t\t\t\tpPixel[y * wordWidth + x].alpha = static_cast<int32_t>((result.alpha >> 5) + (result.alpha >> 1));\n\n\t\t\t\tresult.red += dY.red;\n\t\t\t\tresult.green += dY.green;\n\t\t\t\tresult.blue += dY.blue;\n\t\t\t\tresult.alpha += dY.alpha;\n\t\t\t}\n\n\t\t\thP.red += QminusP.red;\n\t\t\thP.green += QminusP.green;\n\t\t\thP.blue += QminusP.blue;\n\t\t\thP.alpha += QminusP.alpha;\n\n\t\t\thR.red += SminusR.red;\n\t\t\thR.green += SminusR.green;\n\t\t\thR.blue += SminusR.blue;\n\t\t\thR.alpha += SminusR.alpha;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Loop through pixels to achieve results.\n\t\tfor (uint32_t y = 0; y < wordHeight; y++)\n\t\t{\n\t\t\tPixel128S result = { 4 * hP.red, 4 * hP.green, 4 * hP.blue, 4 * hP.alpha };\n\t\t\tPixel128S dY = { hR.red - hP.red, hR.green - hP.green, hR.blue - hP.blue, hR.alpha - hP.alpha };\n\n\t\t\tfor (uint32_t x = 0; x < wordWidth; x++)\n\t\t\t{\n\t\t\t\tpPixel[y * wordWidth + x].red = static_cast<int32_t>((result.red >> 6) + (result.red >> 1));\n\t\t\t\tpPixel[y * wordWidth + x].green = static_cast<int32_t>((result.green >> 6) + (result.green >> 1));\n\t\t\t\tpPixel[y * wordWidth + x].blue = static_cast<int32_t>((result.blue >> 6) + (result.blue >> 1));\n\t\t\t\tpPixel[y * wordWidth + x].alpha = static_cast<int32_t>((result.alpha >> 4) + (result.alpha));\n\n\t\t\t\tresult.red += dY.red;\n\t\t\t\tresult.green += dY.green;\n\t\t\t\tresult.blue += dY.blue;\n\t\t\t\tresult.alpha += dY.alpha;\n\t\t\t}\n\n\t\t\thP.red += QminusP.red;\n\t\t\thP.green += QminusP.green;\n\t\t\thP.blue += QminusP.blue;\n\t\t\thP.alpha += QminusP.alpha;\n\n\t\t\thR.red += SminusR.red;\n\t\t\thR.green += SminusR.green;\n\t\t\thR.blue += SminusR.blue;\n\t\t\thR.alpha += SminusR.alpha;\n\t\t}\n\t}\n}\n\nstatic void unpackModulations(const PVRTCWord& word, int32_t offsetX, int32_t offsetY, int32_t modulationValues[16][8], int32_t modulationModes[16][8], uint8_t bpp)\n{\n\tuint32_t WordModMode = word.colorData & 0x1;\n\tuint32_t ModulationBits = word.modulationData;\n\n\t// Unpack differently depending on 2bpp or 4bpp modes.\n\tif (bpp == 2)\n\t{\n\t\tif (WordModMode)\n\t\t{\n\t\t\t// determine which of the three modes are in use:\n\n\t\t\t// If this is the either the H-only or V-only interpolation mode...\n\t\t\tif (ModulationBits & 0x1)\n\t\t\t{\n\t\t\t\t// look at the \"LSB\" for the \"centre\" (V=2,H=4) texel. Its LSB is now\n\t\t\t\t// actually used to indicate whether it's the H-only mode or the V-only...\n\n\t\t\t\t// The centre texel data is the at (y==2, x==4) and so its LSB is at bit 20.\n\t\t\t\tif (ModulationBits & (0x1 << 20))\n\t\t\t\t{\n\t\t\t\t\t// This is the V-only mode\n\t\t\t\t\tWordModMode = 3;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// This is the H-only mode\n\t\t\t\t\tWordModMode = 2;\n\t\t\t\t}\n\n\t\t\t\t// Create an extra bit for the centre pixel so that it looks like\n\t\t\t\t// we have 2 actual bits for this texel. It makes later coding much easier.\n\t\t\t\tif (ModulationBits & (0x1 << 21))\n\t\t\t\t{\n\t\t\t\t\t// set it to produce code for 1.0\n\t\t\t\t\tModulationBits |= (0x1 << 20);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// clear it to produce 0.0 code\n\t\t\t\t\tModulationBits &= ~(0x1 << 20);\n\t\t\t\t}\n\t\t\t} // end if H-Only or V-Only interpolation mode was chosen\n\n\t\t\tif (ModulationBits & 0x2) { ModulationBits |= 0x1; /*set it*/ }\n\t\t\telse\n\t\t\t{\n\t\t\t\tModulationBits &= ~0x1; /*clear it*/\n\t\t\t}\n\n\t\t\t// run through all the pixels in the block. Note we can now treat all the\n\t\t\t// \"stored\" values as if they have 2bits (even when they didn't!)\n\t\t\tfor (uint8_t y = 0; y < 4; y++)\n\t\t\t{\n\t\t\t\tfor (uint8_t x = 0; x < 8; x++)\n\t\t\t\t{\n\t\t\t\t\tmodulationModes[static_cast<uint32_t>(x + offsetX)][static_cast<uint32_t>(y + offsetY)] = WordModMode;\n\n\t\t\t\t\t// if this is a stored value...\n\t\t\t\t\tif (((x ^ y) & 1) == 0) {modulationValues[static_cast<uint32_t>(x + offsetX)][static_cast<uint32_t>(y + offsetY)] = ModulationBits & 3;\n\t\t\t\t\t\tModulationBits >>= 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // end for y\n\t\t}\n\t\t// else if direct encoded 2bit mode - i.e. 1 mode bit per pixel\n\t\telse\n\t\t{\n\t\t\tfor (uint8_t y = 0; y < 4; y++)\n\t\t\t{\n\t\t\t\tfor (uint8_t x = 0; x < 8; x++)\n\t\t\t\t{\n\t\t\t\t\tmodulationModes[static_cast<uint32_t>(x + offsetX)][static_cast<uint32_t>(y + offsetY)] = WordModMode;\n\n\t\t\t\t\t/*\n\t\t\t\t\t// double the bits so 0=> 00, and 1=>11\n\t\t\t\t\t*/\n\t\t\t\t\tif (ModulationBits & 1) { modulationValues[static_cast<uint32_t>(x + offsetX)][static_cast<uint32_t>(y + offsetY)] = 0x3; }\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmodulationValues[static_cast<uint32_t>(x + offsetX)][static_cast<uint32_t>(y + offsetY)] = 0x0;\n\t\t\t\t\t}\n\t\t\t\t\tModulationBits >>= 1;\n\t\t\t\t}\n\t\t\t} // end for y\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Much simpler than the 2bpp decompression, only two modes, so the n/8 values are set directly.\n\t\t// run through all the pixels in the word.\n\t\tif (WordModMode)\n\t\t{\n\t\t\tfor (uint8_t y = 0; y < 4; y++)\n\t\t\t{\n\t\t\t\tfor (uint8_t x = 0; x < 4; x++)\n\t\t\t\t{\n\t\t\t\t\tmodulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] = ModulationBits & 3;\n\t\t\t\t\t// if (modulationValues==0) {}. We don't need to check 0, 0 = 0/8.\n\t\t\t\t\tif (modulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] == 1)\n\t\t\t\t\t{ modulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] = 4; }\n\t\t\t\t\telse if (modulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tmodulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] = 14; //+10 tells the decompressor to punch through alpha.\n\t\t\t\t\t}\n\t\t\t\t\telse if (modulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tmodulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] = 8;\n\t\t\t\t\t}\n\t\t\t\t\tModulationBits >>= 2;\n\t\t\t\t} // end for x\n\t\t\t} // end for y\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (uint8_t y = 0; y < 4; y++)\n\t\t\t{\n\t\t\t\tfor (uint8_t x = 0; x < 4; x++)\n\t\t\t\t{\n\t\t\t\t\tmodulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] = ModulationBits & 3;\n\t\t\t\t\tmodulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] *= 3;\n\t\t\t\t\tif (modulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] > 3)\n\t\t\t\t\t{ modulationValues[static_cast<uint32_t>(y + offsetY)][static_cast<uint32_t>(x + offsetX)] -= 1; }\n\t\t\t\t\tModulationBits >>= 2;\n\t\t\t\t} // end for x\n\t\t\t} // end for y\n\t\t}\n\t}\n}\n\nstatic int32_t getModulationValues(int32_t modulationValues[16][8], int32_t modulationModes[16][8], uint32_t xPos, uint32_t yPos, uint8_t bpp)\n{\n\tif (bpp == 2)\n\t{\n\t\tconst int32_t RepVals0[4] = { 0, 3, 5, 8 };\n\n\t\t// extract the modulation value. If a simple encoding\n\t\tif (modulationModes[xPos][yPos] == 0) { return RepVals0[modulationValues[xPos][yPos]]; }\n\t\telse\n\t\t{\n\t\t\t// if this is a stored value\n\t\t\tif (((xPos ^ yPos) & 1) == 0) { return RepVals0[modulationValues[xPos][yPos]]; }\n\n\t\t\t// else average from the neighbours\n\t\t\t// if H&V interpolation...\n\t\t\telse if (modulationModes[xPos][yPos] == 1)\n\t\t\t{\n\t\t\t\treturn (RepVals0[modulationValues[xPos][yPos - 1]] + RepVals0[modulationValues[xPos][yPos + 1]] + RepVals0[modulationValues[xPos - 1][yPos]] +\n\t\t\t\t\t\t   RepVals0[modulationValues[xPos + 1][yPos]] + 2) /\n\t\t\t\t\t4;\n\t\t\t}\n\t\t\t// else if H-Only\n\t\t\telse if (modulationModes[xPos][yPos] == 2)\n\t\t\t{\n\t\t\t\treturn (RepVals0[modulationValues[xPos - 1][yPos]] + RepVals0[modulationValues[xPos + 1][yPos]] + 1) / 2;\n\t\t\t}\n\t\t\t// else it's V-Only\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn (RepVals0[modulationValues[xPos][yPos - 1]] + RepVals0[modulationValues[xPos][yPos + 1]] + 1) / 2;\n\t\t\t}\n\t\t}\n\t}\n\telse if (bpp == 4)\n\t{\n\t\treturn modulationValues[xPos][yPos];\n\t}\n\n\treturn 0;\n}\n\nstatic void pvrtcGetDecompressedPixels(const PVRTCWord& P, const PVRTCWord& Q, const PVRTCWord& R, const PVRTCWord& S, Pixel32* pColorData, uint8_t bpp)\n{\n\t// 4bpp only needs 8*8 values, but 2bpp needs 16*8, so rather than wasting processor time we just statically allocate 16*8.\n\tint32_t modulationValues[16][8];\n\t// Only 2bpp needs this.\n\tint32_t modulationModes[16][8];\n\t// 4bpp only needs 16 values, but 2bpp needs 32, so rather than wasting processor time we just statically allocate 32.\n\tPixel128S upscaledColorA[32];\n\tPixel128S upscaledColorB[32];\n\n\tuint32_t wordWidth = 4;\n\tuint32_t wordHeight = 4;\n\tif (bpp == 2) { wordWidth = 8; }\n\n\t// Get the modulations from each word.\n\tunpackModulations(P, 0, 0, modulationValues, modulationModes, bpp);\n\tunpackModulations(Q, wordWidth, 0, modulationValues, modulationModes, bpp);\n\tunpackModulations(R, 0, wordHeight, modulationValues, modulationModes, bpp);\n\tunpackModulations(S, wordWidth, wordHeight, modulationValues, modulationModes, bpp);\n\n\t// Bilinear upscale image data from 2x2 -> 4x4\n\tinterpolateColors(getColorA(P.colorData), getColorA(Q.colorData), getColorA(R.colorData), getColorA(S.colorData), upscaledColorA, bpp);\n\tinterpolateColors(getColorB(P.colorData), getColorB(Q.colorData), getColorB(R.colorData), getColorB(S.colorData), upscaledColorB, bpp);\n\n\tfor (uint32_t y = 0; y < wordHeight; y++)\n\t{\n\t\tfor (uint32_t x = 0; x < wordWidth; x++)\n\t\t{\n\t\t\tint32_t mod = getModulationValues(modulationValues, modulationModes, x + wordWidth / 2, y + wordHeight / 2, bpp);\n\t\t\tbool punchthroughAlpha = false;\n\t\t\tif (mod > 10)\n\t\t\t{\n\t\t\t\tpunchthroughAlpha = true;\n\t\t\t\tmod -= 10;\n\t\t\t}\n\n\t\t\tPixel128S result;\n\t\t\tresult.red = (upscaledColorA[y * wordWidth + x].red * (8 - mod) + upscaledColorB[y * wordWidth + x].red * mod) / 8;\n\t\t\tresult.green = (upscaledColorA[y * wordWidth + x].green * (8 - mod) + upscaledColorB[y * wordWidth + x].green * mod) / 8;\n\t\t\tresult.blue = (upscaledColorA[y * wordWidth + x].blue * (8 - mod) + upscaledColorB[y * wordWidth + x].blue * mod) / 8;\n\t\t\tif (punchthroughAlpha) { result.alpha = 0; }\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.alpha = (upscaledColorA[y * wordWidth + x].alpha * (8 - mod) + upscaledColorB[y * wordWidth + x].alpha * mod) / 8;\n\t\t\t}\n\n\t\t\t// Convert the 32bit precision Result to 8 bit per channel color.\n\t\t\tif (bpp == 2)\n\t\t\t{\n\t\t\t\tpColorData[y * wordWidth + x].red = static_cast<uint8_t>(result.red);\n\t\t\t\tpColorData[y * wordWidth + x].green = static_cast<uint8_t>(result.green);\n\t\t\t\tpColorData[y * wordWidth + x].blue = static_cast<uint8_t>(result.blue);\n\t\t\t\tpColorData[y * wordWidth + x].alpha = static_cast<uint8_t>(result.alpha);\n\t\t\t}\n\t\t\telse if (bpp == 4)\n\t\t\t{\n\t\t\t\tpColorData[y + x * wordHeight].red = static_cast<uint8_t>(result.red);\n\t\t\t\tpColorData[y + x * wordHeight].green = static_cast<uint8_t>(result.green);\n\t\t\t\tpColorData[y + x * wordHeight].blue = static_cast<uint8_t>(result.blue);\n\t\t\t\tpColorData[y + x * wordHeight].alpha = static_cast<uint8_t>(result.alpha);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic uint32_t wrapWordIndex(uint32_t numWords, int word) { return ((word + numWords) % numWords); }\n\nstatic bool isPowerOf2(uint32_t input)\n{\n\tuint32_t minus1;\n\n\tif (!input) { return 0; }\n\n\tminus1 = input - 1;\n\treturn ((input | minus1) == (input ^ minus1));\n}\n\nstatic uint32_t TwiddleUV(uint32_t XSize, uint32_t YSize, uint32_t XPos, uint32_t YPos)\n{\n\t// Initially assume X is the larger size.\n\tuint32_t MinDimension = XSize;\n\tuint32_t MaxValue = YPos;\n\tuint32_t Twiddled = 0;\n\tuint32_t SrcBitPos = 1;\n\tuint32_t DstBitPos = 1;\n\tint ShiftCount = 0;\n\n\t// Check the sizes are valid.\n\tassert(YPos < YSize);\n\tassert(XPos < XSize);\n\tassert(isPowerOf2(YSize));\n\tassert(isPowerOf2(XSize));\n\n\t// If Y is the larger dimension - switch the min/max values.\n\tif (YSize < XSize)\n\t{\n\t\tMinDimension = YSize;\n\t\tMaxValue = XPos;\n\t}\n\n\t// Step through all the bits in the \"minimum\" dimension\n\twhile (SrcBitPos < MinDimension)\n\t{\n\t\tif (YPos & SrcBitPos) { Twiddled |= DstBitPos; }\n\n\t\tif (XPos & SrcBitPos) { Twiddled |= (DstBitPos << 1); }\n\n\t\tSrcBitPos <<= 1;\n\t\tDstBitPos <<= 2;\n\t\tShiftCount += 1;\n\t}\n\n\t// Prepend any unused bits\n\tMaxValue >>= ShiftCount;\n\tTwiddled |= (MaxValue << (2 * ShiftCount));\n\n\treturn Twiddled;\n}\n\nstatic void mapDecompressedData(Pixel32* pOutput, uint32_t width, const Pixel32* pWord, const PVRTCWordIndices& words, uint8_t bpp)\n{\n\tuint32_t wordWidth = 4;\n\tuint32_t wordHeight = 4;\n\tif (bpp == 2) { wordWidth = 8; }\n\n\tfor (uint32_t y = 0; y < wordHeight / 2; y++)\n\t{\n\t\tfor (uint32_t x = 0; x < wordWidth / 2; x++)\n\t\t{\n\t\t\tpOutput[(((words.P[1] * wordHeight) + y + wordHeight / 2) * width + words.P[0] * wordWidth + x + wordWidth / 2)] = pWord[y * wordWidth + x]; // map P\n\n\t\t\tpOutput[(((words.Q[1] * wordHeight) + y + wordHeight / 2) * width + words.Q[0] * wordWidth + x)] = pWord[y * wordWidth + x + wordWidth / 2]; // map Q\n\n\t\t\tpOutput[(((words.R[1] * wordHeight) + y) * width + words.R[0] * wordWidth + x + wordWidth / 2)] = pWord[(y + wordHeight / 2) * wordWidth + x]; // map R\n\n\t\t\tpOutput[(((words.S[1] * wordHeight) + y) * width + words.S[0] * wordWidth + x)] = pWord[(y + wordHeight / 2) * wordWidth + x + wordWidth / 2]; // map S\n\t\t}\n\t}\n}\nstatic uint32_t pvrtcDecompress(uint8_t* pCompressedData, Pixel32* pDecompressedData, uint32_t width, uint32_t height, uint8_t bpp)\n{\n\tuint32_t wordWidth = 4;\n\tuint32_t wordHeight = 4;\n\tif (bpp == 2) { wordWidth = 8; }\n\n\tuint32_t* pWordMembers = (uint32_t*)pCompressedData;\n\tPixel32* pOutData = pDecompressedData;\n\n\t// Calculate number of words\n\tint i32NumXWords = static_cast<int>(width / wordWidth);\n\tint i32NumYWords = static_cast<int>(height / wordHeight);\n\n\t// Structs used for decompression\n\tPVRTCWordIndices indices;\n\tstd::vector<Pixel32> pPixels(wordWidth * wordHeight * sizeof(Pixel32));\n\n\t// For each row of words\n\tfor (int32_t wordY = -1; wordY < i32NumYWords - 1; wordY++)\n\t{\n\t\t// for each column of words\n\t\tfor (int32_t wordX = -1; wordX < i32NumXWords - 1; wordX++)\n\t\t{\n\t\t\tindices.P[0] = static_cast<int>(wrapWordIndex(i32NumXWords, wordX));\n\t\t\tindices.P[1] = static_cast<int>(wrapWordIndex(i32NumYWords, wordY));\n\t\t\tindices.Q[0] = static_cast<int>(wrapWordIndex(i32NumXWords, wordX + 1));\n\t\t\tindices.Q[1] = static_cast<int>(wrapWordIndex(i32NumYWords, wordY));\n\t\t\tindices.R[0] = static_cast<int>(wrapWordIndex(i32NumXWords, wordX));\n\t\t\tindices.R[1] = static_cast<int>(wrapWordIndex(i32NumYWords, wordY + 1));\n\t\t\tindices.S[0] = static_cast<int>(wrapWordIndex(i32NumXWords, wordX + 1));\n\t\t\tindices.S[1] = static_cast<int>(wrapWordIndex(i32NumYWords, wordY + 1));\n\n\t\t\t// Work out the offsets into the twiddle structs, multiply by two as there are two members per word.\n\t\t\tuint32_t WordOffsets[4] = {\n\t\t\t\tTwiddleUV(i32NumXWords, i32NumYWords, indices.P[0], indices.P[1]) * 2,\n\t\t\t\tTwiddleUV(i32NumXWords, i32NumYWords, indices.Q[0], indices.Q[1]) * 2,\n\t\t\t\tTwiddleUV(i32NumXWords, i32NumYWords, indices.R[0], indices.R[1]) * 2,\n\t\t\t\tTwiddleUV(i32NumXWords, i32NumYWords, indices.S[0], indices.S[1]) * 2,\n\t\t\t};\n\n\t\t\t// Access individual elements to fill out PVRTCWord\n\t\t\tPVRTCWord P, Q, R, S;\n\t\t\tP.colorData = static_cast<uint32_t>(pWordMembers[WordOffsets[0] + 1]);\n\t\t\tP.modulationData = static_cast<uint32_t>(pWordMembers[WordOffsets[0]]);\n\t\t\tQ.colorData = static_cast<uint32_t>(pWordMembers[WordOffsets[1] + 1]);\n\t\t\tQ.modulationData = static_cast<uint32_t>(pWordMembers[WordOffsets[1]]);\n\t\t\tR.colorData = static_cast<uint32_t>(pWordMembers[WordOffsets[2] + 1]);\n\t\t\tR.modulationData = static_cast<uint32_t>(pWordMembers[WordOffsets[2]]);\n\t\t\tS.colorData = static_cast<uint32_t>(pWordMembers[WordOffsets[3] + 1]);\n\t\t\tS.modulationData = static_cast<uint32_t>(pWordMembers[WordOffsets[3]]);\n\n\t\t\t// assemble 4 words into struct to get decompressed pixels from\n\t\t\tpvrtcGetDecompressedPixels(P, Q, R, S, pPixels.data(), bpp);\n\t\t\tmapDecompressedData(pOutData, width, pPixels.data(), indices, bpp);\n\n\t\t} // for each word\n\t} // for each row of words\n\n\t// Return the data size\n\treturn width * height / static_cast<uint32_t>((wordWidth / 2));\n}\n\nuint32_t PVRTDecompressPVRTC(const void* pCompressedData, uint32_t Do2bitMode, uint32_t XDim, uint32_t YDim, uint8_t* pResultImage)\n{\n\t// Cast the output buffer to a Pixel32 pointer.\n\tPixel32* pDecompressedData = (Pixel32*)pResultImage;\n\n\t// Check the X and Y values are at least the minimum size.\n\tuint32_t XTrueDim = std::max(XDim, ((Do2bitMode == 1u) ? 16u : 8u));\n\tuint32_t YTrueDim = std::max(YDim, 8u);\n\n\t// If the dimensions aren't correct, we need to create a new buffer instead of just using the provided one, as the buffer will overrun otherwise.\n\tif (XTrueDim != XDim || YTrueDim != YDim) { pDecompressedData = new Pixel32[XTrueDim * YTrueDim]; }\n\n\t// Decompress the surface.\n\tuint32_t retval = pvrtcDecompress((uint8_t*)pCompressedData, pDecompressedData, XTrueDim, YTrueDim, uint8_t(Do2bitMode == 1 ? 2 : 4));\n\n\t// If the dimensions were too small, then copy the new buffer back into the output buffer.\n\tif (XTrueDim != XDim || YTrueDim != YDim)\n\t{\n\t\t// Loop through all the required pixels.\n\t\tfor (uint32_t x = 0; x < XDim; ++x)\n\t\t{\n\t\t\tfor (uint32_t y = 0; y < YDim; ++y) { ((Pixel32*)pResultImage)[x + y * XDim] = pDecompressedData[x + y * XTrueDim]; }\n\t\t}\n\n\t\t// Free the temporary buffer.\n\t\tdelete[] pDecompressedData;\n\t}\n\treturn retval;\n}\n\n////////////////////////////////////// ETC Compression //////////////////////////////////////\n\n#define _CLAMP_(X, Xmin, Xmax) ((X) < (Xmax) ? ((X) < (Xmin) ? (Xmin) : (X)) : (Xmax))\n\nuint32_t ETC_FLIP = 0x01000000;\nuint32_t ETC_DIFF = 0x02000000;\nconst int mod[8][4] = { { 2, 8, -2, -8 }, { 5, 17, -5, -17 }, { 9, 29, -9, -29 }, { 13, 42, -13, -42 }, { 18, 60, -18, -60 }, { 24, 80, -24, -80 }, { 33, 106, -33, -106 },\n\t{ 47, 183, -47, -183 } };\n\nstatic uint32_t modifyPixel(int red, int green, int blue, int x, int y, uint32_t modBlock, int modTable)\n{\n\tint index = x * 4 + y, pixelMod;\n\tuint32_t mostSig = modBlock << 1;\n\n\tif (index < 8) { pixelMod = mod[modTable][((modBlock >> (index + 24)) & 0x1) + ((mostSig >> (index + 8)) & 0x2)]; }\n\telse\n\t{\n\t\tpixelMod = mod[modTable][((modBlock >> (index + 8)) & 0x1) + ((mostSig >> (index - 8)) & 0x2)];\n\t}\n\n\tred = _CLAMP_(red + pixelMod, 0, 255);\n\tgreen = _CLAMP_(green + pixelMod, 0, 255);\n\tblue = _CLAMP_(blue + pixelMod, 0, 255);\n\n\treturn ((red << 16) + (green << 8) + blue) | 0xff000000;\n}\n\nstatic uint32_t ETCTextureDecompress(const void* pSrcData, uint32_t x, uint32_t y, void* pDestData, uint32_t /*nMode*/)\n{\n\tuint32_t* output;\n\tuint32_t blockTop, blockBot;\n\tconst uint32_t* input = static_cast<const uint32_t*>(pSrcData);\n\tunsigned char red1, green1, blue1, red2, green2, blue2;\n\tbool bFlip, bDiff;\n\tint modtable1, modtable2;\n\n\tfor (uint32_t i = 0; i < y; i += 4)\n\t{\n\t\tfor (uint32_t m = 0; m < x; m += 4)\n\t\t{\n\t\t\tblockTop = *(input++);\n\t\t\tblockBot = *(input++);\n\n\t\t\toutput = (uint32_t*)pDestData + i * x + m;\n\n\t\t\t// check flipbit\n\t\t\tbFlip = (blockTop & ETC_FLIP) != 0;\n\t\t\tbDiff = (blockTop & ETC_DIFF) != 0;\n\n\t\t\tif (bDiff)\n\t\t\t{\n\t\t\t\t// differential mode 5 color bits + 3 difference bits\n\t\t\t\t// get base color for subblock 1\n\t\t\t\tblue1 = static_cast<unsigned char>((blockTop & 0xf80000) >> 16u);\n\t\t\t\tgreen1 = static_cast<unsigned char>((blockTop & 0xf800) >> 8u);\n\t\t\t\tred1 = static_cast<unsigned char>(blockTop & 0xf8);\n\n\t\t\t\t// get differential color for subblock 2\n\t\t\t\tsigned char blues = static_cast<signed char>(blue1 >> 3) + (static_cast<signed char>((blockTop & 0x70000) >> 11) >> 5);\n\t\t\t\tsigned char greens = static_cast<signed char>(green1 >> 3) + (static_cast<signed char>((blockTop & 0x700) >> 3) >> 5);\n\t\t\t\tsigned char reds = static_cast<signed char>(red1 >> 3) + (static_cast<signed char>((blockTop & 0x7) << 5) >> 5);\n\n\t\t\t\tblue2 = static_cast<unsigned char>(blues);\n\t\t\t\tgreen2 = static_cast<unsigned char>(greens);\n\t\t\t\tred2 = static_cast<unsigned char>(reds);\n\n\t\t\t\tred1 = static_cast<unsigned char>(red1 + (red1 >> 5u)); // copy bits to lower sig\n\t\t\t\tgreen1 = static_cast<unsigned char>(green1 + (green1 >> 5u)); // copy bits to lower sig\n\t\t\t\tblue1 = static_cast<unsigned char>(blue1 + (blue1 >> 5u)); // copy bits to lower sig\n\n\t\t\t\tred2 = static_cast<unsigned char>((red2 << 3u) + (red2 >> 2u)); // copy bits to lower sig\n\t\t\t\tgreen2 = static_cast<unsigned char>((green2 << 3u) + (green2 >> 2u)); // copy bits to lower sig\n\t\t\t\tblue2 = static_cast<unsigned char>((blue2 << 3u) + (blue2 >> 2u)); // copy bits to lower sig\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// individual mode 4 + 4 color bits\n\t\t\t\t// get base color for subblock 1\n\t\t\t\tblue1 = static_cast<unsigned char>((blockTop & 0xf00000) >> 16);\n\t\t\t\tblue1 = static_cast<unsigned char>(blue1 + (blue1 >> 4)); // copy bits to lower sig\n\t\t\t\tgreen1 = static_cast<unsigned char>((blockTop & 0xf000) >> 8);\n\t\t\t\tgreen1 = static_cast<unsigned char>(green1 + (green1 >> 4)); // copy bits to lower sig\n\t\t\t\tred1 = static_cast<unsigned char>(blockTop & 0xf0);\n\t\t\t\tred1 = static_cast<unsigned char>(red1 + (red1 >> 4)); // copy bits to lower sig\n\n\t\t\t\t// get base color for subblock 2\n\t\t\t\tblue2 = static_cast<unsigned char>((blockTop & 0xf0000) >> 12);\n\t\t\t\tblue2 = static_cast<unsigned char>(blue2 + (blue2 >> 4)); // copy bits to lower sig\n\t\t\t\tgreen2 = static_cast<unsigned char>((blockTop & 0xf00) >> 4);\n\t\t\t\tgreen2 = static_cast<unsigned char>(green2 + (green2 >> 4)); // copy bits to lower sig\n\t\t\t\tred2 = static_cast<unsigned char>((blockTop & 0xf) << 4);\n\t\t\t\tred2 = static_cast<unsigned char>(red2 + (red2 >> 4)); // copy bits to lower sig\n\t\t\t}\n\t\t\t// get the modtables for each subblock\n\t\t\tmodtable1 = static_cast<int>((blockTop >> 29) & 0x7);\n\t\t\tmodtable2 = static_cast<int>((blockTop >> 26) & 0x7);\n\n\t\t\tif (!bFlip)\n\t\t\t{\n\t\t\t\t// 2 2x4 blocks side by side\n\n\t\t\t\tfor (uint8_t j = 0; j < 4; j++) // vertical\n\t\t\t\t{\n\t\t\t\t\tfor (uint8_t k = 0; k < 2; k++) // horizontal\n\t\t\t\t\t{\n\t\t\t\t\t\t*(output + j * x + k) = modifyPixel(red1, green1, blue1, k, j, blockBot, modtable1);\n\t\t\t\t\t\t*(output + j * x + k + 2) = modifyPixel(red2, green2, blue2, k + 2, j, blockBot, modtable2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 2 4x2 blocks on top of each other\n\t\t\t\tfor (uint8_t j = 0; j < 2; j++)\n\t\t\t\t{\n\t\t\t\t\tfor (uint8_t k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\t*(output + j * x + k) = modifyPixel(red1, green1, blue1, k, j, blockBot, modtable1);\n\t\t\t\t\t\t*(output + (j + 2) * x + k) = modifyPixel(red2, green2, blue2, k, j + 2, blockBot, modtable2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn x * y / 2;\n}\n\nuint32_t PVRTDecompressETC(const void* pSrcData, uint32_t x, uint32_t y, void* pDestData, uint32_t nMode)\n{\n\tuint32_t i32read;\n\n\tif (x < ETC_MIN_TEXWIDTH || y < ETC_MIN_TEXHEIGHT)\n\t{\n\t\t// decompress into a buffer big enough to take the minimum size\n\t\tchar* pTempBuffer = new char[std::max<uint32_t>(x, ETC_MIN_TEXWIDTH) * std::max<uint32_t>(y, ETC_MIN_TEXHEIGHT) * 4];\n\t\ti32read = ETCTextureDecompress(pSrcData, std::max<uint32_t>(x, ETC_MIN_TEXWIDTH), std::max<uint32_t>(y, ETC_MIN_TEXHEIGHT), pTempBuffer, nMode);\n\n\t\tfor (uint32_t i = 0; i < y; i++)\n\t\t{\n\t\t\t// copy from larger temp buffer to output data\n\t\t\tmemcpy(static_cast<char*>(pDestData) + i * x * 4, pTempBuffer + std::max<uint32_t>(x, ETC_MIN_TEXWIDTH) * 4 * i, x * 4);\n\t\t}\n\n\t\tdelete[] pTempBuffer;\n\t}\n\telse // decompress larger MIP levels straight into the output data\n\t{\n\t\ti32read = ETCTextureDecompress(pSrcData, x, y, pDestData, nMode);\n\t}\n\n\t// swap r and b channels\n\tunsigned char *pSwap = static_cast<unsigned char*>(pDestData), swap;\n\n\tfor (uint32_t i = 0; i < y; i++)\n\t\tfor (uint32_t j = 0; j < x; j++)\n\t\t{\n\t\t\tswap = pSwap[0];\n\t\t\tpSwap[0] = pSwap[2];\n\t\t\tpSwap[2] = swap;\n\t\t\tpSwap += 4;\n\t\t}\n\n\treturn i32read;\n}\n//} // namespace pvr\n//!\\endcond","//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"include/overridable_function.h\"\n#include <__assert>\n#include <__memory/aligned_alloc.h>\n#include <cstddef>\n#include <cstdlib>\n#include <new>\n\n#if !defined(__GLIBCXX__) && !defined(_LIBCPP_ABI_VCRUNTIME)\n\n// The code below is copied as-is into libc++abi's libcxxabi/src/stdlib_new_delete.cpp\n// file. The version in this file is the canonical one.\n\ninline void __throw_bad_alloc_shim() { std::__throw_bad_alloc(); }\n\n#  define _LIBCPP_ASSERT_SHIM(expr, str) _LIBCPP_ASSERT(expr, str)\n\n// ------------------ BEGIN COPY ------------------\n// Implement all new and delete operators as weak definitions\n// in this shared library, so that they can be overridden by programs\n// that define non-weak copies of the functions.\n\nstatic void* operator_new_impl(std::size_t size) {\n  if (size == 0)\n    size = 1;\n  void* p;\n  while ((p = std::malloc(size)) == nullptr) {\n    // If malloc fails and there is a new_handler,\n    // call it to try free up memory.\n    std::new_handler nh = std::get_new_handler();\n    if (nh)\n      nh();\n    else\n      break;\n  }\n  return p;\n}\n\n_LIBCPP_MAKE_OVERRIDABLE_FUNCTION_DETECTABLE _LIBCPP_WEAK void* operator new(std::size_t size) _THROW_BAD_ALLOC {\n  void* p = operator_new_impl(size);\n  if (p == nullptr)\n    __throw_bad_alloc_shim();\n  return p;\n}\n\n_LIBCPP_WEAK void* operator new(size_t size, const std::nothrow_t&) noexcept {\n#  if !_LIBCPP_HAS_EXCEPTIONS\n#    if _LIBCPP_CAN_DETECT_OVERRIDDEN_FUNCTION\n  _LIBCPP_ASSERT_SHIM(\n      !std::__is_function_overridden(static_cast<void* (*)(std::size_t)>(&operator new)),\n      \"libc++ was configured with exceptions disabled and `operator new(size_t)` has been overridden, \"\n      \"but `operator new(size_t, nothrow_t)` has not been overridden. This is problematic because \"\n      \"`operator new(size_t, nothrow_t)` must call `operator new(size_t)`, which will terminate in case \"\n      \"it fails to allocate, making it impossible for `operator new(size_t, nothrow_t)` to fulfill its \"\n      \"contract (since it should return nullptr upon failure). Please make sure you override \"\n      \"`operator new(size_t, nothrow_t)` as well.\");\n#    endif\n\n  return operator_new_impl(size);\n#  else\n  void* p = nullptr;\n  try {\n    p = ::operator new(size);\n  } catch (...) {\n  }\n  return p;\n#  endif\n}\n\n_LIBCPP_MAKE_OVERRIDABLE_FUNCTION_DETECTABLE _LIBCPP_WEAK void* operator new[](size_t size) _THROW_BAD_ALLOC {\n  return ::operator new(size);\n}\n\n_LIBCPP_WEAK void* operator new[](size_t size, const std::nothrow_t&) noexcept {\n#  if !_LIBCPP_HAS_EXCEPTIONS\n#    if _LIBCPP_CAN_DETECT_OVERRIDDEN_FUNCTION\n  _LIBCPP_ASSERT_SHIM(\n      !std::__is_function_overridden(static_cast<void* (*)(std::size_t)>(&operator new[])),\n      \"libc++ was configured with exceptions disabled and `operator new[](size_t)` has been overridden, \"\n      \"but `operator new[](size_t, nothrow_t)` has not been overridden. This is problematic because \"\n      \"`operator new[](size_t, nothrow_t)` must call `operator new[](size_t)`, which will terminate in case \"\n      \"it fails to allocate, making it impossible for `operator new[](size_t, nothrow_t)` to fulfill its \"\n      \"contract (since it should return nullptr upon failure). Please make sure you override \"\n      \"`operator new[](size_t, nothrow_t)` as well.\");\n#    endif\n\n  return operator_new_impl(size);\n#  else\n  void* p = nullptr;\n  try {\n    p = ::operator new[](size);\n  } catch (...) {\n  }\n  return p;\n#  endif\n}\n\n_LIBCPP_WEAK void operator delete(void* ptr) noexcept { std::free(ptr); }\n\n_LIBCPP_WEAK void operator delete(void* ptr, const std::nothrow_t&) noexcept { ::operator delete(ptr); }\n\n_LIBCPP_WEAK void operator delete(void* ptr, size_t) noexcept { ::operator delete(ptr); }\n\n_LIBCPP_WEAK void operator delete[](void* ptr) noexcept { ::operator delete(ptr); }\n\n_LIBCPP_WEAK void operator delete[](void* ptr, const std::nothrow_t&) noexcept { ::operator delete[](ptr); }\n\n_LIBCPP_WEAK void operator delete[](void* ptr, size_t) noexcept { ::operator delete[](ptr); }\n\n#  if _LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION\n\nstatic void* operator_new_aligned_impl(std::size_t size, std::align_val_t alignment) {\n  if (size == 0)\n    size = 1;\n  if (static_cast<size_t>(alignment) < sizeof(void*))\n    alignment = std::align_val_t(sizeof(void*));\n\n  // Try allocating memory. If allocation fails and there is a new_handler,\n  // call it to try free up memory, and try again until it succeeds, or until\n  // the new_handler decides to terminate.\n  void* p;\n  while ((p = std::__libcpp_aligned_alloc(static_cast<std::size_t>(alignment), size)) == nullptr) {\n    std::new_handler nh = std::get_new_handler();\n    if (nh)\n      nh();\n    else\n      break;\n  }\n  return p;\n}\n\n_LIBCPP_MAKE_OVERRIDABLE_FUNCTION_DETECTABLE _LIBCPP_WEAK void*\noperator new(std::size_t size, std::align_val_t alignment) _THROW_BAD_ALLOC {\n  void* p = operator_new_aligned_impl(size, alignment);\n  if (p == nullptr)\n    __throw_bad_alloc_shim();\n  return p;\n}\n\n_LIBCPP_WEAK void* operator new(size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept {\n#    if !_LIBCPP_HAS_EXCEPTIONS\n#      if _LIBCPP_CAN_DETECT_OVERRIDDEN_FUNCTION\n  _LIBCPP_ASSERT_SHIM(\n      !std::__is_function_overridden(static_cast<void* (*)(std::size_t, std::align_val_t)>(&operator new)),\n      \"libc++ was configured with exceptions disabled and `operator new(size_t, align_val_t)` has been overridden, \"\n      \"but `operator new(size_t, align_val_t, nothrow_t)` has not been overridden. This is problematic because \"\n      \"`operator new(size_t, align_val_t, nothrow_t)` must call `operator new(size_t, align_val_t)`, which will \"\n      \"terminate in case it fails to allocate, making it impossible for `operator new(size_t, align_val_t, nothrow_t)` \"\n      \"to fulfill its contract (since it should return nullptr upon failure). Please make sure you override \"\n      \"`operator new(size_t, align_val_t, nothrow_t)` as well.\");\n#      endif\n\n  return operator_new_aligned_impl(size, alignment);\n#    else\n  void* p = nullptr;\n  try {\n    p = ::operator new(size, alignment);\n  } catch (...) {\n  }\n  return p;\n#    endif\n}\n\n_LIBCPP_MAKE_OVERRIDABLE_FUNCTION_DETECTABLE _LIBCPP_WEAK void*\noperator new[](size_t size, std::align_val_t alignment) _THROW_BAD_ALLOC {\n  return ::operator new(size, alignment);\n}\n\n_LIBCPP_WEAK void* operator new[](size_t size, std::align_val_t alignment, const std::nothrow_t&) noexcept {\n#    if !_LIBCPP_HAS_EXCEPTIONS\n#      if _LIBCPP_CAN_DETECT_OVERRIDDEN_FUNCTION\n  _LIBCPP_ASSERT_SHIM(\n      !std::__is_function_overridden(static_cast<void* (*)(std::size_t, std::align_val_t)>(&operator new[])),\n      \"libc++ was configured with exceptions disabled and `operator new[](size_t, align_val_t)` has been overridden, \"\n      \"but `operator new[](size_t, align_val_t, nothrow_t)` has not been overridden. This is problematic because \"\n      \"`operator new[](size_t, align_val_t, nothrow_t)` must call `operator new[](size_t, align_val_t)`, which will \"\n      \"terminate in case it fails to allocate, making it impossible for `operator new[](size_t, align_val_t, \"\n      \"nothrow_t)` to fulfill its contract (since it should return nullptr upon failure). Please make sure you \"\n      \"override \"\n      \"`operator new[](size_t, align_val_t, nothrow_t)` as well.\");\n#      endif\n\n  return operator_new_aligned_impl(size, alignment);\n#    else\n  void* p = nullptr;\n  try {\n    p = ::operator new[](size, alignment);\n  } catch (...) {\n  }\n  return p;\n#    endif\n}\n\n_LIBCPP_WEAK void operator delete(void* ptr, std::align_val_t) noexcept { std::__libcpp_aligned_free(ptr); }\n\n_LIBCPP_WEAK void operator delete(void* ptr, std::align_val_t alignment, const std::nothrow_t&) noexcept {\n  ::operator delete(ptr, alignment);\n}\n\n_LIBCPP_WEAK void operator delete(void* ptr, size_t, std::align_val_t alignment) noexcept {\n  ::operator delete(ptr, alignment);\n}\n\n_LIBCPP_WEAK void operator delete[](void* ptr, std::align_val_t alignment) noexcept {\n  ::operator delete(ptr, alignment);\n}\n\n_LIBCPP_WEAK void operator delete[](void* ptr, std::align_val_t alignment, const std::nothrow_t&) noexcept {\n  ::operator delete[](ptr, alignment);\n}\n\n_LIBCPP_WEAK void operator delete[](void* ptr, size_t, std::align_val_t alignment) noexcept {\n  ::operator delete[](ptr, alignment);\n}\n\n#  endif // _LIBCPP_HAS_LIBRARY_ALIGNED_ALLOCATION\n// ------------------ END COPY ------------------\n\n#endif // !__GLIBCXX__ && !_LIBCPP_ABI_VCRUNTIME\n","//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___NEW_ALLOCATE_H\n#define _LIBCPP___NEW_ALLOCATE_H\n\n#include <__config>\n#include <__cstddef/max_align_t.h>\n#include <__cstddef/size_t.h>\n#include <__new/align_val_t.h>\n#include <__new/global_new_delete.h> // for _LIBCPP_HAS_SIZED_DEALLOCATION\n#include <__type_traits/type_identity.h>\n#include <__utility/element_count.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#  pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n_LIBCPP_CONSTEXPR inline _LIBCPP_HIDE_FROM_ABI bool __is_overaligned_for_new(size_t __align) _NOEXCEPT {\n#ifdef __STDCPP_DEFAULT_NEW_ALIGNMENT__\n  return __align > __STDCPP_DEFAULT_NEW_ALIGNMENT__;\n#else\n  return __align > _LIBCPP_ALIGNOF(max_align_t);\n#endif\n}\n\ntemplate <class... _Args>\n_LIBCPP_HIDE_FROM_ABI void* __libcpp_operator_new(_Args... __args) {\n#if __has_builtin(__builtin_operator_new) && __has_builtin(__builtin_operator_delete)\n  return __builtin_operator_new(__args...);\n#else\n  return ::operator new(__args...);\n#endif\n}\n\ntemplate <class... _Args>\n_LIBCPP_HIDE_FROM_ABI void __libcpp_operator_delete(_Args... __args) _NOEXCEPT {\n#if __has_builtin(__builtin_operator_new) && __has_builtin(__builtin_operator_delete)\n  __builtin_operator_delete(__args...);\n#else\n  ::operator delete(__args...);\n#endif\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_HIDE_FROM_ABI _LIBCPP_NO_CFI _Tp*\n__libcpp_allocate(__element_count __n, size_t __align = _LIBCPP_ALIGNOF(_Tp)) {\n  size_t __size = static_cast<size_t>(__n) * sizeof(_Tp);\n#if _LIBCPP_HAS_ALIGNED_ALLOCATION\n  if (__is_overaligned_for_new(__align)) {\n    const align_val_t __align_val = static_cast<align_val_t>(__align);\n    return static_cast<_Tp*>(std::__libcpp_operator_new(__size, __align_val));\n  }\n#endif\n\n  (void)__align;\n  return static_cast<_Tp*>(std::__libcpp_operator_new(__size));\n}\n\n#if _LIBCPP_HAS_SIZED_DEALLOCATION\n#  define _LIBCPP_ONLY_IF_SIZED_DEALLOCATION(...) __VA_ARGS__\n#else\n#  define _LIBCPP_ONLY_IF_SIZED_DEALLOCATION(...) /* nothing */\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_HIDE_FROM_ABI void __libcpp_deallocate(\n    __type_identity_t<_Tp>* __ptr, __element_count __n, size_t __align = _LIBCPP_ALIGNOF(_Tp)) _NOEXCEPT {\n  size_t __size = static_cast<size_t>(__n) * sizeof(_Tp);\n  (void)__size;\n#if !_LIBCPP_HAS_ALIGNED_ALLOCATION\n  (void)__align;\n  return std::__libcpp_operator_delete(__ptr _LIBCPP_ONLY_IF_SIZED_DEALLOCATION(, __size));\n#else\n  if (__is_overaligned_for_new(__align)) {\n    const align_val_t __align_val = static_cast<align_val_t>(__align);\n    return std::__libcpp_operator_delete(__ptr _LIBCPP_ONLY_IF_SIZED_DEALLOCATION(, __size), __align_val);\n  } else {\n    return std::__libcpp_operator_delete(__ptr _LIBCPP_ONLY_IF_SIZED_DEALLOCATION(, __size));\n  }\n#endif\n}\n\n#undef _LIBCPP_ONLY_IF_SIZED_DEALLOCATION\n\ntemplate <class _Tp>\ninline _LIBCPP_HIDE_FROM_ABI void\n__libcpp_deallocate_unsized(__type_identity_t<_Tp>* __ptr, size_t __align = _LIBCPP_ALIGNOF(_Tp)) _NOEXCEPT {\n#if !_LIBCPP_HAS_ALIGNED_ALLOCATION\n  (void)__align;\n  return std::__libcpp_operator_delete(__ptr);\n#else\n  if (__is_overaligned_for_new(__align)) {\n    const align_val_t __align_val = static_cast<align_val_t>(__align);\n    return std::__libcpp_operator_delete(__ptr, __align_val);\n  } else {\n    return std::__libcpp_operator_delete(__ptr);\n  }\n#endif\n}\n_LIBCPP_END_NAMESPACE_STD\n\n#endif // _LIBCPP___NEW_ALLOCATE_H\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___MEMORY_ALLOCATOR_H\n#define _LIBCPP___MEMORY_ALLOCATOR_H\n\n#include <__config>\n#include <__cstddef/ptrdiff_t.h>\n#include <__cstddef/size_t.h>\n#include <__memory/addressof.h>\n#include <__memory/allocate_at_least.h>\n#include <__memory/allocator_traits.h>\n#include <__new/allocate.h>\n#include <__new/exceptions.h>\n#include <__type_traits/is_const.h>\n#include <__type_traits/is_constant_evaluated.h>\n#include <__type_traits/is_same.h>\n#include <__type_traits/is_void.h>\n#include <__type_traits/is_volatile.h>\n#include <__utility/forward.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#  pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp>\nclass allocator;\n\n#if _LIBCPP_STD_VER <= 17\n// These specializations shouldn't be marked _LIBCPP_DEPRECATED_IN_CXX17.\n// Specializing allocator<void> is deprecated, but not using it.\ntemplate <>\nclass _LIBCPP_TEMPLATE_VIS allocator<void> {\npublic:\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef void* pointer;\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef const void* const_pointer;\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef void value_type;\n\n  template <class _Up>\n  struct _LIBCPP_DEPRECATED_IN_CXX17 rebind {\n    typedef allocator<_Up> other;\n  };\n};\n#endif // _LIBCPP_STD_VER <= 17\n\n// This class provides a non-trivial default constructor to the class that derives from it\n// if the condition is satisfied.\n//\n// The second template parameter exists to allow giving a unique type to __non_trivial_if,\n// which makes it possible to avoid breaking the ABI when making this a base class of an\n// existing class. Without that, imagine we have classes D1 and D2, both of which used to\n// have no base classes, but which now derive from __non_trivial_if. The layout of a class\n// that inherits from both D1 and D2 will change because the two __non_trivial_if base\n// classes are not allowed to share the same address.\n//\n// By making those __non_trivial_if base classes unique, we work around this problem and\n// it is safe to start deriving from __non_trivial_if in existing classes.\ntemplate <bool _Cond, class _Unique>\nstruct __non_trivial_if {};\n\ntemplate <class _Unique>\nstruct __non_trivial_if<true, _Unique> {\n  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR __non_trivial_if() _NOEXCEPT {}\n};\n\n// allocator\n//\n// Note: For ABI compatibility between C++20 and previous standards, we make\n//       allocator<void> trivial in C++20.\n\ntemplate <class _Tp>\nclass _LIBCPP_TEMPLATE_VIS allocator : private __non_trivial_if<!is_void<_Tp>::value, allocator<_Tp> > {\n  static_assert(!is_const<_Tp>::value, \"std::allocator does not support const types\");\n  static_assert(!is_volatile<_Tp>::value, \"std::allocator does not support volatile types\");\n\npublic:\n  typedef size_t size_type;\n  typedef ptrdiff_t difference_type;\n  typedef _Tp value_type;\n  typedef true_type propagate_on_container_move_assignment;\n#if _LIBCPP_STD_VER <= 23 || defined(_LIBCPP_ENABLE_CXX26_REMOVED_ALLOCATOR_MEMBERS)\n  _LIBCPP_DEPRECATED_IN_CXX23 typedef true_type is_always_equal;\n#endif\n\n  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 allocator() _NOEXCEPT = default;\n\n  template <class _Up>\n  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 allocator(const allocator<_Up>&) _NOEXCEPT {}\n\n  [[__nodiscard__]] _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 _Tp* allocate(size_t __n) {\n    static_assert(sizeof(_Tp) >= 0, \"cannot allocate memory for an incomplete type\");\n    if (__n > allocator_traits<allocator>::max_size(*this))\n      __throw_bad_array_new_length();\n    if (__libcpp_is_constant_evaluated()) {\n      return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n    } else {\n      return std::__libcpp_allocate<_Tp>(__element_count(__n));\n    }\n  }\n\n#if _LIBCPP_STD_VER >= 23\n  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI constexpr allocation_result<_Tp*> allocate_at_least(size_t __n) {\n    static_assert(sizeof(_Tp) >= 0, \"cannot allocate memory for an incomplete type\");\n    return {allocate(__n), __n};\n  }\n#endif\n\n  _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 void deallocate(_Tp* __p, size_t __n) _NOEXCEPT {\n    if (__libcpp_is_constant_evaluated()) {\n      ::operator delete(__p);\n    } else {\n      std::__libcpp_deallocate<_Tp>(__p, __element_count(__n));\n    }\n  }\n\n  // C++20 Removed members\n#if _LIBCPP_STD_VER <= 17\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef _Tp* pointer;\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef const _Tp* const_pointer;\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef _Tp& reference;\n  _LIBCPP_DEPRECATED_IN_CXX17 typedef const _Tp& const_reference;\n\n  template <class _Up>\n  struct _LIBCPP_DEPRECATED_IN_CXX17 rebind {\n    typedef allocator<_Up> other;\n  };\n\n  _LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_HIDE_FROM_ABI pointer address(reference __x) const _NOEXCEPT {\n    return std::addressof(__x);\n  }\n  _LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_HIDE_FROM_ABI const_pointer address(const_reference __x) const _NOEXCEPT {\n    return std::addressof(__x);\n  }\n\n  [[__nodiscard__]] _LIBCPP_HIDE_FROM_ABI _LIBCPP_DEPRECATED_IN_CXX17 _Tp* allocate(size_t __n, const void*) {\n    return allocate(__n);\n  }\n\n  _LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_HIDE_FROM_ABI size_type max_size() const _NOEXCEPT {\n    return size_type(~0) / sizeof(_Tp);\n  }\n\n  template <class _Up, class... _Args>\n  _LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_HIDE_FROM_ABI void construct(_Up* __p, _Args&&... __args) {\n    ::new ((void*)__p) _Up(std::forward<_Args>(__args)...);\n  }\n\n  _LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_HIDE_FROM_ABI void destroy(pointer __p) { __p->~_Tp(); }\n#endif\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX20 bool\noperator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {\n  return true;\n}\n\n#if _LIBCPP_STD_VER <= 17\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_HIDE_FROM_ABI bool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {\n  return false;\n}\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif // _LIBCPP___MEMORY_ALLOCATOR_H\n","//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//\n// This file implements the functionality associated with the terminate_handler,\n// unexpected_handler, and new_handler.\n//===----------------------------------------------------------------------===//\n\n#include <stdexcept>\n#include <new>\n#include <exception>\n#include \"abort_message.h\"\n#include \"cxxabi.h\"\n#include \"cxa_handlers.h\"\n#include \"cxa_exception.h\"\n#include \"private_typeinfo.h\"\n#include \"include/atomic_support.h\" // from libc++\n\nnamespace std\n{\n\nunexpected_handler\nget_unexpected() noexcept\n{\n    return __libcpp_atomic_load(&__cxa_unexpected_handler, _AO_Acquire);\n}\n\nvoid\n__unexpected(unexpected_handler func)\n{\n    func();\n    // unexpected handler should not return\n    __abort_message(\"unexpected_handler unexpectedly returned\");\n}\n\n__attribute__((noreturn))\nvoid\nunexpected()\n{\n    __unexpected(get_unexpected());\n}\n\nterminate_handler\nget_terminate() noexcept\n{\n    return __libcpp_atomic_load(&__cxa_terminate_handler, _AO_Acquire);\n}\n\nvoid\n__terminate(terminate_handler func) noexcept\n{\n#ifndef _LIBCXXABI_NO_EXCEPTIONS\n    try\n    {\n#endif // _LIBCXXABI_NO_EXCEPTIONS\n        func();\n        // handler should not return\n        __abort_message(\"terminate_handler unexpectedly returned\");\n#ifndef _LIBCXXABI_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        // handler should not throw exception\n        __abort_message(\"terminate_handler unexpectedly threw an exception\");\n    }\n#endif // _LIBCXXABI_NO_EXCEPTIONS\n}\n\n__attribute__((noreturn))\nvoid\nterminate() noexcept\n{\n#if !defined(_LIBCXXABI_NO_EXCEPTIONS) && !defined(__EMSCRIPTEN_EXCEPTIONS__)\n    // If there might be an uncaught exception\n    using namespace __cxxabiv1;\n    __cxa_eh_globals* globals = __cxa_get_globals_fast();\n    if (globals)\n    {\n        __cxa_exception* exception_header = globals->caughtExceptions;\n        if (exception_header)\n        {\n            _Unwind_Exception* unwind_exception =\n                reinterpret_cast<_Unwind_Exception*>(exception_header + 1) - 1;\n            if (__isOurExceptionClass(unwind_exception))\n                __terminate(exception_header->terminateHandler);\n        }\n    }\n#endif\n    __terminate(get_terminate());\n}\n\nnew_handler\nget_new_handler() noexcept\n{\n    return __libcpp_atomic_load(&__cxa_new_handler, _AO_Acquire);\n}\n\n}  // std\n","//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include <__verbose_abort>\n#include <new>\n\nnamespace std { // purposefully not versioned\n\n#ifndef __GLIBCXX__\nconst nothrow_t nothrow{};\n#endif\n\n#ifndef LIBSTDCXX\n\nvoid __throw_bad_alloc() {\n#  if _LIBCPP_HAS_EXCEPTIONS\n  throw bad_alloc();\n#  else\n  _LIBCPP_VERBOSE_ABORT(\"bad_alloc was thrown in -fno-exceptions mode\");\n#  endif\n}\n\n#endif // !LIBSTDCXX\n\n} // namespace std\n","#include <stdlib.h>\n#include <signal.h>\n#include \"syscall.h\"\n#include \"pthread_impl.h\"\n#include \"atomic.h\"\n#include \"lock.h\"\n#include \"ksigaction.h\"\n\n#if __EMSCRIPTEN__\n#include \"emscripten_internal.h\"\n#endif\n\n_Noreturn void abort(void)\n{\n#if __EMSCRIPTEN__\n\t/* In emscripten we call out to JS to perform the actual abort where it can\n\t * produce a nice error.\n\t * Note that the JS library function is not called `abort` to avoid conflict\n\t * with the JavaScript abort helper (which takes a JS string as an argument\n\t * and is itself used to implement `_abort_js`) */\n\t_abort_js();\n#else\n\traise(SIGABRT);\n\n\t/* If there was a SIGABRT handler installed and it returned, or if\n\t * SIGABRT was blocked or ignored, take an AS-safe lock to prevent\n\t * sigaction from installing a new SIGABRT handler, uninstall any\n\t * handler that may be present, and re-raise the signal to generate\n\t * the default action of abnormal termination. */\n\t__block_all_sigs(0);\n\tLOCK(__abort_lock);\n\t__syscall(SYS_rt_sigaction, SIGABRT,\n\t\t&(struct k_sigaction){.handler = SIG_DFL}, 0, _NSIG/8);\n\t__syscall(SYS_tkill, __pthread_self()->tid, SIGABRT);\n\t__syscall(SYS_rt_sigprocmask, SIG_UNBLOCK,\n\t\t&(long[_NSIG/(8*sizeof(long))]){1UL<<(SIGABRT-1)}, 0, _NSIG/8);\n\n\t/* Beyond this point should be unreachable. */\n\ta_crash();\n\traise(SIGKILL);\n\t_Exit(127);\n#endif\n}\n","//===----------------------------------------------------------------------===////\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===////\n\n#ifndef ATOMIC_SUPPORT_H\n#define ATOMIC_SUPPORT_H\n\n#include <__config>\n#include <memory> // for __libcpp_relaxed_load\n\n#if defined(__clang__) && __has_builtin(__atomic_load_n) && __has_builtin(__atomic_store_n) &&                         \\\n    __has_builtin(__atomic_add_fetch) && __has_builtin(__atomic_exchange_n) &&                                         \\\n    __has_builtin(__atomic_compare_exchange_n) && defined(__ATOMIC_RELAXED) && defined(__ATOMIC_CONSUME) &&            \\\n    defined(__ATOMIC_ACQUIRE) && defined(__ATOMIC_RELEASE) && defined(__ATOMIC_ACQ_REL) && defined(__ATOMIC_SEQ_CST)\n#  define _LIBCPP_HAS_ATOMIC_BUILTINS\n#elif defined(_LIBCPP_COMPILER_GCC)\n#  define _LIBCPP_HAS_ATOMIC_BUILTINS\n#endif\n\n#if !defined(_LIBCPP_HAS_ATOMIC_BUILTINS) && _LIBCPP_HAS_THREADS\n#  if defined(_LIBCPP_WARNING)\n_LIBCPP_WARNING(\"Building libc++ without __atomic builtins is unsupported\")\n#  else\n#    warning Building libc++ without __atomic builtins is unsupported\n#  endif\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace {\n\n#if defined(_LIBCPP_HAS_ATOMIC_BUILTINS) && _LIBCPP_HAS_THREADS\n\nenum __libcpp_atomic_order {\n  _AO_Relaxed = __ATOMIC_RELAXED,\n  _AO_Consume = __ATOMIC_CONSUME,\n  _AO_Acquire = __ATOMIC_ACQUIRE,\n  _AO_Release = __ATOMIC_RELEASE,\n  _AO_Acq_Rel = __ATOMIC_ACQ_REL,\n  _AO_Seq     = __ATOMIC_SEQ_CST\n};\n\ntemplate <class _ValueType, class _FromType>\ninline _LIBCPP_HIDE_FROM_ABI void __libcpp_atomic_store(_ValueType* __dest, _FromType __val, int __order = _AO_Seq) {\n  __atomic_store_n(__dest, __val, __order);\n}\n\ntemplate <class _ValueType, class _FromType>\ninline _LIBCPP_HIDE_FROM_ABI void __libcpp_relaxed_store(_ValueType* __dest, _FromType __val) {\n  __atomic_store_n(__dest, __val, _AO_Relaxed);\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_HIDE_FROM_ABI _ValueType __libcpp_atomic_load(_ValueType const* __val, int __order = _AO_Seq) {\n  return __atomic_load_n(__val, __order);\n}\n\ntemplate <class _ValueType, class _AddType>\ninline _LIBCPP_HIDE_FROM_ABI _ValueType __libcpp_atomic_add(_ValueType* __val, _AddType __a, int __order = _AO_Seq) {\n  return __atomic_add_fetch(__val, __a, __order);\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_HIDE_FROM_ABI _ValueType\n__libcpp_atomic_exchange(_ValueType* __target, _ValueType __value, int __order = _AO_Seq) {\n  return __atomic_exchange_n(__target, __value, __order);\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_HIDE_FROM_ABI bool __libcpp_atomic_compare_exchange(\n    _ValueType* __val,\n    _ValueType* __expected,\n    _ValueType __after,\n    int __success_order = _AO_Seq,\n    int __fail_order    = _AO_Seq) {\n  return __atomic_compare_exchange_n(__val, __expected, __after, true, __success_order, __fail_order);\n}\n\n#else // _LIBCPP_HAS_THREADS\n\nenum __libcpp_atomic_order { _AO_Relaxed, _AO_Consume, _AO_Acquire, _AO_Release, _AO_Acq_Rel, _AO_Seq };\n\ntemplate <class _ValueType, class _FromType>\ninline _LIBCPP_HIDE_FROM_ABI void __libcpp_atomic_store(_ValueType* __dest, _FromType __val, int = 0) {\n  *__dest = __val;\n}\n\ntemplate <class _ValueType, class _FromType>\ninline _LIBCPP_HIDE_FROM_ABI void __libcpp_relaxed_store(_ValueType* __dest, _FromType __val) {\n  *__dest = __val;\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_HIDE_FROM_ABI _ValueType __libcpp_atomic_load(_ValueType const* __val, int = 0) {\n  return *__val;\n}\n\ntemplate <class _ValueType, class _AddType>\ninline _LIBCPP_HIDE_FROM_ABI _ValueType __libcpp_atomic_add(_ValueType* __val, _AddType __a, int = 0) {\n  return *__val += __a;\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_HIDE_FROM_ABI _ValueType\n__libcpp_atomic_exchange(_ValueType* __target, _ValueType __value, int = _AO_Seq) {\n  _ValueType old = *__target;\n  *__target      = __value;\n  return old;\n}\n\ntemplate <class _ValueType>\ninline _LIBCPP_HIDE_FROM_ABI bool\n__libcpp_atomic_compare_exchange(_ValueType* __val, _ValueType* __expected, _ValueType __after, int = 0, int = 0) {\n  if (*__val == *__expected) {\n    *__val = __after;\n    return true;\n  }\n  *__expected = *__val;\n  return false;\n}\n\n#endif // _LIBCPP_HAS_THREADS\n\n} // namespace\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif // ATOMIC_SUPPORT_H\n","#include <sys/time.h>\n#include <errno.h>\n#include \"syscall.h\"\n\n#define IS32BIT(x) !((x)+0x80000000ULL>>32)\n\n#ifdef __EMSCRIPTEN__\n#include <emscripten/emscripten.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#include \"emscripten_internal.h\"\n\n// Timeouts can either fire directly from the JS event loop (which calls\n// `_emscripten_timeout`), or from `_emscripten_check_timers` (which is called\n// from `_emscripten_yield`).  In order to be able to check the timers here we\n// cache the current timeout and interval for each the 3 types of timer\n// (ITIMER_PROF/ITIMER_VIRTUAL/ITIMER_REAL).\nstatic double current_timeout_ms[3];\nstatic double current_intervals_ms[3];\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n\nvoid __getitimer(int which, struct itimerval *old, double now)\n{\n\tdouble remaining_ms = MAX(current_timeout_ms[which] - now, 0);\n\told->it_value.tv_sec = remaining_ms / 1000;\n\told->it_value.tv_usec = remaining_ms * 1000;\n\told->it_interval.tv_sec = current_intervals_ms[which] / 1000;\n\told->it_interval.tv_usec = current_intervals_ms[which] * 1000;\n}\n\nvoid _emscripten_timeout(int which, double now)\n{\n\tint signum = SIGALRM;\n\tif (which == ITIMER_PROF)\n\t\tsignum = SIGPROF;\n\telse if (which == ITIMER_VIRTUAL)\n\t\tsignum = SIGVTALRM;\n\tdouble next_timeout = 0.0;\n\tif (current_intervals_ms[which]) {\n\t\t// If time went backwards, schedule the next timer as if it didn't.\n\t\tnow = __builtin_wasm_max_f64(now, current_timeout_ms[which]);\n\t\t// The next alarm is due 'interval' ms after the previous one.\n\t\t// If this alarm was delayed, that is sooner than 'interval' ms\n\t\t// from now. The delay could even be so long that we missed the\n\t\t// next alarm(s) entirely. Schedule the alarm for the next\n\t\t// multiple of 'interval' ms from the original due time.\n\t\tuint64_t intervals =\n\t\t\t(uint64_t)(now - current_timeout_ms[which]) /\n\t\t\t  (uint64_t)current_intervals_ms[which] +\n\t\t\t1;\n\t\tcurrent_timeout_ms[which] +=\n\t\t\tintervals * current_intervals_ms[which];\n\t\tnext_timeout = current_timeout_ms[which] - now;\n\t} else {\n\t\tcurrent_timeout_ms[which] = 0;\n\t}\n\t_setitimer_js(which, next_timeout);\n\traise(signum);\n}\n\nvoid _emscripten_check_timers(double now)\n{\n\tfor (int which = 0; which < 3; which++) {\n\t\tif (current_timeout_ms[which]) {\n\t\t\t// Only call out to JS to get the current time if it was not passed in\n\t\t\t// *and* we have one or more timers set.\n\t\t\tif (!now)\n\t\t\t \tnow = emscripten_get_now();\n\t\t\tif (now >= current_timeout_ms[which])\n\t\t\t\t_emscripten_timeout(which, now);\n\t\t}\n\t}\n}\n#endif\n\nint setitimer(int which, const struct itimerval *restrict new, struct itimerval *restrict old)\n{\n#ifdef __EMSCRIPTEN__\n\tif (which > ITIMER_PROF) return EINVAL;\n\tdouble now = emscripten_get_now();\n\tif (old) {\n\t\t__getitimer(which, old, now);\n\t}\n\tif (new->it_value.tv_sec || new->it_value.tv_usec) {\n\t\tcurrent_timeout_ms[which] = now + new->it_value.tv_sec * 1000 + new->it_value.tv_usec / 1000;\n\t\tcurrent_intervals_ms[which] = new->it_interval.tv_sec * 1000 + new->it_interval.tv_usec / 1000;\n\t} else {\n\t\tcurrent_timeout_ms[which] = 0;\n\t\tcurrent_intervals_ms[which] = 0;\n\t}\n\treturn _setitimer_js(which, new->it_value.tv_sec * 1000 + new->it_value.tv_usec / 1000);\n#else\n\tif (sizeof(time_t) > sizeof(long)) {\n\t\ttime_t is = new->it_interval.tv_sec, vs = new->it_value.tv_sec;\n\t\tlong ius = new->it_interval.tv_usec, vus = new->it_value.tv_usec;\n\t\tif (!IS32BIT(is) || !IS32BIT(vs))\n\t\t\treturn __syscall_ret(-ENOTSUP);\n\t\tlong old32[4];\n\t\tint r = __syscall(SYS_setitimer, which,\n\t\t\t((long[]){is, ius, vs, vus}), old32);\n\t\tif (!r && old) {\n\t\t\told->it_interval.tv_sec = old32[0];\n\t\t\told->it_interval.tv_usec = old32[1];\n\t\t\told->it_value.tv_sec = old32[2];\n\t\t\told->it_value.tv_usec = old32[3];\n\t\t}\n\t\treturn __syscall_ret(r);\n\t}\n\treturn syscall(SYS_setitimer, which, new, old);\n#endif\n}\n","/*\n * Copyright 2021 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n */\n\n#define _GNU_SOURCE // for sighandler_t\n#include <stdbool.h>\n#include <stddef.h>\n#include <signal.h>\n\n#include \"emscripten_internal.h\"\n\nextern struct sigaction __sig_actions[_NSIG];\nextern sigset_t __sig_pending;\n\nbool __sig_is_blocked(int sig);\n\n// Default handler actions ~auto-generated from https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html.\n// Note that stop and continue actions are not supported and treated as ignored.\n\nvoid action_abort(int sig) {\n  abort();\n}\n\nvoid action_terminate(int sig) {\n  // Prepare to forcibly shut down runtime even if it has async work in flight.\n  _emscripten_runtime_keepalive_clear();\n  // Intentionally exiting via a function that doesn't call atexit handlers.\n  _Exit(128 + sig);\n}\n\nstatic sighandler_t default_actions[_NSIG] = {\n  [SIGABRT] = action_abort,\n  [SIGALRM] = action_terminate,\n  [SIGBUS] = action_abort,\n  [SIGFPE] = action_abort,\n  [SIGHUP] = action_terminate,\n  [SIGILL] = action_abort,\n  [SIGINT] = action_terminate,\n  [SIGKILL] = action_terminate,\n  [SIGPIPE] = action_terminate,\n  [SIGQUIT] = action_abort,\n  [SIGSEGV] = action_abort,\n  [SIGTERM] = action_terminate,\n  [SIGUSR1] = action_terminate,\n  [SIGUSR2] = action_terminate,\n  [SIGPOLL] = action_terminate,\n  [SIGPROF] = action_terminate,\n  [SIGSYS] = action_abort,\n  [SIGTRAP] = action_abort,\n  [SIGVTALRM] = action_terminate,\n  [SIGXCPU] = action_abort,\n  [SIGXFSZ] = action_abort,\n};\n\nint raise(int sig) {\n  if (__sig_is_blocked(sig)) {\n    sigaddset(&__sig_pending, sig);\n    return 0;\n  }\n  if (__sig_actions[sig].sa_flags & SA_SIGINFO) {\n    siginfo_t t = {0};\n    __sig_actions[sig].sa_sigaction(sig, &t, NULL);\n  } else {\n    sighandler_t handler = __sig_actions[sig].sa_handler;\n    if (handler == SIG_DFL) {\n      handler = default_actions[sig];\n      if (handler) {\n        handler(sig);\n      }\n    } else if (handler != SIG_IGN) {\n        // Avoid a direct call to the handler, and instead call via JS so we can\n        // avoid strict signature checking.\n        // https://github.com/emscripten-core/posixtestsuite/issues/6\n        __call_sighandler(handler, sig);\n    }\n  }\n  return 0;\n}\n","#include <stdlib.h>\n#include \"syscall.h\"\n\n_Noreturn void _Exit(int ec)\n{\n#ifdef __EMSCRIPTEN__\n\t__wasi_proc_exit(ec);\n#else\n\t__syscall(SYS_exit_group, ec);\n\tfor (;;) __syscall(SYS_exit, ec);\n#endif\n}\n","/*\n * Copyright 2021 The Emscripten Authors.  All rights reserved.\n * Emscripten is available under two separate licenses, the MIT license and the\n * University of Illinois/NCSA Open Source License.  Both these licenses can be\n * found in the LICENSE file.\n */\n\n#define _GNU_SOURCE // for sigorset/sigandset\n#include <stdbool.h>\n#include <threads.h>\n#include <signal.h>\n#include <errno.h>\n#include \"libc.h\"\n\n#define SST_SIZE (_NSIG/8/sizeof(long))\n\nstatic thread_local sigset_t __sig_mask;\nsigset_t __sig_pending;\n\nstatic int siginvertset(sigset_t *dest, const sigset_t *src) {\n  unsigned long i = 0, *d = (void*) dest, *s = (void*) src;\n  for(; i < SST_SIZE; i++) d[i] = ~s[i];\n  return 0;\n}\n\nbool __sig_is_blocked(int sig) {\n  return sigismember(&__sig_mask, sig);\n}\n\nint pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict old) {\n  if (old) {\n    *old = __sig_mask;\n  }\n\n  switch (how) {\n    case SIG_SETMASK:\n      __sig_mask = *set;\n      break;\n    case SIG_BLOCK:\n      sigorset(&__sig_mask, &__sig_mask, set);\n      break;\n    case SIG_UNBLOCK: {\n      sigset_t tmp;\n      siginvertset(&tmp, set);\n      sigandset(&__sig_mask, &__sig_mask, &tmp);\n      break;\n    }\n    default:\n      return EINVAL;\n  }\n\n  // These two signals can never be blocked.\n  sigdelset(&__sig_mask, SIGKILL);\n  sigdelset(&__sig_mask, SIGSTOP);\n\n  // Raise any pending signals that are now unblocked.\n  for (int sig = 0; sig < _NSIG; sig++) {\n    if (sigismember(&__sig_pending, sig) && !sigismember(&__sig_mask, sig)) {\n      sigdelset(&__sig_pending, sig);\n      raise(sig);\n    }\n  }\n\n  return 0;\n}\n\nint sigpending(sigset_t *set) {\n  *set = __sig_pending;\n  return 0;\n}\n","#include <signal.h>\n#include <errno.h>\n\nint sigaddset(sigset_t *set, int sig)\n{\n\tunsigned s = sig-1;\n\tif (s >= _NSIG-1 || sig-32U < 3) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tset->__bits[s/8/sizeof *set->__bits] |= 1UL<<(s&8*sizeof *set->__bits-1);\n\treturn 0;\n}\n","#include <signal.h>\n\nint sigismember(const sigset_t *set, int sig)\n{\n\tunsigned s = sig-1;\n\tif (s >= _NSIG-1) return 0;\n\treturn !!(set->__bits[s/8/sizeof *set->__bits] & 1UL<<(s&8*sizeof *set->__bits-1));\n}\n"],"names":["ETCTextureDecompress(void const*, unsigned int, unsigned int, void*, unsigned int)","PVRTDecompressETC(void const*, unsigned int, unsigned int, void*, unsigned int)","PVRTDecompressPVRTC(void const*, unsigned int, unsigned int, unsigned int, unsigned char*)","TwiddleUV(unsigned int, unsigned int, unsigned int, unsigned int)","_Exit","__errno_location","__sig_is_blocked","__throw_bad_alloc_shim()","_emscripten_timeout","abort","action_abort","action_terminate","dlfree","dlmalloc","emscripten_get_heap_size","interpolateColors(Pixel32, Pixel32, Pixel32, Pixel32, Pixel128S*, unsigned char)","isPowerOf2(unsigned int)","operator delete(void*)","operator delete[](void*)","operator new(unsigned long)","operator new[](unsigned long)","operator_new_impl(unsigned long)","prepend_alloc","raise","sigaddset","sigismember","std::__2::vector<Pixel32, std::__2::allocator<Pixel32>>::vector[abi:ne200100](unsigned long)","unpackModulations(PVRTCWord const&, int, int, int (*) [8], int (*) [8], unsigned char)","void std::__2::__libcpp_operator_delete[abi:ne200100]<Pixel32*, unsigned long>(Pixel32*, unsigned long)"],"mappings":"yjBEoHiB,OAxDU,OAAsB,CAUzB,MACA,GAAiB,SAKR,CAwChB,EAvCE,GAAF,EFlERc,IAA8BA,CEkEtB,CAA6B,EAAI,IAA7C,G,GACC,EAAM,KAsCV,EAxBY,QAwBZ,G,ECi6IFD,qCA+BkBA,CA/BlBA,EAoC4BA,cAFXA,SAAOA,CAAPA,KACCA,CACmBA,OAEVA,CAFCA,EAEOA,MAEDA,IAAdA,OACAA,OACGA,QAEPA,QANmBA,EAMnBA,6CACAA,8BAMcA,GAANA,KACMA,IAIqBA,SAAUA,WAAFA,CAEvCA,KACIA,OACGA,QAEPA,QAN+BA,EAM/BA,wCAMIA,IACIA,KANoBA,WAOxBA,cACAA,sC,CAAAA,oFAOKA,GAAaA,KAhHtCA,KACSA,CAADA,IACAA,QAAaA,SAETA,W,CAAAA,OAAZA,MACkBA,QAAaA,GAClBA,2BAFbA,IAYQA,sDAAZA,EAAYA,8EAsGWA,OAGNA,WACGA,GAAaA,gBAjM7BA,CAiM6BA,EAjM7BA,8CACUA,CAADA,IAAqBA,E,CAD9BA,EAC8BA,mBAEFA,EAFEA,EAEFA,MAAHA,GAIHA,YAAaA,GAClBA,eAEcA,aAGlBA,iBACDA,IADIA,CACJA,MACQA,YAMHA,OAJHA,IAORA,K,CAAAA,EAAKA,MACaA,WAAwBA,GAC/BA,KAGTA,KACKA,CAADA,O,EAIZA,IACkBA,UAAaA,GAClBA,OAILA,2B,GAAAA,QANRA,IAUWA,UAAuBA,GAAOA,GAArBA,CAATA,EAKCA,sDAAhBA,EAAgBA,qEAsJDA,EAtJCA,GAsJMA,GAAPA,GAtJCA,EAsJDA,GAEeA,KADQA,WAEhBA,CAFgBA,EAGCA,WAEvBA,oBACAA,IACJA,SAKIA,mDAEEA,MAKEA,EALFA,GAKQA,GAANA,GALFA,EAKEA,GACmBA,gBACTA,GACMA,KAAFA,WACNA,CAARA,SACRA,QACMA,MA3+CCA,QAk4BPA,GATRA,aASQA,GATRA,QAn4B2BA,cADLA,MAqCRA,eAGmCA,QApCtBA,QAOZA,OAy3BfA,EASQA,WACEA,UAEHA,GAAgBA,EAFbA,EAEaA,GACJA,GAAUA,KAClBA,KAAgBA,eA0BCA,M,CA1BDA,EA0BHA,WAGCA,GAAJA,EAHGA,EAGHA,KAt2CDA,OAAPA,EAAOA,EAAPA,CAAOA,EAA8BA,SAANA,CAAXA,CAARA,GAEPA,KAAMA,QAw2CIA,MACXA,UAGAA,aAHAA,EAIkCA,KAAzBA,WAAJA,IAEAA,E,EAAAA,CACyCA,KAC3CA,GAAqBA,EADsBA,EACtBA,WACpBA,KAAeA,UACNA,IAAuBA,KADaA,KASlDA,QAGUA,IAA8BA,OAASA,KAALA,CAAXA,CADUA,WAQ5CA,UAEOA,CAFPA,EACgDA,OAESA,GAAzCA,KAAyCA,KAAzCA,OAEQA,MACXA,cALmCA,OAFjDA,UAuBFA,UAoBSA,QACCA,QAEPA,CAAUA,gBACMA,WACJA,CAALA,UAUAA,cAAeA,GAAfA,EAAUA,CAAVA,EAAUA,GACPA,WAEhBA,GAADA,EAFiBA,EAEjBA,KAyB+BA,SAAWA,OAANA,GAAZA,GACkBA,aA1B1CA,GACOA,GAAgBA,E,EAAAA,K,EADvBA,EACuBA,GACLA,aAENA,QADAA,UAIMA,SADCA,GAAVA,QADKA,SA7QJA,SACNA,MAAUA,YAFMA,KAAdA,CAAdA,UAoRgDA,KApShCA,MAEVA,GAGKA,QAJcA,KAGlBA,WAESA,CAARA,GAEqBA,OAAKA,SACVA,GAAVA,GA2RFA,QAiBuBA,gBAAvCA,CAAuCA,EAGdA,iBAxTLA,MACSA,GAGlBA,WAqT4BA,GAAQA,GAvTrCA,KAGKA,WACKA,CAARA,GAEqBA,OAAKA,SACVA,GAAVA,GAiTNA,OA+TAA,OAtCIA,MAvReA,GAuRfA,EAvRUA,CAuRVA,EAvRUA,GACQA,kBAEIA,IAAKA,EAALA,KAAKA,GAALA,EACoBA,KAD3BA,QAGVA,QAAsBA,SA5+CnBA,SAAPA,EAAOA,EAAPA,CAAOA,EAA8BA,SAANA,CAAXA,GAARA,GAEPA,OAAMA,IAFCA,OA+wCWA,KArGpBA,MAEVA,GAGKA,QAJcA,KAGlBA,WAESA,CAARA,GAEqBA,OAAKA,SACVA,GAAVA,SAkFEA,MADMA,GAEJA,SACUA,CAAXA,CAALA,KAYZA,QACSA,wBAXsBA,CAenBA,MAFAA,QADAA,UAEEA,OAbIA,SAmBNA,OAEaA,OAHHA,GAGUA,QAQxBA,OAIJA,aAFmBA,WAEnBA,kBACAA,CADAA,EACAA,iC,CAAAA,8F,EAAAA,yC,CAAAA,sMA4MYA,GAALA,UACuBA,gBACTA,GACMA,KAAFA,WACLA,CAARA,SACRA,QAGOA,M,GAIfA,YArByBA,OACAA,aA3R7BS,IA4R2BT,EA3RTS,OA2RST,EA3RTS,EAKdA,QAsRuBT,EA1RFS,KAEPA,OACOA,UAQFA,GAREA,EAQRA,CARQA,EAQRA,GAEFA,WADmBA,iBAEVA,CAARA,GAEZA,MACwBA,GADxBA,EACkBA,CADlBA,EACkBA,GAERA,WADmBA,iBAEzBA,cACJA,GAESA,eAADA,IACeA,GACfA,mWACWA,KAGfA,OAFUA,QAEVA,mCACAA,CADAA,EACAA,iC,CAAAA,sG,EAAAA,yC,CAAAA,wLAKGA,CAuPgBT,KA4QXA,2GAAsBA,KAAtBA,EAAsBA,EAAtBA,eAAsBA,KAAtBA,0BACUA,CADVA,EAEsCA,WAAlCA,+BAEAA,eACAA,mBACAA,CADAA,EACAA,iC,CAAAA,sG,EAAAA,mC,CAAAA,wLAEGA,GAwIUA,GA1GrBA,yGAAsBA,KAAtBA,EAAsBA,EAAtBA,eAAsBA,KAAtBA,0BACUA,CADVA,EAEsCA,WAAlCA,+BAEAA,eACAA,cACAA,sC,CAAAA,4EAEGA,IAoJnBA,U,KAWYD,WAKWA,OAYsBA,QACdA,CACEA,WACZA,CAADA,MAEIA,WAOiBA,WAGLA,CAARA,kBACaA,GADbA,EACMA,CADNA,EAEIA,2KAEYA,SAAKA,GAAcA,MACpBA,WACXA,qBAkEhCA,EAtEgCA,kLAaJA,KAAiBA,EAAGA,UAA5BA,eACKA,C,CADLA,EACIA,GACgBA,GADhBA,EACSA,CADTA,EACSA,GAEGA,WADmBA,iBAEXA,CAARA,QACKA,GAAPA,QAESA,QADJA,GAkDvCA,KA3C6CA,GAAPA,EA2CtCA,EA3CsCA,CA2CtCA,EA3CsCA,GAEHA,WADmBA,iBAE1BA,cAwC5BA,MApC2CA,CACTA,KACNA,kMASJA,gCATIA,kKACAA,cACMA,UACSA,KA+B3CA,OAvBwBA,CAuBxBA,EAvBwBA,KACAA,uBADAA,CACAA,I,CAAAA,sDAsBxBA,aAjBwBA,CAiBxBA,EAjBwBA,+B,EAAAA,2C,CAAAA,wMAEIA,UAAqBA,OAejDA,C,CClwJA,GACA,EACA,C,EAKA,EAEA,EAEA,CAEA,EACA,CACA,EACA,EACA,EACA,C,CAIA,GACA,C,ECwqBAX,OAG0BA,KAH1BA,IAGOA,C,EAHPA,EAM+BA,EAA0CA,QAA1CA,IAHLA,QAG+CA,IAA1CA,MAAwCA,CAA2CA,GCxoBzGmB,EDyoBGnB,MAEVA,E,CAAAA,EAMAA,ECtnBsDgB,EDsnBtDhB,oBANAA,CAMAA,EANAA,cAGCA,O,CAAAA,EAAHA,OAAGA,CAAHA,QAAGA,S,CAAAA,WAAHA,GAAGA,CAAHA,QAAGA,WAH4BA,CAA7BA,cAGCA,KAAHA,OAAGA,CAAHA,QAAGA,OAGDA,ECtnBsDgB,EDsnBtDhB,GAIUA,sCAOVA,e,CAAAA,EAGYA,SADJA,OAEEA,GADAA,OADFA,OACIA,OAAFA,GACAA,OAFFA,OACIA,OAAFA,GACAA,OAFFA,OACIA,OAAFA,GACAA,WACHA,OALPA,mBAGYA,SADJA,OAEEA,GADAA,WAEHA,OALPA,cAD4BA,CAANA,KAAvBA,IASAA,G,EAvIDD,sBAYcA,qBAMOA,YACAA,CADAA,EAYkCA,IAASA,GAAqDA,CAXhGA,KAMkBA,KAKgBA,CAAMA,IAcrBA,KAAMA,KAAgBA,CAATA,GAZAA,IAAyDA,IAYzDA,KAjBfA,KAKeA,CAAMA,IAUpBA,KAAKA,KAAeA,CAARA,GAXMA,IAASA,GAAkDA,CAWjEA,IAhBSA,IAApBA,KAKiBA,CAAMA,IAYtBA,KAAOA,KAAiBA,CAAVA,OAHDA,CAATA,SAFMA,CAARA,SACcA,CAAVA,GAM5CA,GAiBmCA,IACaA,CAlBhDA,IAiBmCA,CACKA,QATLA,KACaA,CAARA,UALJA,KACeA,CAATA,SAScA,IAAnBA,MACOA,WAHaA,IAArBA,KACeA,CAATA,SAPeA,IAApBA,KACiBA,CAAVA,IAnC1BA,EAmC0BA,oFAgBxCA,I,CAAAA,iBA7EAA,KA6EAA,QAhFyCA,wBAG7BA,aAAZA,YACEA,IAAcA,aAAdA,YAGYA,CAFbA,GAAaA,aAAbA,WAE4BA,MAAQA,CAkFZA,KAtFzBA,KAsFyBA,QA5FgCA,eAAoCA,YAMjFA,aAAZA,YACEA,IAAcA,aAAdA,YAGYA,CAFbA,GAAaA,aAAbA,WAE4BA,MAAQA,CAiFhBA,KArFrBA,KAqFqBA,QAxFoBA,eAN7BA,YASAA,aAAZA,YACEA,IAAcA,aAAdA,YAGYA,CAFbA,GAAaA,aAAbA,WAE4BA,MAAQA,CAkFZA,KAtFzBA,KAsFyBA,QA5FgCA,eAAoCA,YAMjFA,aAAZA,YACEA,IAAcA,aAAdA,YAGYA,CAFbA,GAAaA,aAAbA,WAE4BA,MAAQA,CAiFhBA,OAJIA,KAANA,CAAtBA,K,EAYAA,6CAtGWA,CA0GTA,GAjGCA,KATYA,aAGRA,gDAMQA,aAAZA,YACEA,IAAcA,aAAdA,YAGYA,CAFbA,GAAaA,aAAbA,WAE4BA,MAAQA,CA6FhBA,GACtBA,KAlGCA,KATYA,aAGRA,2CAMQA,aAAZA,YACEA,IAAcA,aAAdA,YAGYA,CAFbA,GAAaA,aAAbA,WAE4BA,MAAQA,CA8FVA,OAHDA,KAANA,CAAtBA,SAFDA,YAZAA,WA/D4BA,CAAPA,KAAvBA,OAF6BA,CAAPA,KAAvBA,GAyFSA,OAAIA,CAAbA,C,EA1JDE,uBAKiDA,CAAZA,GAAhBA,kBACAA,QAGPA,UAAQA,G,CAARA,EAAQA,EAAgEA,SAArBA,WC7exDkB,ED6ewDlB,OApExDA,OEhckCwB,CAlBlCA,MCoHcA,sBHoWoBxB,mDAiEkEA,SAhEjEA,sBADDA,gDAWzCA,sFA/FyEA,WAAYA,GA4GnFA,gBATiEA,CAnGMA,KAAYA,GA6GnFA,QACAA,YACAA,cAWmCA,EACKA,OADLA,aAFAA,EACKA,OADLA,aAFAA,EACKA,OADLA,aAFAA,EACKA,KADLA,WAtKtCA,wBACAA,wBACAA,wBACAA,wBApUeA,CAoUfA,EAhUqDA,IADGA,GAApBA,OADmBA,GAArBA,OAFTA,IAIoBA,KAA8BA,CAAtBA,GAErDA,GAM2DA,KADZA,KAAQA,KAA4BA,CAAtBA,QADhBA,KAASA,KAA6BA,CAAvBA,OAGHA,GAArBA,GAPpCA,IAM8CA,KAAXA,KAA6CA,CAArBA,EAwT3DA,EAvToCA,oCAbrBA,CAaqBA,EATiBA,IADGA,GAApBA,OADmBA,GAArBA,OAFTA,IAIoBA,KAA8BA,CAAtBA,GAErDA,GAM2DA,KADZA,KAAQA,KAA4BA,CAAtBA,QADhBA,KAASA,KAA6BA,CAAvBA,OAGHA,GAArBA,GAPpCA,IAM8CA,KAAXA,KAA6CA,CAArBA,EACvBA,sCAbrBA,CAaqBA,EATiBA,IADGA,GAApBA,OADmBA,GAArBA,OAFTA,IAIoBA,KAA8BA,CAAtBA,GAErDA,GAM2DA,KADZA,KAAQA,KAA4BA,CAAtBA,QADhBA,KAASA,KAA6BA,CAAvBA,OAGHA,GAArBA,GAPpCA,IAM8CA,KAAXA,KAA6CA,CAArBA,EACvBA,sCAbrBA,CAaqBA,EATiBA,IADGA,GAApBA,OADmBA,GAArBA,OAFTA,IAIoBA,KAA8BA,CAAtBA,GAErDA,GAM2DA,KADZA,KAAQA,KAA4BA,CAAtBA,QADhBA,KAASA,KAA6BA,CAAvBA,OAGHA,GAArBA,GAPpCA,IAM8CA,KAAXA,KAA6CA,CAArBA,EACvBA,8BA0TpCA,sEAlSoCA,EAkSpCA,MA/SIA,CA+SJA,EA/SIA,IAIsDA,GAAvBA,OADyBA,GAAxBA,OADuBA,GAAzBA,KAIlCA,SAM+CA,KAAWA,KAAgCA,CAAzBA,UADjBA,KAAYA,KAAiCA,CAA1BA,WADrBA,KAAaA,KAAkCA,CAA3BA,OAGLA,GAAzBA,kCAbhCA,CAagCA,EAbhCA,IAIsDA,GAAvBA,OADyBA,GAAxBA,OADuBA,GAAzBA,KAIlCA,SAM+CA,KAAWA,KAAgCA,CAAzBA,UADjBA,KAAYA,KAAiCA,CAA1BA,WADrBA,KAAaA,KAAkCA,CAA3BA,OAGLA,GAAzBA,kCAbhCA,CAagCA,EAbhCA,IAIsDA,GAAvBA,OADyBA,GAAxBA,OADuBA,GAAzBA,KAIlCA,SAM+CA,KAAWA,KAAgCA,CAAzBA,UADjBA,KAAYA,KAAiCA,CAA1BA,WADrBA,KAAaA,KAAkCA,CAA3BA,OAGLA,GAAzBA,kCAbhCA,CAagCA,EAbhCA,IAIsDA,GAAvBA,OADyBA,GAAxBA,OADuBA,GAAzBA,KAIlCA,SAM+CA,KAAWA,KAAgCA,CAAzBA,UADjBA,KAAYA,KAAiCA,CAA1BA,WADrBA,KAAaA,KAAkCA,CAA3BA,OAGLA,GAAzBA,0BAmSpCA,yFAICA,kCAEwEA,eAmLzBA,CAtPxCA,E,CAmEiEA,EAnEjEA,MAKHA,OAA4BA,E,CALzBA,EAKiDA,UAATA,QAAPA,cAI5BA,OAAaA,C,CAAbA,EAAqCA,UAATA,QAAPA,aAIKA,OAEnBA,eAATA,QAAsDA,OAATA,QAAFA,KAAwDA,MAATA,QAAFA,CAClFA,OAATA,QADwIA,GAC7FA,GAAKA,CADrDA,GAOiBA,eAATA,QAAsDA,OAATA,QAAFA,GAA6CA,GAAKA,CAArGA,GAKiBA,eAATA,QAAsDA,OAATA,QAAFA,GAA6CA,GAAKA,CAArGA,SAMKA,MAkCiEA,EAW+BA,SAT9FA,IASmGA,EAFhEA,SAA7BA,CAAoDA,QAEoCA,KAAKA,CAA1DA,EAFQA,GAEHA,EAFxCA,SAEmCA,KAAKA,CAAYA,GAAgDA,GADVA,KAAMA,GAA5DA,KAAMA,GAAYA,GAAiDA,GADrEA,OAAIA,CAAgDA,KAAIA,GAAxCA,GAA+CA,OAG3GA,E,CAAAA,EAGqGA,KAAMA,GAA5DA,KAAMA,GAAYA,GAAiDA,IAMnFA,MAOlCA,EATOA,MAEPA,EAFOA,KASPA,8BA9BmCA,CAAdA,KAAvBA,OAFqCA,KAAfA,CAAvBA,2BAuGCA,gCAEoHA,CAAnHA,GAAmHA,KAAFA,QAEjHA,KAAmGA,KAAFA,MAEjGA,KAAkGA,KAAFA,QAEhGA,KAAkFA,KAAFA,UARxCA,CAAlBA,KAAvBA,2CAEoHA,CAAnHA,GAAmHA,KAAFA,QAEjHA,KAAmGA,KAAFA,MAEjGA,KAAkGA,KAAFA,QAEhGA,KAAkFA,KAAFA,UARxCA,CAAlBA,KAAvBA,GAiC+BA,WAA/BA,MAH8BA,WAAyBA,GAAxDA,MEvdC0B,ED2DsDX,EDwdlCf,MAGpBA,6BAECA,0C,CAAAA,EAAqEA,WAA/BA,EAAiEA,SAAxBA,EAAFA,YAA9CA,CAAsCA,OAA/BA,EAAiEA,SAAxBA,EAAFA,YAA9CA,CAAsCA,OAA/BA,EAAiEA,SAAxBA,EAAFA,YAA9CA,CAAsCA,OAA/BA,EAAiEA,SAAxBA,EAAFA,UAA9CA,CAA/BA,kBAAqEA,WAA/BA,EAAiEA,SAAxBA,EAAFA,UAA9CA,OAA/BA,cAF8BA,CAARA,KAAvBA,GAMAA,QCjesDe,GDmevDf,QA9BaA,aASmCA,CAT1BA,EA8BtBA,C,MC9iBDmB,EAiBYF,EAjBZE,IACWA,IAGGA,QAAZA,EAAYA,E,GMyBL,MNrBDA,OAKNA,GAJIA,Q,EASEF,E,CADIA,EIvBV,IJ0BAA,G,KD8YWhB,aACAA,KAAZA,MAlBIa,YAmBJb,MAnBIa,YAoBJb,EAGUA,iBAOOA,CAPPA,EAOVA,0BAIKA,GAAKA,KAALA,QAFKA,KAALA,CAEAA,OAIOA,OADDA,OADAA,CANMA,KAAjBA,IAPUA,OAmBDA,OACmBA,CAANA,CAAbA,GAETA,EA5BAA,gBACAA,gBACAA,gBACAA,gB,EArQDwB,OACuCA,SAI9BA,CAJ8BA,EAMjCA,E,CAAAA,uFA8DFA,UAECA,MAAwFA,GAFzFA,gBAOoBA,QALnBA,OAAwFA,YAKpFA,UALJA,OAAwFA,YAKpFA,UALJA,OAAwFA,YAKpFA,UALJA,OAAwFA,YAKpFA,UALJA,OAAwFA,YAKpFA,UALJA,OAAwFA,YAKpFA,UALJA,OAAwFA,YAKpFA,cAKWA,OAdWA,KAANA,CAAtBA,MA5DGA,MAKgBA,C,CALhBA,EAKCA,kBAMgBA,WAaAA,CAbAA,EAafA,OAGYA,GAChBA,UAIgBA,UAchBA,UAECA,IAAwFA,KAFzFA,KAK0BA,SAfvBA,UAAeA,CAAfA,KAeiIA,CAAjBA,SAHlHA,IAAwFA,WAAxFA,IAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,UAHlHA,IAAwFA,YAAxFA,IAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,UAHlHA,IAAwFA,YAAxFA,IAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,UAHlHA,IAAwFA,WAFzFA,IAECA,KAAwFA,KAAxFA,KAAwFA,KAFzFA,KAK0BA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,SALnHA,IAECA,KAAwFA,KAFzFA,KAK0BA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,WAFzFA,IAECA,KAAwFA,KAAxFA,KAAwFA,KAFzFA,KAK0BA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,GADmHA,CAAjBA,GAHlHA,KAAwFA,KAAxFA,KAAwFA,KAG/DA,SACTA,CADkGA,GAqEvHA,yBArCMA,YAMwFA,WAEIA,E,GAAAA,aAqBJA,KACIA,WAE9EA,GAH0EA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,WAE9EA,GAJ2FA,KACjBA,KACIA,KAOlGA,MAxBKA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,0BAKeA,GAZ2FA,CAAjBA,KAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,GAZ2FA,CAAjBA,SAEIA,U,GAAAA,WAK7FA,sBAKeA,CAZ0EA,KAEIA,Q,GAAAA,WAQHA,GAqB/FA,MAzB+FA,GAyB/FA,MA5BgGA,IA4BhGA,C,KAlNmIZ,KADAA,KAK1CA,KAJYA,KADAA,KAKhCA,KAJCA,KADAA,KAKrBA,KAJRA,KADAA,KAKXA,KANqGA,KADAA,KAM1CA,KALYA,KADAA,KAMhCA,KALCA,KADAA,KAMrBA,KALRA,KADAA,KAMXA,eATrBA,CAaDA,GAOEA,KADDA,OADCA,OADFA,OADEA,OADDA,OADCA,OADFA,aAbCA,CAaDA,EASCA,QAQDA,IAKiEA,IAAsBA,CALvFA,IAKiEA,CAAMA,CAA3CA,SADmCA,CAAMA,GAA1CA,SADsCA,CAAMA,GAA3CA,SADiCA,CAAMA,GAAzCA,GAJoDA,aADrBA,CAahDA,KALwDA,KAAsBA,CAAhBA,CAA3CA,IAP8BA,aADdA,CAYpCA,KALuDA,KAAqBA,CAAfA,CAA1CA,IANWA,aADRA,CAWrBA,KALwDA,KAAsBA,CAAhBA,CAA3CA,IALTA,aADDA,CAUXA,KALsDA,KAAoBA,CAAdA,CAAzCA,IAQjBA,WALwDA,KAAsBA,CAAhBA,CAA3CA,IAIpBA,WALuDA,KAAqBA,CAAfA,CAA1CA,IAIlBA,WALwDA,KAAsBA,CAAhBA,CAA3CA,IAIrBA,WALsDA,KAAoBA,CAAdA,CAAzCA,IAQjBA,WALwDA,KAAsBA,CAAhBA,CAA3CA,IAIpBA,WALuDA,KAAqBA,CAAfA,CAA1CA,IAIlBA,WALwDA,KAAsBA,CAAhBA,CAA3CA,IAIrBA,WALsDA,KAAoBA,CAAdA,CAAzCA,IAmBtBA,OADDA,OADCA,OADFA,OAFEA,OADDA,OADCA,OADFA,WAlB6BA,KAAdA,CAAvBA,K,EAHOA,SAsC6EA,SAApBA,OAApBA,OAAnBA,WADsCA,OAAbA,OAAdA,OAAZA,yBAKtBA,QAGqEA,CAAMA,GAA3CA,SADmCA,KAAqBA,CAAfA,CAA1CA,SADsCA,KAAsBA,CAAhBA,CAA3CA,SADiCA,KAAoBA,CAAdA,CAAzCA,GAQjBA,OADDA,OADCA,OADFA,WAPyBA,CAAdA,KAAvBA,GAqBSA,OADDA,OADCA,OADFA,OAFEA,OADDA,OADCA,OADFA,WAlB8BA,KAAfA,CAAvBA,IA6BFA,C,EMtKCN,I,CEcDD,cAyBCA,G,EGjCQF,MHiCRE,UAvBUA,QCsBLe,EIvDNE,EACiBA,CAETA,IJoDFF,EGhDgCC,WHiDlCD,EGjDkCC,EALrBA,CAK2BA,CAANA,IHsEtCD,OAZgBA,KACNA,EAWVA,EAVQA,SDTRf,C,ECtCEE,I,EAKAC,OAEUA,CCxBXP,GDwBCO"}